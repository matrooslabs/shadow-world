# Create Incognito Action
Source: https://docs.world.org/api-reference/create-incognito-action

openapi/world-miniapps.json post /api/v2/create-action/{app_id}
Create an incognito action for your app.



# Get Prices
Source: https://docs.world.org/api-reference/get-prices

openapi/world-miniapps.json get /public/v1/miniapps/prices
Query latest prices of tokens in various fiat currencies.



# Get Transaction
Source: https://docs.world.org/api-reference/get-transaction

openapi/world-miniapps.json get /api/v2/minikit/transaction/{transaction_id}
Query transactions for their current status.



# Get Transaction Debug URL
Source: https://docs.world.org/api-reference/get-transaction-debug-url

openapi/world-miniapps.json get /api/v2/minikit/transaction/debug
Debug transactions that failed during the prepare stage. Returns Tenderly URLs when applicable.



# Get User Grant Cycle
Source: https://docs.world.org/api-reference/get-user-grant-cycle

openapi/world-miniapps.json get /api/v2/minikit/user-grant-cycle
Retrieve the next grant claim date for a user of your mini app. Returns the user's humanity (orb-verified) grant cycle date if available, otherwise falls back to their document (passport-verified) grant cycle date.



# Send Notification
Source: https://docs.world.org/api-reference/send-notification

openapi/world-miniapps.json post /api/v2/minikit/send-notification
Send notifications to users of your mini app.



# Verify Proof
Source: https://docs.world.org/api-reference/verify-proof

openapi/world-miniapps.json post /api/v2/verify/{app_id}
Verify a World ID proof for a Cloud action.



# World Developer Docs
Source: https://docs.world.org/index

Build Mini Apps, integrate World ID, and deploy on World Chain with official developer documentation.

<div>
  <a href="https://world.org/blog/announcements/dev-rewards-pilot-increases-to-100k-per-week-as-the-world-ecosystem-surpasses-500-mini-apps" aria-label="Now live: $100K in developer rewards per week.">
    <div>
      <span>ðŸ’°</span>

      <span>
        Now live: \$100K in developer rewards per week.
      </span>

      <span>
        Learn more
      </span>
    </div>
  </a>
</div>

Choose your integration path:

* **Mini Apps** â€“ Build native-like applications that run inside World App with the most distribution, leveraging World ID and the wallet.
* **External Integrations** â€“ Add World ID's proof-of-personhood verification to your existing platform.
* **World Chain** â€“ Build directly on our blockchain infrastructure.

<div>
  <div>
    <a href="/mini-apps" aria-label="Mini Apps" />

    <img alt="Mini Apps" />

    <div>
      <h3>Create a Mini App</h3>
      <p>Native like applications integrated in World App</p>
    </div>
  </div>

  <div>
    <a href="/world-id" aria-label="IDKit" />

    <img alt="IDKit" />

    <div>
      <h3>Use IDKit</h3>

      <p>
        World ID verification for your website or app
      </p>
    </div>
  </div>

  <div>
    <a href="/world-chain/index" aria-label="World Chain" />

    <img alt="World Chain" />

    <div>
      <h3>Integrate World Chain</h3>
      <p>A chain designed for real humans.</p>
    </div>
  </div>
</div>

<Warning>
  **Deprecation Notice**: Sign in with World ID v1 has been deprecated and will
  be shut down on **January 31, 2026**. Read more in the
  [announcement](/world-id/sign-in/deprecation).
</Warning>


# World Chat
Source: https://docs.world.org/mini-apps/commands/chat



The chat command allows your mini app to prompt users to share a message via World Chat. Users can send messages to individual contacts or groups.

## Using the command

```tsx theme={null}
import { MiniKit } from '@worldcoin/minikit-js'

const handleChat = async () => {
  if (!MiniKit.isInstalled()) {
    return
  }

  const { finalPayload } = await MiniKit.commandsAsync.chat({
    message: "Check out this awesome mini app!", // Required
    to: ["username1", "0x1234..."], // Optional: usernames or addresses, pre-selects them in the modal
  })

  if (finalPayload.status === "error") {
    console.log("Error:", finalPayload.error_code)
    return
  }

  console.log(`Message shared to ${finalPayload.count} chats`)
}
```

### Response

**Success:**
Upon success the user will be navigated to the chat tab and your mini app will be closed.
Thus, it's advised to include a link to your mini app in the message so they can easily return.

**Error payload:**

```tsx theme={null}
type ChatErrorPayload = {
  status: "error"
  error_code: "user_rejected" | "send_failed" | "generic_error"
  version: number
}
```

### Error Codes

| Code            | Description                                              |
| --------------- | -------------------------------------------------------- |
| `user_rejected` | User closed the modal                                    |
| `send_failed`   | Sending message failed (user might not be on World Chat) |
| `generic_error` | Any other error                                          |

### Command Preview

<div>
  <video>
    <source type="video/mp4" />

    Your browser does not support the video tag.
  </video>
</div>

## Universal Links to World Chat

You can create universal links to open World Chat from your mini app or any web page. These also work as deep links.

### Open the chat tab in World App

```
https://world.org/chat
```

### Open a conversation with a specific user

Opens a user-specific page with an action:

```
https://world.org/profile?username=andy&action=chat
```

| Query Param | Values                       | Description                  |
| ----------- | ---------------------------- | ---------------------------- |
| `username`  | e.g. `andy`                  | Username of the user         |
| `address`   | e.g. `0xdeadbeef`            | Wallet address of the user   |
| `action`    | `chat` \| `request` \| `pay` | Action to take with the user |

## Show Profile Card

Display a native profile card modal inside your app for social sharing and easy access to profiles.

```tsx theme={null}
MiniKit.showProfileCard({
  username: "andy", // Optional
  walletAddress: "0x1234..." // Optional
})
```

<Note>
  Adding profile cards anywhere you display usernames helps users discover and connect with each other, making your app feel more integrated with World App.
</Note>

<div>
  <video>
    <source type="video/mp4" />

    Your browser does not support the video tag.
  </video>
</div>


# Get Permissions
Source: https://docs.world.org/mini-apps/commands/get-permissions



This command lets you check the status of permissions a user has granted to your mini app.

## Using the command

Currently this command currently supports contacts, notifications, and microphone.

<Tabs>
  <Tab title="Async handlers">
    ### Sending the command and handling the response

    ```tsx theme={null}
    import { MiniKit, GetPermissionsPayload, Permission } from '@worldcoin/minikit-js'

    // Example function of how to use the command
    const getPermissions = useCallback(
        async () => {
            const payload = await MiniKit.commandsAsync.getPermissions();
            // Handle the response
        },
        []
    );
    ```
  </Tab>

  <Tab title="Event listeners">
    ### Sending the command

    ```tsx theme={null}
    // Example function of how to use the command
    const getPermissions = useCallback(
        () => {
            const payload = MiniKit.commands.getPermissions();
            },
        []
    );
    ```

    ### Handling the response

    ```tsx app/page.tsx theme={null}
    import { MiniKit, ResponseEvent } from '@worldcoin/minikit-js'
        // ...
        useEffect(() => {
            if (!MiniKit.isInstalled()) {
                console.error("MiniKit is not installed");
                return;
            }

            MiniKit.subscribe(
                ResponseEvent.MiniAppGetPermissions,
                async (response: MiniAppGetPermissionsPayload) => {
                    if (response.status == "success") {
                        const response = await res.json();
                        // Handle the response
                    }
                }
            );

            return () => {
                MiniKit.unsubscribe(ResponseEvent.MiniAppGetPermissions);
            };
        }, []);
    ```
  </Tab>
</Tabs>

## Response type

### Success response payload

```ts theme={null}
type MiniAppGetPermissionsSuccessPayload = {
    status: 'success';
    permissions: Permission[];
    version: number;    // same version that was received from MiniKit
};
```

```json theme={null}
{
  "permissions": {
    "notifications": false
  },
  "status": "success",
  "timestamp": "2025-03-11T18:21:49.741-07:00",
  "version": 1
}
```

### Error response payload

```ts theme={null}
type MiniAppGetPermissionsErrorPayload = {
	status: 'error'
	error_code: GetPermissionsErrorCodes
	version: number
}
```

The possible error codes are:

* `generic_error` - Request failed for unknown reason


# Send Notifications
Source: https://docs.world.org/mini-apps/commands/how-to-send-notifications



Please take a minute to read the [Features & Guidelines](/mini-apps/guidelines/features-and-guidelines).
It's important to follow these, otherwise we may disable your ability to send notifications.

To send notifications to users you need to:

* Request permission in the Developer Portal Advanced settings, for your mini app,
* Request permission to send notifications from the user, via MiniKit (see [Request Permission](/mini-apps/commands/request-permission)),
* Actually send the notification using our API or the Developer Portal.

Notifications are queued on our servers, users may not receive them immediately.

## Manually sending notifications from Developer Portal

<Note type="info">
  This form doesn't support localized notifications yet. To take advantage of
  localizations, use the API.
</Note>

You can send notifications to multiple wallet addresses (up to 1000) directly from the Developer Portal.

<div>
  <img alt="Notification Interface in the Developer Portal" />
</div>

Use the form to input addresses, and content details. Once you click the `Send` button and get a success response, your notifications will be queued for delivery.

## Calling the send-notification endpoint

The API endpoint provides capabilities for sending notifications programmatically. These notifications can be localized,
which ensures you reach users in their preferred language. This results in a dramatically higher engagement rate.

### Localization made simple

```javascript theme={null}
const response = await fetch(
  "https://developer.worldcoin.org/api/v2/minikit/send-notification",
  {
    method: "POST",
    headers: {
      Authorization: `Bearer ${process.env.API_KEY}`,
      "Content-Type": "application/json",
    },
    body: JSON.stringify({
      app_id: "your_app_id",
      wallet_addresses: ["0x123...", "0x456..."],
      localisations: [
        {
          language: "en",
          title: "ðŸŽ‰ Rewards Available",
          message: "Hey ${username}, your daily rewards are ready!",
        },
        {
          language: "es",
          title: "ðŸŽ‰ Recompensas Disponibles",
          message: "Hola ${username}, tus recompensas diarias estÃ¡n listas!",
        },
        {
          language: "fr",
          title: "ðŸŽ‰ RÃ©compenses Disponibles",
          message:
            "Salut ${username}, vos rÃ©compenses quotidiennes sont prÃªtes!",
        },
      ],
      mini_app_path: "worldapp://mini-app?app_id=your_app_id&path=/rewards",
    }),
  }
);
```

Each user automatically receives the notification in their preferred language.
If their language isn't included in your localizations, you'll receive a specific `reason` in the response.

For complete API documentation including all supported languages and response formats, see the [API Reference](/mini-apps/reference/api#send-notification).

## Testing

We currently have a limit of 40 notifications per 4 hours for unverified apps. This is to help you test your notification implementations.
Currently you will need to create a new app if your app is verified as it will default to the verified app's metadata. In addition, you need
to enable notifications for your mini app inside of World App to receive them.

## Useful links

* [Features & Guidelines](/mini-apps/guidelines/features-and-guidelines)
* [How To Request Notification Permissions](/mini-apps/commands/request-permission)
* [How To Get Notification Permissions](/mini-apps/commands/get-permissions)
* [Send Notification API Reference](/mini-apps/reference/api#send-notification)


# Pay
Source: https://docs.world.org/mini-apps/commands/pay



This command is essential for applications that need to facilitate payments directly within the app,
enabling seamless transactions for users. At launch, WLD and USDC will be supported.

**Example:** Enabling an e-commerce platform to allow users to purchase digital goods using cryptocurrencies,
providing a smooth checkout experience.

Payments are easy to use and only have three simple steps.

1. Creating the transaction
2. Sending the command
3. Verifying the payment

<Warning>For legal reasons, payments are not available in Indonesia and Philippines.</Warning>

## Setup

Payments are executed on-chain, so you'll need an [Ethereum compatible wallet](https://metamask.io/).
Next, whitelist the address in the [Developer Portal](https://developer.worldcoin.org/).
Whitelisting adds security to your mini app to prevent payments from being sent to an unauthorized addresses. Optionally you can
disable this check in the Developer Portal.

<img alt="Whitelist an Address" />

## Initiating the payment

For security, it's important you initialize and store your payment operation in the backend.

```tsx app/api/initiate-pay/route.ts theme={null}
import { NextRequest, NextResponse } from 'next/server'

export async function POST(req: NextRequest) {
	const uuid = crypto.randomUUID().replace(/-/g, '')

	// TODO: Store the ID field in your database so you can verify the payment later

	return NextResponse.json({ id: uuid })
}
```

## Using the command

<Tabs>
  <Tab title="Async handlers">
    ### Sending the command & handling the response

    We currently support WLD and USDC payments on Worldchain. Below is the expected input for the Pay command.
    Since World App sponsors the gas fee, there is a minimum transfer amount of \$0.1 for all tokens.

    ```tsx PayCommandInput theme={null}
    // Represents tokens you allow the user to pay with and amount for each
    export type TokensPayload = {
      symbol: Tokens;
      token_amount: string;
    };

    export type PayCommandInput = {
      reference: string;
      to: string;
      tokens: TokensPayload[];
      network?: Network; // Optional
      description: string;
    };
    ```

    For convenience, we offer a public endpoint to query the current price of WLD in various currencies detailed [here](/mini-apps/reference/api#get-prices).

    ```tsx app/page.tsx theme={null}
    import { MiniKit, tokenToDecimals, Tokens, PayCommandInput } from '@worldcoin/minikit-js'

    const sendPayment = async () => {
      const res = await fetch('/api/initiate-payment', {
        method: 'POST',
      })
      const { id } = await res.json()

      const payload: PayCommandInput = {
        reference: id,
        to: '0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045', // Test address
        tokens: [
          {
            symbol: Tokens.WLD,
            token_amount: tokenToDecimals(1, Tokens.WLD).toString(),
          },
          {
            symbol: Tokens.USDC,
            token_amount: tokenToDecimals(3, Tokens.USDC).toString(),
          },
        ],
        description: 'Test example payment for minikit',
      }

      if (!MiniKit.isInstalled()) {
        return
      }

      const { finalPayload } = await MiniKit.commandsAsync.pay(payload)

      if (finalPayload.status == 'success') {
        const res = await fetch(`/api/confirm-payment`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(finalPayload),
        })
        const payment = await res.json()
        if (payment.success) {
          // Congrats your payment was successful!
        }
      }
    }
    ```
  </Tab>

  <Tab title="Event listeners">
    ### Sending the command

    We currently support WLD and USDC payments on Worldchain. Below is the expected input for the Pay command.
    Since World App sponsors the gas fee, there is a minimum transfer amount of \$0.1 for all tokens.

    ```tsx PayCommandInput theme={null}
    // Represents tokens you allow the user to pay with and amount for each
    export type TokensPayload = {
      symbol: Tokens;
      token_amount: string;
    };

    export type PayCommandInput = {
      reference: string;
      to: string;
      tokens: TokensPayload[];
      network?: Network; // Optional
      description: string;
    };
    ```

    For convenience, we offer a public endpoint to query the current price of WLD in various currencies detailed [here](/mini-apps/reference/api#get-prices).

    ```tsx app/page.tsx theme={null}
    import { MiniKit, tokenToDecimals, Tokens, PayCommandInput } from '@worldcoin/minikit-js'
        // ...
        const sendPayment = async () => {
          const res = await fetch('/api/initiate-payment', {
            method: 'POST'
          });
          const { id } = await res.json();

          const payload: PayCommandInput = {
            reference: id,
            to: "0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045", // Test address
            tokens: [
              {
                symbol: Tokens.WLD,
                token_amount: tokenToDecimals(1, Tokens.WLD).toString(),
              },
              {
                symbol: Tokens.USDC,
                token_amount: tokenToDecimals(3, Tokens.USDC).toString(),
              },
            ],
            description: "Test example payment for minikit",
          };

          if (MiniKit.isInstalled()) {
            MiniKit.commands.pay(payload);
          }
        };
    ```

    ### Handling the response

    Once World App receives the command, the user will be prompted to confirm the payment via a drawer. After that the app will send the payment to our relayer to be submitted on-chain.
    The response does not wait until the transaction is mined. **Thus, it's critical to confirm the payment in your backend.**

    ```tsx app/page.tsx theme={null}
    import { MiniKit, tokenToDecimals, Tokens, PayCommandInput, ResponseEvent } from '@worldcoin/minikit-js'
      useEffect(() => {
        if (!MiniKit.isInstalled()) {
          console.error("MiniKit is not installed");
          return;
        }

        MiniKit.subscribe(
          ResponseEvent.MiniAppPayment,
          async (response: MiniAppPaymentPayload) => {
            if (response.status == "success") {
              const res = await fetch(`/api/confirm-payment`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(response),
              });
              const payment = await res.json();
              if (payment.success) {
                // Congrats your payment was successful!
              }
            }
          }
        );

        return () => {
          MiniKit.unsubscribe(ResponseEvent.MiniAppPayment);
        };
      }, []);
    ```
  </Tab>
</Tabs>

## Verifying the payment

<Warning>
  You should always verify the payment in your backend. Users can manipulate information in the frontend, so the
  response must be verified in a trusted environment.
</Warning>

**Web2** applications can call our Developer Portal API to get the current status of the transaction. Since payments are executed on-chain, it can take up to a few minutes to confirm.
You can choose to optimistically accept the payments once they've landed on-chain, or poll the endpoint to wait until it's successfully mined.

**Web3** applications can verify payments by inspecting the ERC-4337 `UserOperationEvent` emitted during the pay operation.

The `TransferReference` event will no longer be emitted. Instead, the `reference` string is SHA-256 hashed and the **leftmost 10 bytes** are included in the **`nonceKey`** embedded in the `nonce` field of `UserOperationEvent`.

The `nonceKey` is a fixed-length **24-byte** value constructed as:

* **1 byte**: version
* **13 bytes**: truncated SHA-256 hash of `miniappId`
* **10 bytes**: truncated SHA-256 hash of `reference`

Conceptually:

1. Compute (h = \mathrm(\text))
2. Take `h[0..10)` (10 bytes)
3. Compare it against bytes `nonceKey[14..24)` (offset = 1 + 13) extracted from the `UserOperationEvent` nonce

In this example, we will show querying via Developer Portal API.

```tsx app/confirm-payment/route.ts theme={null}
import { NextRequest, NextResponse } from 'next/server'
import { MiniAppPaymentSuccessPayload } from '@worldcoin/minikit-js'

interface IRequestPayload {
	payload: MiniAppPaymentSuccessPayload
}

export async function POST(req: NextRequest) {
	const { payload } = (await req.json()) as IRequestPayload

	// IMPORTANT: Here we should fetch the reference you created in /initiate-payment to ensure the transaction we are verifying is the same one we initiated
	const reference = getReferenceFromDB()

	// 1. Check that the transaction we received from the mini app is the same one we sent
	if (payload.reference === reference) {
		const response = await fetch(
			`https://developer.worldcoin.org/api/v2/minikit/transaction/${payload.transaction_id}?app_id=${process.env.APP_ID}`,
			{
				method: 'GET',
				headers: {
					Authorization: `Bearer ${process.env.DEV_PORTAL_API_KEY}`,
				},
			}
		)
		const transaction = await response.json()

		// 2. Here we optimistically confirm the transaction.
		// Otherwise, you can poll until the status == mined
		if (transaction.reference == reference && transaction.status != 'failed') {
			return NextResponse.json({ success: true })
		} else {
			return NextResponse.json({ success: false })
		}
	}
}
```

### On-chain verification (advanced)

Below is a minimal example of how you can extract the `nonceKey` from the `UserOperationEvent` nonce and compare the embedded reference bytes.

```ts theme={null}
import { createHash } from 'crypto'
import { ethers } from 'ethers'

// In the EntryPoint contract, `UserOperationEvent` includes a `nonce` field.
// That nonce is structured as: [24-byte nonceKey][8-byte sequential nonce].
//
// nonceKey layout (24 bytes):
// [ 1B version ][ 13B sha256(miniappId)[0..13) ][ 10B sha256(reference)[0..10) ]

const REFERENCE_BYTES = 10
const MINIAPP_ID_BYTES = 13
const VERSION_BYTES = 1

function referenceBytes(reference: string) {
  return createHash('sha256').update(reference, 'utf8').digest().subarray(0, REFERENCE_BYTES)
}

async function verifyReferenceFromReceipt({
  provider,
  transactionHash,
  senderAddress,
  entryPointInterface,
  userOperationEventTopic,
  reference,
  miniappId,
}: {
  provider: ethers.Provider
  transactionHash: string
  senderAddress: string
  entryPointInterface: ethers.Interface
  userOperationEventTopic: string
  reference: string
  miniappId: string
}) {
  const receipt = await provider.getTransactionReceipt(transactionHash)
  if (!receipt) throw new Error('Transaction receipt not found')

  // Find the UserOperationEvent for this user's wallet (sender is indexed)
  const senderTopic = ethers.zeroPadValue(senderAddress.toLowerCase(), 32)
  const useropLog = receipt.logs.find(
    (log) => log.topics[0] === userOperationEventTopic && log.topics[2]?.toLowerCase() === senderTopic,
  )
  if (!useropLog) throw new Error('UserOperationEvent log not found')

  const parsed = entryPointInterface.parseLog({ topics: useropLog.topics as string[], data: useropLog.data })
  const nonce = parsed.args.nonce as bigint

  // nonceKey is the top 24 bytes of nonce
  const nonceKey = nonce >> 64n
  const nonceKeyHex = nonceKey.toString(16).padStart(48, '0') // 24 bytes
  const nonceKeyBytes = Buffer.from(nonceKeyHex, 'hex')

  // Reference bytes live at: nonceKey[1 + 13 .. 24)
  const expected = referenceBytes(reference)
  const referenceOffset = VERSION_BYTES + MINIAPP_ID_BYTES
  const actual = nonceKeyBytes.subarray(referenceOffset, referenceOffset + REFERENCE_BYTES)

  // Optional: also validate miniappId bytes (nonceKey[1..14))
  const expectedMiniapp = createHash('sha256').update(miniappId, 'utf8').digest().subarray(0, MINIAPP_ID_BYTES)
  const actualMiniapp = nonceKeyBytes.subarray(VERSION_BYTES, VERSION_BYTES + MINIAPP_ID_BYTES)
  if (Buffer.compare(actualMiniapp, expectedMiniapp) !== 0) return false

  return Buffer.compare(actual, expected) === 0
}
```

## Success Result on World App

If implemented correctly, the user will see the following drawer on World App.

<div>
  <video>
    <source type="video/mp4" />

    Your browser does not support the video tag.
  </video>
</div>


# Request Permission
Source: https://docs.world.org/mini-apps/commands/request-permission



This command lets you request permissions to the user's device. This currently includes notifications and microphone.

## Using the command

This command only supports requesting one permission at a time. Additionally, it will only show the user the modal once. If a user rejects it, you will need to direct them to settings in order to re-enable the permission.

<Info>
  If a user removes your mini app from their World App home screen, you will need to request the permission again by universal linking to <b>worldcoin.org/settings/miniapps</b>
</Info>

Permission Types:

```tsx theme={null}
// Types of permissions you can request. You can only request one at a time.
export enum Permission {
  Notifications = 'notifications',
  Microphone = 'microphone',
}
```

<Tabs>
  <Tab title="Async handlers">
    ### Sending the command and handling the response

    ```tsx theme={null}
    import { MiniKit, RequestPermissionPayload, Permission } from '@worldcoin/minikit-js'

    // Example function of how to use the command
    const requestPermission = useCallback(
        async () => {
            const requestPermissionPayload: RequestPermissionPayload = {
                permission: Permission.Notifications,
            };
            const payload = await MiniKit.commandsAsync.requestPermission(requestPermissionPayload);
            // Handle the response
        }, []);
    ```
  </Tab>

  <Tab title="Event listeners">
    ### Sending the command

    ```tsx theme={null}
    // Example function of how to use the command
    const requestPermission = useCallback(
        () => {
            const requestPermissionPayload: RequestPermissionPayload = {
                permission: Permission.Notifications,
            };
            const payload = MiniKit.commands.requestPermission(requestPermissionPayload);
            },
        []
    );
    ```

    ### Handling the response

    ```tsx app/page.tsx theme={null}
    import { MiniKit, tokenToDecimals, Tokens, PayCommandInput, ResponseEvent } from '@worldcoin/minikit-js'
        // ...
        useEffect(() => {
            if (!MiniKit.isInstalled()) {
                console.error("MiniKit is not installed");
                return;
            }

            MiniKit.subscribe(
                ResponseEvent.MiniAppRequestPermission,
                async (response: MiniAppRequestPermissionPayload) => {
                    if (response.status == "success") {
                        const response = await res.json();
                        // Handle the response
                    }
                }
            );

            return () => {
                MiniKit.unsubscribe(ResponseEvent.MiniAppRequestPermission);
            };
        }, []);
    ```
  </Tab>
</Tabs>

## Response type

### Success response payload

```ts theme={null}
type MiniAppRequestPermissionSuccessPayload = {
    status: 'success';
    permission: 'notifications';
    timestamp: string;  // ISO-8601
    version: number;    // same version that was received from MiniKit
};
```

### Error response payload

```ts theme={null}
type MiniAppRequestPermissionErrorPayload = {
    status: 'error';
    error_code: RequestPermissionErrorCodes;
    version: number;
}
```

The possible error codes are:

* `user_rejected` - User declined permission request
* `generic_error` - Request failed for unknown reason
* `already_requested` - User has already declined turning on notifications once
* `permission_disabled` - User has notification disabled for World App
* `already_granted` - User has already granted this mini app permission
* `unsupported_permission` - Permission is not supported yet
* `world_app_permission_not_enabled` - User has not granted permission to World App. This means you need to prompt the user to enable microphone for World App first.

## Success Result on World App

If implemented correctly, the user will see the following drawer on World App.

<div>
  <video>
    <source type="video/mp4" />

    Your browser does not support the video tag.
  </video>
</div>


# Send Haptic Feedback
Source: https://docs.world.org/mini-apps/commands/send-haptic-feedback



Send Haptic Feedback is our command that lets you create more immersive experiences, by providing tactile feedback to users.
This command is available from minikit 1.7.1 and World App 2.8.7602 onwards.
Haptic feedback can improve the user experience by:

* **Enhancing Responsiveness**: Immediate tactile feedback makes interactions feel faster and more satisfying.
* **Improving Accessibility**: Haptics can help users with visual impairments by providing an additional layer of feedback.
* **Increasing Engagement**: Users are more likely to enjoy and continue using apps that feel interactive and responsive.

## Available payloads

| hapticsType        | style     | description                                                                       |
| ------------------ | --------- | --------------------------------------------------------------------------------- |
| `impact`           | `light`   | Collision between small UI elements.                                              |
| `impact`           | `medium`  | Collision between medium UI elements.                                             |
| `impact`           | `heavy`   | Collision between big UI elements.                                                |
|                    |           |                                                                                   |
| `notification`     | `success` | Indicates that an action was successful.                                          |
| `notification`     | `warning` | Indicates that something is not right and user should take notice.                |
| `notification`     | `error`   | Indicates that an action has failed.                                              |
|                    |           |                                                                                   |
| `selectionChanged` | ---       | Informs the user that a selection has changed, for example a checkbox was clicked |

## Creating the payload

```tsx app/page.tsx theme={null}
export type SendHapticFeedbackInput = {
	hapticsType: 'impact'
	style: 'light'
}
```

## Using the command

There's no response from this command.

```tsx app/page.tsx theme={null}
import { MiniKit } from '@worldcoin/minikit-js'

const sendHapticFeedbackCommand = () =>
	MiniKit.commands.sendHapticFeedback({
		hapticsType: 'impact',
		style: 'light',
	})

const ImportantPage = () => {
	const handleClick = () => {
		// ...
		sendHapticFeedbackCommand()
	}
	return <button onClick={handleClick}>Click me</button>
}

export default ImportantPage
```


# Send Transaction
Source: https://docs.world.org/mini-apps/commands/send-transaction



Send transaction allows you to read and write to any smart contract on World Chain.
Token transfers are only supported through Permit2 [Signature Transfer](https://docs.uniswap.org/contracts/permit2/reference/signature-transfer) or by directly calling the asset's transfer function.
Approvals are by default disabled.

Allow list the contracts and tokens you are interacting with in the Developer Portal (Configuration â†’ Advanced); otherwise, the backend will block the transaction.
Users can send 500 transactions a day for free. Afterwards, a user must pay for gas themselves. There is also an enforced 1 million gas limit per transaction.

Users can sign and send multiple transactions in parallel. Sequential execution is not enforced for miniapp transactions, unless those transactions are placed in the transaction array and sent as a single sendTransaction command.

## Creating a transaction

This command accepts an array of transactions, allowing you to specify multiple actions that will be executed atomically in a single multicall.
We default to formatting the payload to avoid validation errors, but if you are experiencing issues, you can set `formatPayload` to `false`.

```ts theme={null}
export type SendTransactionInput = {
	transaction: Transaction[]
	permit2?: Permit2[] // Optional
  formatPayload?: boolean // Optional, default is true. If this is causing errors, you can set this to false.
}

export type Transaction = {
	address: string // Contract address you're interacting with
	abi: Abi | readonly unknown[] // It's recommended to only include the functions you're using.
	functionName: ContractFunctionName<Abi | readonly unknown[], 'payable' | 'nonpayable'>
	value?: string // Hex string representation of the value to send with the function call
	args: ContractFunctionArgs<
		Abi | readonly unknown[],
		'payable' | 'nonpayable',
		ContractFunctionName<Abi | readonly unknown[], 'payable' | 'nonpayable'>
	>
}
```

<Tabs>
  <Tab title="Send Transaction">
    ```tsx app/page.tsx theme={null}
    import SimpleABI from '../../abi/SimpleABI.json'
    import { MiniKit } from '@worldcoin/minikit-js'

    const sendTransaction = async () => {
      const {commandPayload, finalPayload} = await MiniKit.commandsAsync.sendTransaction({
        transaction: [
          {
            address: '0x9Cf4F011F55Add3ECC1B1B497A3e9bd32183D6e8',
            abi: SimpleABI,
            functionName: 'mintToken',
            args: ['0x126f7998Eb44Dd2d097A8AB2eBcb28dEA1646AC8'],
          },
        ],
      })
    }
    ```

    ### Confirming the transaction

    Once the transaction is sent, you will receive a `transaction_id`. You can use this ID to check the transaction status and retrieve the transaction hash after confirmation.
    In this flow, we will use the `useWaitForTransactionReceipt` hook to monitor the transaction status.

    ```tsx app/page.tsx theme={null}
    // Make sure you have the @worldcoin/minikit-react package installed
    import { useWaitForTransactionReceipt } from '@worldcoin/minikit-react'

    const [transactionId, setTransactionId] = useState<string>('')

    const client = createPublicClient({
      chain: worldchain,
      transport: http('https://worldchain-mainnet.g.alchemy.com/public'),
    })

    const { isLoading: isConfirming, isSuccess: isConfirmed } = useWaitForTransactionReceipt({
      client: client,
      appConfig: {
        app_id: '<app_id>',
      },
      transactionId: transactionId,
    })

    const sendTransaction = async () => {
      const {commandPayload, finalPayload} = await MiniKit.commandsAsync.sendTransaction({
        // ...
      })

      if (payload.status === 'error') {
        console.error('Error sending transaction', payload)
      } else {
        setTransactionId(payload.transaction_id)
      }
    }
    ```
  </Tab>

  <Tab title="ABI">
    ```tsx abi/SimpleAbi.json theme={null}
    [
        {
          "inputs": [
            {
              "internalType": "address",
              "name": "",
              "type": "address"
            }
           ],
          "name": "mintToken",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
    ]

    ```
  </Tab>
</Tabs>

## Using permit2

This example demonstrates how to send a transaction using Permit2. You must specify additional configuration options in the Developer Portal (under Configuration â†’ Advanced) to enable a particular token.

Note that Permit2 requires a signature. Our backend automatically replaces the placeholder with the correct signature; you simply need to indicate this using `PERMIT2_SIGNATURE_PLACEHOLDER_{index}`.
The index corresponds to the position of the Permit2 value within the permit2 array.

```ts theme={null}
export type Permit2 = {
	permitted: {
		token: string
		amount: string | unknown
	}
	spender: string
	nonce: string | unknown
	deadline: string | unknown
}
```

<Tabs>
  <Tab title="Send Transaction (Permit2)">
    ### Sending the transaction & receiving the response

    ```tsx app/page.tsx theme={null}
    import Permit2 from '../../abi/Permit2.json'
    import { MiniKit } from '@worldcoin/minikit-js'

    const onClickUsePermit2 = async () => {
      // Permit2 is valid for max 1 hour
      const permitTransfer = {
        permitted: {
          token: "0x..." // The token I'm sending
          amount: (0.5 * 10 ** 18).toString(),
        },
        nonce: Date.now().toString(),
        deadline: Math.floor((Date.now() + 30 * 60 * 1000) / 1000).toString(),
      };

      const transferDetails = {
        to: address,
        requestedAmount: (0.5 * 10 ** 18).toString(),
      };

      try {
        const { finalPayload } = await MiniKit.commandsAsync.sendTransaction({
          transaction: [
            {
              address: "0xF0882554ee924278806d708396F1a7975b732522",
              abi: Permit2,
              functionName: 'signatureTransfer',
              args: [
                [
                  [
                    permitTransfer.permitted.token,
                    permitTransfer.permitted.amount,
                  ],
                  permitTransfer.nonce,
                  permitTransfer.deadline,
                ],
                [transferDetails.to, transferDetails.requestedAmount],
                'PERMIT2_SIGNATURE_PLACEHOLDER_0', // Placeholders will automatically be replaced with the correct signature. 
              ],
            },
          ],
          permit2: [
            {
              ...permitTransfer,
              spender: myContractToken,
            }, // If you have more than one permit2 you can add more values here.
          ],
        });
      }
    }
    ```

    ### Confirming the transaction

    Once the transaction is sent you will receive back a transaction id. You can use this to check the status of the transaction and will also be able to get the transaction hash
    once the transaction is confirmed.

    This requires installing the `@worldcoin/minikit-react` package.

    ```tsx app/page.tsx theme={null}
    import { useWaitForTransactionReceipt } from '@worldcoin/minikit-react'

    const [transactionId, setTransactionId] = useState<string>('')

    const client = createPublicClient({
      chain: worldchain,
      transport: http('https://worldchain-mainnet.g.alchemy.com/public'),
    })

    // You can use isSuccess to check if the transaction is mined
    const { isLoading: isConfirming, isSuccess: isConfirmed } = useWaitForTransactionReceipt({
      client: client,
      appConfig: {
        app_id: '<app_id>',
      },
      transactionId: transactionId,
    })

    const sendTransaction = async () => {
      const {commandPayload, finalPayload} = await MiniKit.commandsAsync.sendTransaction({
        // ...
      })

      if (payload.status === 'error') {
        console.error('Error sending transaction', payload)
      } else {
        setTransactionId(payload.transaction_id)
      }
    }
    ```
  </Tab>

  <Tab title="ABI">
    ```tsx abi/Permit2.json theme={null}
    [
        {
        "inputs": [
          {
            "components": [
              {
                "components": [
                  {
                    "internalType": "address",
                    "name": "token",
                    "type": "address"
                  },
                  {
                    "internalType": "uint256",
                    "name": "amount",
                    "type": "uint256"
                  }
                ],
                "internalType": "struct ISignatureTransfer.TokenPermissions",
                "name": "permitted",
                "type": "tuple"
              },
              {
                "internalType": "uint256",
                "name": "nonce",
                "type": "uint256"
              },
              {
                "internalType": "uint256",
                "name": "deadline",
                "type": "uint256"
              }
            ],
            "internalType": "struct ISignatureTransfer.PermitTransferFrom",
            "name": "permitTransferFrom",
            "type": "tuple"
          },
          {
            "components": [
              {
                "internalType": "address",
                "name": "to",
                "type": "address"
              },
              {
                "internalType": "uint256",
                "name": "requestedAmount",
                "type": "uint256"
              }
            ],
            "internalType": "struct ISignatureTransfer.SignatureTransferDetails",
            "name": "transferDetails",
            "type": "tuple"
          },
          {
            "internalType": "bytes",
            "name": "signature",
            "type": "bytes"
          }
        ],
        "name": "signatureTransfer",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
      },
    ]

    ```
  </Tab>
</Tabs>

## Success Result on World App

If implemented correctly, the user will see the following drawer on World App.

<div>
  <video>
    <source type="video/mp4" />

    Your browser does not support the video tag.
  </video>
</div>

## Debugging failed transactions

Sending transactions can be tricky. If you encounter a simulation\_failed error, you will receive a `debug_url` that allows you to inspect the error in Tenderly.
However, when using Permit2, the `debug_url` won't be available until your Permit2 signature expires. Therefore, it's recommended to <b>set a shorter deadline during testing. </b>
For details on other types of [errors](/mini-apps/reference/errors#transactions)

To get precise debug information, you can fetch debug URLs (Tenderly) using the [Get Transaction Debug URL](/mini-apps/reference/api#get-transaction-debug-url) endpoint.

## Alternative: Verifying the transaction

If you don't want to use our hook you can choose to query for the hash yourself using this endpoint. Make sure to specify `type=transaction` in the query string.

Transactions are sent via our relayer currently and so we provide you an internal id rather than a hash in the original response above.

```tsx app/confirm-transaction/route.ts theme={null}
import { NextRequest, NextResponse } from 'next/server'
import { MiniAppSendTransactionSuccessPayload } from '@worldcoin/minikit-js'

interface IRequestPayload {
	payload: MiniAppSendTransactionSuccessPayload
}

export async function POST(req: NextRequest) {
	const { payload } = (await req.json()) as IRequestPayload

	const response = await fetch(
		`https://developer.worldcoin.org/api/v2/minikit/transaction/${payload.transaction_id}?app_id=${process.env.APP_ID}&type=transaction`,
		{
			method: 'GET',
		}
	)
	const transaction = await response.json()

	return NextResponse.json(transaction)
}
```

Example response from api call.

```tsx theme={null}
{
    "transactionId": "0xa5b02107433da9e2a450c433560be1db01963a9146c14eed076cbf2c61837d60",
    "transactionHash": "0xa8388148b630b49a3d5a739eaad9e98b5766235cdb21a5ec8d3f89053d982a71",
    "transactionStatus": "failed",
    "miniappId": "app_staging_5748c49d2e6c68849479e0b321bc5257",
    "updatedAt": "2024-09-09T15:18:25.320Z",
    "network": "worldchain",
    "fromWalletAddress": "0x2321401e6a175a7236498ab66f25cd1db4b17558",
    "toContractAddress": "0x2321401e6a175a7236498ab66f25cd1db4b17558"
}
```

## Using ETH

<Info>This functionality is available from minikit-js 1.6.0 onwards.</Info>
Send transaction supports sending to payable functions. Make sure you have ETH in your wallet. For ease of use, we have a
simple contract that lets you send ETH by forwarding the value. [Forward.sol](https://worldscan.org/address/0x087d5449a126e4e439495fcBc62A853eB3257936#code)

```tsx theme={null}
// Sending eth via Forward.sol
const sendTransaction = async () => {
	const payload = await MiniKit.commandsAsync.sendTransaction({
		transaction: [
			{
				address: '0x087d5449a126e4e439495fcBc62A853eB3257936', // Forward.sol
				abi: ForwardABI,
				functionName: 'pay',
				args: ['0x377da9cab87c04a1d6f19d8b4be9aef8df26fcdd'], // To Whom
				value: '0x9184E72A000', // Send 0.00001 ETH hex encoded
			},
		],
	})
}
```

## Why Approvals are not supported

Approvals are not supported in order to create a better user experience. Any user transfer of funds will
only show one confirmation modal. This is to help cater towards users who are less familiar with the user patterns
of crypto.


# Share
Source: https://docs.world.org/mini-apps/commands/share



Share will be the primary way to access the browsers native share drawer.
This command will let you prompt users to share content, files, and links with other users through
any of the communication apps installed on their device. This command will also support downloading media to their device from your mini app.

This command will be available from MiniKit 2.0.0 and World App 2.8.84 onwards.

## Creating the payload

```tsx app/page.tsx theme={null}

export type SharePayload = {
  files: File[];
  title?: string;
  text?: string;
  url?: string;
};
```

## Using the command

There's no response from this command.

```tsx app/page.tsx theme={null}
import { MiniKit } from '@worldcoin/minikit-js'

const shareCommand = async () => {
	await MiniKit.commandsAsync.share({
		title: 'Invite Link', // Preview used in share drawer
		text: 'Use this invite code to join my mini app', // Text sent in shared message
		url: 'https://worldcoin.org', // URL to share
	})
}


const ImportantPage = () => {
	const handleClick = () => {
		// ...
		await shareCommand()
	}
	return <button onClick={handleClick}>Invite Friends</button>
}

```

On Android, we use the native share sheet which does alert the user to the success or failure of the share, however on iOS, we use the native web share sheet which has no response.

If you want to know if the share was successful, you can use the `share` event.

```tsx app/page.tsx theme={null}
MiniKit.subscribe(ResponseEvent.MiniAppShare, (payload) => {
	// Do nothing here to simply handle the error response
	console.log('Share Response', payload);
});
```

### Example in World App

Here's what the share drawer looks like in World App.

<div>
  <video>
    <source type="video/mp4" />

    Your browser does not support the video tag.
  </video>
</div>


# Share Contacts
Source: https://docs.world.org/mini-apps/commands/share-contacts



Sharing contacts is a command that allows you to request users to share contacts in their phone in a privacy preserving way.
This command will be available from v1.4.0 of minikit and v2.8.72 of World App.

## Crafting the payload

```ts theme={null}
export type ShareContactsInput = {
	isMultiSelectEnabled: boolean
	inviteMessage?: string
}
```

* `isMultiSelectEnabled` is a boolean that determines if the user can select multiple contacts, by default you can only select one contact in the modal.
* `inviteMessage` is an optional custom message that will be displayed to the user when the user invites a non world app user while inside of your mini app.

## Using the command

Here is an example of how to use the shareContacts command.

<Tabs>
  <Tab title="Async handlers">
    ### Sending the command and handling the response

    ```tsx theme={null}
    // Example function of how to use the command
    const shareContacts = useCallback(
        async (isMultiSelectEnabled: boolean = false, inviteMessage?: string) => {
            const shareContactsPayload: ShareContactsPayload = {
                isMultiSelectEnabled,
                inviteMessage,
            };
            const payload = await MiniKit.commandsAsync.shareContacts(shareContactsPayload);
            // Handle the response
        },
        []
    );
    ```
  </Tab>

  <Tab title="Event listeners">
    ### Sending the command

    ```tsx theme={null}
    // Example function of how to use the command
    const shareContacts = useCallback(
        (isMultiSelectEnabled: boolean = false, inviteMessage?: string) => {
            const shareContactsPayload: ShareContactsPayload = {
                isMultiSelectEnabled,
                inviteMessage,
            };
            const payload = MiniKit.commands.shareContacts(shareContactsPayload);
            },
        []
    );
    ```

    ### Handling the response

    The user will then see a modal of their contacts as well as be able to search for other users.

    ```tsx app/page.tsx theme={null}
    import { MiniKit, tokenToDecimals, Tokens, PayCommandInput, ResponseEvent } from '@worldcoin/minikit-js'
        // ...
        useEffect(() => {
            if (!MiniKit.isInstalled()) {
                console.error("MiniKit is not installed");
                return;
            }

            MiniKit.subscribe(
                ResponseEvent.MiniAppShareContacts,
                async (response: MiniAppShareContactsPayload) => {
                    if (response.status == "success") {
                        const contacts = await res.json();
                        // Handle the response
                    }
                }
            );

            return () => {
                MiniKit.unsubscribe(ResponseEvent.MiniAppShareContacts);
            };
        }, []);
    ```
  </Tab>
</Tabs>

## Response type

The response will contain an array of contacts that the user has selected.

### Success response payload

```ts theme={null}
type MiniAppShareContactsSuccessPayload = {
    status: 'success';
    contacts: Array<{
        username: string;
        walletAddress: string;
        profilePictureUrl: string | null;
    }>;
    timestamp: string;
    version: number;
};
```

### Error response payload

```ts theme={null}
type MiniAppShareContactsErrorPayload = {
    status: 'error';
    error_code: ShareContactsErrorCodes;
    version: number;
}
```

The possible error codes are:

* `user_rejected` - The user rejected the request
* `generic_error` - An unknown error occurred

## Success Result on World App

If implemented correctly, the user will see the following drawer on World App.

<div>
  <video>
    <source type="video/mp4" />

    Your browser does not support the video tag.
  </video>
</div>


# Sign Message
Source: https://docs.world.org/mini-apps/commands/sign-message



Sign message lets you create an [EIP-191](https://eips.ethereum.org/EIPS/eip-191).
You should verify the signature.

**Use Case:** This command is useful for applications that need to sign messages for verification purposes,
ensuring that the message was indeed created by the owner of the wallet.

**Example:** A voting app that requires users to sign a message to prove ownership
of their wallet before allowing them to vote.

## Using the command

<Tabs>
  <Tab title="Async handlers">
    ### Sending the command & handling the response

    The response will include a signature compliant with EIP-191.
    You should verify the signature.

    ```ts theme={null}
    type MiniAppSignMessageSuccessPayload = {
      status: "success";
      signature: string;
      address: string;
      version: number;
    };
    ```

    ```tsx app/page.tsx theme={null}
    import { MiniKit, SignMessageInput } from '@worldcoin/minikit-js'

    const signAndVerifyMessage = async () => {
      const signMessagePayload: SignMessageInput = {
        message: "Hello world",
      };

      const {finalPayload} = await MiniKit.commandsAsync.signMessage(signMessagePayload);

      if (finalPayload.status === "success") {
        const messageHash = hashSafeMessage(messageToSign);

        const isValid = await (
          await Safe.init({
            provider:
              "https://worldchain-mainnet.g.alchemy.com/v2/your-api-key",
            safeAddress: finalPayload.address,
          })
        ).isValidSignature(messageHash, finalPayload.signature);

        // Checks functionally if the signature is correct
        if (isValid) {
          console.log("Signature is valid");
        }
      }
    };
    ```

    Your message is verified!
  </Tab>

  <Tab title="Event listeners">
    ### Sending the command

    ```ts theme={null}
    export type SignMessageInput = {
      message: string;
    };
    ```

    ```tsx app/page.tsx theme={null}
    import { MiniKit, SignMessageInput } from '@worldcoin/minikit-js'

      const onSignMessage = () => {
        if (!MiniKit.isInstalled()) {
          return
        }
        const signMessagePayload: SignMessageInput = {
          message: "Hello world",
        };

        MiniKit.commands.signMessage(signMessagePayload);
      };
    ```

    ### Receiving the response

    The response will include a signature compliant with [EIP-191](https://eips.ethereum.org/EIPS/eip-191).
    You should verify the signature.

    ```ts theme={null}
    export type SignMessageInput = {
      message: string;
    };
    ```

    ```ts theme={null}
    type MiniAppSignMessageSuccessPayload = {
      status: "success";
      signature: string;
      address: string;
      version: number;
    };
    ```

    ```tsx app/page.tsx theme={null}
    import { MiniKit, ResponseEvent } from '@worldcoin/minikit-js'
    import Safe, { hashSafeMessage } from "@safe-global/protocol-kit";

    MiniKit.subscribe(ResponseEvent.MiniAppSignMessage, async (payload) => {
          if (payload.status === "success") {
            const messageHash = hashSafeMessage(messageToSign);

            const isValid = await (
              await Safe.init({
                provider:
                  "https://opt-mainnet.g.alchemy.com/v2/your-api-key",
                safeAddress: payload.address,
              })
            ).isValidSignature(messageHash, payload.signature);

            // Checks functionally if the signature is correct
            if (isValid) {
              console.log("Signature is valid");
            }
          }

        return () => {
          MiniKit.unsubscribe(ResponseEvent.MiniAppSignMessage);
        };
      }, []);

    ```

    Your message is verified!
  </Tab>
</Tabs>


# Verify
Source: https://docs.world.org/mini-apps/commands/verify



The verify command lets you use [incognito actions](/world-id/id/cloud) inside of your mini app. Incognito actions are a primitive of World ID and allow you to gate functionality behind a unique human check.

To use incognito actions, first create one in the [Developer Portal](https://developer.worldcoin.org/).

**Use Case:** This command is crucial for applications that require user verification to access certain features,
ensuring that only verified humans can perform actions. You can set up the incognito action limiting the number of times a user can perform an action.

**Example:** An game that requires users to verify their identity before playing to have a bot free experience.

## Using the command

<Tabs>
  <Tab title="Async handlers">
    ### Sending the command & handling the response

    MiniKit uses a slightly different input payload than IDKit. We do not need to pass in the `app_id`.

    ```tsx theme={null}
    export type VerifyCommandInput = {
    	action: string
    	signal?: string
    	verification_level?: VerificationLevel // Default: Orb
    }
    ```

    ```ts theme={null}
    type MiniAppVerifyActionSuccessPayload = {
    	status: 'success'
    	proof: string
    	merkle_root: string
    	nullifier_hash: string
    	verification_level: VerificationLevel
    	version: number
    }
    ```

    ```tsx app/page.tsx theme={null}
    import { MiniKit, VerifyCommandInput, VerificationLevel, ISuccessResult } from '@worldcoin/minikit-js'

    const verifyPayload: VerifyCommandInput = {
    	action: 'voting-action', // This is your action ID from the Developer Portal
    	signal: '0x12312', // Optional additional data
    	verification_level: VerificationLevel.Orb, // Orb | Device
    }

    const handleVerify = async () => {
    	if (!MiniKit.isInstalled()) {
    		return
    	}
    	// World App will open a drawer prompting the user to confirm the operation, promise is resolved once user confirms or cancels
    	const {finalPayload} = await MiniKit.commandsAsync.verify(verifyPayload)
    		if (finalPayload.status === 'error') {
    			return console.log('Error payload', finalPayload)
    		}

    		// Verify the proof in the backend
    		const verifyResponse = await fetch('/api/verify', {
    			method: 'POST',
    			headers: {
    				'Content-Type': 'application/json',
    			},
    			body: JSON.stringify({
    			payload: finalPayload as ISuccessResult, // Parses only the fields we need to verify
    			action: 'voting-action',
    			signal: '0x12312', // Optional
    		}),
    	})

    	// TODO: Handle Success!
    	const verifyResponseJson = await verifyResponse.json()
    	if (verifyResponseJson.status === 200) {
    		console.log('Verification success!')
    	}
    }
    ```
  </Tab>

  <Tab title="Event listeners">
    ### Sending the command

    MiniKit uses a slightly different input payload than IDKit. We do not need to pass in the `app_id`.

    ```tsx theme={null}
    export type VerifyCommandInput = {
    	action: string
    	signal?: string
    	verification_level?: VerificationLevel // Default: Orb
    }
    ```

    Using the `verify` command:

    ```tsx app/page.tsx theme={null}
    import { MiniKit, VerifyCommandInput, VerificationLevel } from '@worldcoin/minikit-js'

    const verifyPayload: VerifyCommandInput = {
    	action: 'voting-action', // This is your action ID from the Developer Portal
    	signal: '0x12312', // Optional additional data
    	verification_level: VerificationLevel.Orb, // Orb | Device
    }

    const payload = MiniKit.commands.verify(verifyPayload)
    ```

    ### Listening for the response

    Upon receiving the command from your mini app, World App will open a drawer prompting the user to confirm the operation.

    ```tsx app/page.tsx theme={null}
    import { MiniKit, ResponseEvent, ISuccessResult, MiniAppVerifyActionPayload } from '@worldcoin/minikit-js'

    // ...
    useEffect(() => {
    	if (!MiniKit.isInstalled()) {
    		return
    	}

    	MiniKit.subscribe(ResponseEvent.MiniAppVerifyAction, async (response: MiniAppVerifyActionPayload) => {
    		if (response.status === 'error') {
    			return console.log('Error payload', response)
    		}

    		// Verify the proof in the backend
    		const verifyResponse = await fetch('/api/verify', {
    			method: 'POST',
    			headers: {
    				'Content-Type': 'application/json',
    			},
    			body: JSON.stringify({
    				payload: response as ISuccessResult, // Parses only the fields we need to verify
    				action: 'voting-action',
    				signal: '0x12312', // Optional
    			}),
    		})

    		// TODO: Handle Success!
    		const verifyResponseJson = await verifyResponse.json()
    		if (verifyResponseJson.status === 200) {
    			console.log('Verification success!')
    		}
    	})

    	return () => {
    		MiniKit.unsubscribe(ResponseEvent.MiniAppVerifyAction)
    	}
    }, [])
    ```
  </Tab>
</Tabs>

## Verifying the proof

<Warning>
  You should pass the proof to your backend when verifying proofs via the API. Users can manipulate information in the
  frontend, so the proof must be verified in a trusted environment.
</Warning>

Successful responses will return a `MiniAppVerifyActionSuccessPayload`.

```ts theme={null}
type MiniAppVerifyActionSuccessPayload = {
	status: 'success'
	proof: string
	merkle_root: string
	nullifier_hash: string
	verification_level: VerificationLevel
	version: number
}
```

To verify the proof, you will need to make a backend route.

```ts app/api/verify/route.ts theme={null}
import { NextRequest, NextResponse } from 'next/server'
import { verifyCloudProof, IVerifyResponse, ISuccessResult } from '@worldcoin/minikit-js'

interface IRequestPayload {
	payload: ISuccessResult
	action: string
	signal: string | undefined
}

export async function POST(req: NextRequest) {
	const { payload, action, signal } = (await req.json()) as IRequestPayload
	const app_id = process.env.APP_ID as `app_${string}`
	const verifyRes = (await verifyCloudProof(payload, app_id, action, signal)) as IVerifyResponse // Wrapper on this

	if (verifyRes.success) {
		// This is where you should perform backend actions if the verification succeeds
		// Such as, setting a user as "verified" in a database
		return NextResponse.json({ verifyRes, status: 200 })
	} else {
		// This is where you should handle errors from the World ID /verify endpoint.
		// Usually these errors are due to a user having already verified.
		return NextResponse.json({ verifyRes, status: 400 })
	}
}
```

## Success Result on World App

If implemented correctly, the user will see the following drawer on World App.

<div>
  <video>
    <source type="video/mp4" />

    Your browser does not support the video tag.
  </video>
</div>


# Wallet Authentication
Source: https://docs.world.org/mini-apps/commands/wallet-auth



<Note type="warning">
  Use Wallet Authentication as the primary auth flow. Do not use the Verify
  command for login purposes.
</Note>

Wallet Authentication provides native support for [SIWE](https://eips.ethereum.org/EIPS/eip-4361) and it's the recommended way to authenticate users in your mini app.
This provides your app with access to a User object that contains the user's wallet address, username, and other information.

```tsx theme={null}
export type User = {
  walletAddress?: string;
  username?: string;
  profilePictureUrl?: string;
  permissions?: {
    notifications: boolean;
    contacts: boolean;
  };
  optedIntoOptionalAnalytics?: boolean;
  worldAppVersion?: number;
  deviceOS?: string;
};
```

In addition we have two helper functions to make it easier to get User information.

```tsx theme={null}
MiniKit.getUserByAddress(address: string): Promise<User>
MiniKit.getUserByUsername(username: string): Promise<User>

// Returns
return {
    walletAddress: '0x...',
    username: 'John Doe',
    profilePictureUrl: 'https://example.com/profile.png',
};
```

## How it works

Using [NextAuth](https://authjs.dev/getting-started) you can easily create and manage sessions for your app. The starter template is already set up with NextAuth.
To extend this to other wallet providers, you simply need to trigger the wallet auth command and verify the response with [verifySiweMessage](https://github.com/worldcoin/minikit-js/blob/c3aff19f80d07fe1635e68541f91205862500baa/demo/next-15-template/src/auth/index.ts#L41-L74).

<Note>
  Starting from World App 2.8.79 and higher, we support the standard SIWE
  verification library.
</Note>

## Creating the nonce

Since the user can modify the client, it's important to create the nonce in the backend. **The nonce must be at least 8 alphanumeric characters in length.**

```ts app/api/nonce.ts theme={null}
import {cookies} from "next/headers"; import {(NextRequest, NextResponse)} from "next/server";

export function GET(req: NextRequest) {
  // Expects only alphanumeric characters
  const nonce = crypto.randomUUID().replace(/-/g, "");

// The nonce should be stored somewhere that is not tamperable by the client
// Optionally you can HMAC the nonce with a secret key stored in your environment
cookies().set("siwe", nonce, { secure: true });
return NextResponse.json({ nonce });
}

```

## Using the command

<Tabs>
  <Tab title="Async handlers">
    ### Sending & handling the command response

    Below is the expected input for `walletAuth`.

    ```ts theme={null}
    interface WalletAuthInput {
    	nonce: string
    	expirationTime?: Date
    	statement?: string
    	requestId?: string
    	notBefore?: Date
    }
    ```

    Using the async `walletAuth` command.

    ```tsx app/page.tsx theme={null}
    import { MiniKit, WalletAuthInput } from '@worldcoin/minikit-js'
    // ...
    const signInWithWallet = async () => {
    	if (!MiniKit.isInstalled()) {
    		return
    	}
    	const res = await fetch(`/api/nonce`)
    	const { nonce } = await res.json()

    	const {commandPayload: generateMessageResult, finalPayload} = await MiniKit.commandsAsync.walletAuth({
    		nonce: nonce,
    		requestId: '0', // Optional
    		expirationTime: new Date(new Date().getTime() + 7 * 24 * 60 * 60 * 1000),
    		notBefore: new Date(new Date().getTime() - 24 * 60 * 60 * 1000),
    		statement: 'This is my statement and here is a link https://worldcoin.com/apps',
    	})
    	// ...
    ```

    The returned message (in final payload) will include a signature compliant with [ERC-191](https://eips.ethereum.org/EIPS/eip-191).
    You're welcome to use any third party libraries to verify the payloads for SIWE.

    ```tsx theme={null}
    type MiniAppWalletAuthSuccessPayload = {
    	status: 'success'
    	message: string
    	signature: string
    	address: string
    	version: number
    }
    ```

    ```tsx app/page.tsx theme={null}
    const signInWithWallet = async () => {
    	if (!MiniKit.isInstalled()) {
    		return
    	}

    	const res = await fetch(`/api/nonce`)
    	const { nonce } = await res.json()

    	const { commandPayload: generateMessageResult, finalPayload } = await MiniKit.commandsAsync.walletAuth({
    		nonce: nonce,
    		requestId: '0', // Optional
    		expirationTime: new Date(new Date().getTime() + 7 * 24 * 60 * 60 * 1000),
    		notBefore: new Date(new Date().getTime() - 24 * 60 * 60 * 1000),
    		statement: 'This is my statement and here is a link https://worldcoin.com/apps',
    	})

    	if (finalPayload.status === 'error') {
    		return
    	} else {
    		const response = await fetch('/api/complete-siwe', {
    			method: 'POST',
    			headers: {
    				'Content-Type': 'application/json',
    			},
    			body: JSON.stringify({
    				payload: finalPayload,
    				nonce,
    			}),
    		})
    	}
    }
    ```

    You can now additionally access the user's wallet address from the minikit object.

    ```tsx theme={null}
    const walletAddress = MiniKit.walletAddress
    // or
    const walletAddress = window.MiniKit?.walletAddress
    ```
  </Tab>

  <Tab title="Event listeners">
    ### Sending the command

    Below is the expected input for `walletAuth`.

    ```ts theme={null}
    interface WalletAuthInput {
    	nonce: string
    	expirationTime?: Date
    	statement?: string
    	requestId?: string
    	notBefore?: Date
    }
    ```

    Using the `walletAuth` command.

    ```tsx app/page.tsx theme={null}
    import { MiniKit, WalletAuthInput } from '@worldcoin/minikit-js'
    // ...
    const signInWithWallet = async () => {
    	const res = await fetch(`/api/nonce`)
    	const { nonce } = await res.json()

    	const generateMessageResult = MiniKit.commands.walletAuth({
    		nonce: nonce,
    		requestId: '0', // Optional
    		expirationTime: new Date(new Date().getTime() + 7 * 24 * 60 * 60 * 1000),
    		notBefore: new Date(new Date().getTime() - 24 * 60 * 60 * 1000),
    		statement: 'This is my statement and here is a link https://worldcoin.com/apps',
    	})
    }
    ```

    ### Receiving the response

    The returned message will include a signature compliant with [ERC-191](https://eips.ethereum.org/EIPS/eip-4361).

    ```tsx theme={null}
    type MiniAppWalletAuthSuccessPayload = {
    	status: 'success'
    	message: string
    	signature: string
    	address: string
    	version: number
    }
    ```

    ```tsx app/page.tsx theme={null}
    import { ResponseEvent } from '@worldcoin/minikit-js'
    // ...
    useEffect(() => {
    	if (!MiniKit.isInstalled()) {
    		return
    	}

    	MiniKit.subscribe(ResponseEvent.MiniAppWalletAuth, async payload => {
    		if (payload.status === 'error') {
    			return
    		} else {
    			const response = await fetch('/api/complete-siwe', {
    				method: 'POST',
    				headers: {
    					'Content-Type': 'application/json',
    				},
    				body: JSON.stringify({
    					payload: payload,
    					nonce,
    				}),
    			})
    		}
    	})

    	return () => {
    		MiniKit.unsubscribe(ResponseEvent.MiniAppWalletAuth)
    	}
    }, [])
    ```

    You can now additionally access the user's wallet address from the minikit object.

    ```tsx theme={null}
    const walletAddress = MiniKit.walletAddress
    // or
    const walletAddress = window.MiniKit?.walletAddress
    ```
  </Tab>
</Tabs>

## Verifying the Login

Finally, complete the sign in by verifying the response from World App in your backend. Here we check the nonce matches the one we created earlier, and
then verify the signature.

```ts app/api/complete-siwe.ts theme={null}
import { cookies } from "next/headers";
import { NextRequest, NextResponse } from "next/server";
import {
  MiniAppWalletAuthSuccessPayload,
  verifySiweMessage,
} from "@worldcoin/minikit-js";

interface IRequestPayload {
  payload: MiniAppWalletAuthSuccessPayload;
  nonce: string;
}

export const POST = async (req: NextRequest) => {
  const { payload, nonce } = (await req.json()) as IRequestPayload;
  if (nonce != cookies().get("siwe")?.value) {
    return NextResponse.json({
      status: "error",
      isValid: false,
      message: "Invalid nonce",
    });
  }
  try {
    const validMessage = await verifySiweMessage(payload, nonce);
    return NextResponse.json({
      status: "success",
      isValid: validMessage.isValid,
    });
  } catch (error: any) {
    // Handle errors in validation or processing
    return NextResponse.json({
      status: "error",
      isValid: false,
      message: error.message,
    });
  }
};
```

## Success Result on World App

If implemented correctly, the user will see the following drawer on World App.

<div>
  <video>
    <source type="video/mp4" />

    Your browser does not support the video tag.
  </video>
</div>

## SIWE Implementations

* **Privy**: You can find a complete integration guide at [Worldcoin Mini App SIWE with Privy](https://docs.privy.io/recipes/react/worldcoin-siwe-guide)

## Alternative Authentication Methods

* **OAuth** (Google, Apple, etc.): These providers are supported but it's recommended to trigger this outside of the World App and then redirect back to your mini app with the access token `worldapp://mini-app?app_id=appId&path=/handle-oauth?accessToken=...`.
* **Sign in with World ID**: Not recommended as it doesn't provide the user's wallet address.


# Data & Analytics
Source: https://docs.world.org/mini-apps/growth/analytics



Track only what answers **critical product questions**â€”nothing more.\
This page shows you **what to measure, why, and how to start in one sprint**.

## 1 Â· Mental Model *Q â†’ M â†’ E*

> **Question â†’ Metric â†’ Event**

1. **Question** you want answered
2. **Metric** that quantifies it
3. **Event** (or two) that feed that metric

| Product Question             | Metric (M)                    | Minimal Events (E)               |
| ---------------------------- | ----------------------------- | -------------------------------- |
| Do users see value on day 0? | **Conversion to First Value** | `signup`, `first_value`          |
| Do they come back?           | **D1 / D7 Retention**         | `app_open`                       |
| Will growth be organic?      | **Invite Acceptance Rate**    | `invite_sent`, `invite_accepted` |
| Can we reâ€‘engage them?       | **Push Open Rate**            | `notification_open`              |

If an event doesn't roll up to a key question, skip it.

## 2 Â· Core Event Set (6 Lines of Code)

```ts theme={null}
track('app_open') // every launch
track('signup', { method: 'id' })
track('first_value', { action: 'ðŸŽ‰' })
track('invite_sent')
track('invite_accepted')
track('notification_open')
```

That is enough to build funnels, retention, and viral metrics.

## 3 Â· Action Plan

**Focus on these 4 metrics weekly until they're all green:**

* **Signup â†’ First Value %** (target: â‰¥40%) - Are users getting value immediately?
* **D1 Retention** (target: â‰¥25%) - Are they coming back the next day?
* **Invite Acceptance %** (target: â‰¥15%) - Is word-of-mouth working?
* **Push Open %** (target: â‰¥15%) - Can we re-engage users?

**Next steps:** Pick the lowest metric and spend 1-2 sprints fixing it. Don't touch anything else until all four are hitting targets.

## 4 Â· Common Pitfalls to Dodge

* **Event sprawl** â€“ >10 events = analysis paralysis.
* **Vanity charts** â€“ page views â‰  value.
* **No cohorts** â€“ averages hide churn.
* **Premature segmentation** â€“ wait for 1k users.
* **Ignoring retention** â€“ acquisition is useless without it.

Analytics should light the path, not become the journey. Keep it lean, learn fast, and build what moves the needle.


# Gamification
Source: https://docs.world.org/mini-apps/growth/gamification



Gamification isn't about turning your app into a gameâ€”it's about using proven psychological principles to make routine actions more engaging and rewarding.

## Why It Works

Game mechanics tap into fundamental human psychology: our need for achievement, progress, and social comparison. Duolingo saw retention jump from 12% D1 to 55% after implementing streak mechanics. The key is choosing mechanics that align with your core user behavior, not just adding badges everywhere.

## Core Mechanics by Impact & Effort

| Mechanic            | Effort | Why It Works                                            | Quick Implementation                                         |
| ------------------- | ------ | ------------------------------------------------------- | ------------------------------------------------------------ |
| **Daily Streaks**   | â˜…â˜…â˜†â˜†â˜†  | Creates habit formation; users hate breaking chains     | Track daily actions, show streak count, celebrate milestones |
| **Progress Bars**   | â˜…â˜†â˜†â˜†â˜†  | Visual momentum; users hate seeing 80% incomplete       | CSS progress indicators for any goal completion              |
| **Badges & Levels** | â˜…â˜…â˜†â˜†â˜†  | Collectibles trigger completion bias                    | Emoji icons + achievement unlocks                            |
| **Leaderboards**    | â˜…â˜…â˜†â˜†â˜†  | Social comparison drives engagement                     | Simple top 10 list, refresh weekly                           |
| **Mystery Rewards** | â˜…â˜…â˜†â˜†â˜†  | Variable rewards release dopamine (slot machine effect) | Daily random reward from small pool                          |

## Strategic Implementation

### 1. Daily Streaks

**Why this first**: Highest retention impact with moderate effort. Creates powerful daily habit loops.

**Core concept**: Track consecutive days of user activity, celebrate milestones, make breaking streaks feel costly.

**Implementation strategy**:

* Store `currentStreak`, `longestStreak`, `lastActiveDate` per user
* Check daily: consecutive day = +1, gap = reset to 1
* Celebrate at days 3, 7, 14, 30 with visual rewards
* Show streak prominently in app header

```typescript theme={null}
// Simple streak logic
const updateStreak = (lastActive: string) => {
	const daysSinceLastActive = getDaysDifference(lastActive, today)
	return daysSinceLastActive === 1 ? streak + 1 : 1
}
```

### 2. Progress Bars & Visual Momentum

Users hate leaving things 80% complete. Visual progress creates urgency to finish.

**Where to use**:

* **Profile completion:** 2/5 steps remaining
* **Daily/weekly goals:** 7/10 tasks done
* **Social milestones:** 3/5 friends invited
* **Skill progression**: Level 4: 80% to Level 5

**Key principle**: Always show progress toward the next achievable milestone, not distant end goals.

### 3. Achievement Badges

**Strategy**: Create collectible moments that trigger completion bias and provide social proof.

**Badge categories that work**:

* **Onboarding**: "First Steps" (welcome badge), "Explorer" (tried 3 features)
* **Social**: "Social Butterfly" (first share), "Connector" (5 friends invited)
* **Engagement**: "Week Warrior" (7-day streak), "Power User" (daily active for 30 days)
* **Milestones**: "High Achiever" (reached level 10), "Completionist" (100% profile)

**Design tips**:

* Make early badges easy to get within first session
* Create clear progression: Common â†’ Rare â†’ Epic
* Show badge collection in user profile for social proof

### 4. Social Leaderboards

**When to use**: Best for apps with clear scoring metrics (points, levels, achievements completed).

**Types that work**:

* **Weekly leaderboards**: Reset regularly so everyone has a chance
* **Friend leaderboards**: Compare with people you know (higher engagement)
* **Category leaderboards**: "Top Streaks", "Most Social", "Fastest Completion"

**Key strategies**:

* Keep it simple: Top 10 list with current user highlighted
* Refresh weekly to prevent permanent dominance
* Only show verified users to prevent gaming

**World App advantage**: World ID ensures fair competition with one-person-one-account guarantee.

### 5. Variable Reward Systems

**Psychology**: Variable rewards trigger dopamine more than predictable ones (slot machine effect).

**Implementation ideas**:

* **Daily mystery box**: Random reward from a small pool (coins, badges, features)
* **Streak bonuses**: Random multiplier for milestone completions
* **Surprise rewards**: Occasional "lucky day" bonuses for regular actions
* **Loot boxes**: Earned through achievements, contain random useful items

**Reward pool strategy**:

* 70% common rewards (small coin amounts, basic items)
* 25% rare rewards (larger bonuses, temporary premium features)
* 5% epic rewards (exclusive badges, significant bonuses)

**Key principle**: Make the anticipation of opening more exciting than the reward itself.

## Design Principles

### 1. One Core Loop

Pick one primary habit loop and nail it before adding more.
**Example flow**: Daily check-in â†’ earn streak â†’ unlock reward â†’ share achievement â†’ invite friends

### 2. Early Wins

Users should earn their first badge/reward within 30 seconds of first use. This creates immediate positive reinforcement and sets expectations for future rewards.

### 3. Surface Progress Everywhere

* Show current streak in app header/navigation
* Display progress bars for any incomplete goals
* Badge count in user profile for social proof
* Preview next achievable reward/milestone

### 4. Measure & Optimize

Track key events: `streak_extended`, `badge_earned`, `leaderboard_viewed`, `reward_claimed`

**Golden rule**: If a mechanic doesn't improve D7 retention after 2 weeks, remove it.

## Common Pitfalls

1. **Over-gamification**: Don't add badges for every tiny actionâ€”dilutes achievement value
2. **Participation trophies**: Make early badges easy but later ones meaningful
3. **Pay-to-win mechanics**: Keep purchases separate from core progression
4. **Feature creep**: Start with one mechanic, prove it works, then expand

## Your Next Steps

1. **Start simple**: Implement daily streaks firstâ€”highest impact for effort invested
2. **Add visual progress**: One progress bar or completion indicator
3. **Create 3-5 early badges**: Tied directly to your core user actions
4. **Measure ruthlessly**: Track D7 retention before/after each mechanic
5. **Expand gradually**: Only add new mechanics after current ones prove effective

The goal isn't to build a game â€”it's to make your core experience more engaging and habit-forming.


# Overview
Source: https://docs.world.org/mini-apps/growth/index



A focused, step-by-step guide to growing your mini app within the World ecosystem. Everything is scoped to what an indie hacker or small team can realistically ship in a few weeks.

## Overview & Philosophy

Building a successful mini app requires more than great featuresâ€”you need users to discover, engage with, and stick around. This growth playbook focuses on four key areas that drive sustainable growth:

1. **[Invites & Viral Loops](/mini-apps/growth/invites-viral)** - Turn your users into advocates
2. **[Gamification](/mini-apps/growth/gamification)** - Build engagement through game mechanics
3. **[Retention via Notifications](/mini-apps/growth/notifications)** - Keep users coming back
4. **[Data & Analytics](/mini-apps/growth/analytics)** - Measure what matters

## Real-World Results

The strategies in this playbook are based on proven case studies:

* **PayPal's referral program**: 7-10% daily growth
* **Dropbox's two-sided rewards**: 3900% growth in 15 months
* **Duolingo's streak mechanics**: Retention jumped from 12% to 55%


# Invites & Viral Loops
Source: https://docs.world.org/mini-apps/growth/invites-viral



## Why It Works

Referral programs are proven growth drivers because they leverage trust. People are 4x more likely to try something recommended by a friend versus discovering it through ads. PayPal's $20/$20 referral program produced 7-10% daily growth, while Dropbox's free storage rewards drove 3900% growth in 15 months.

## Step-by-Step Implementation

### 1. Set Up Universal Links

Create server-side invite pages that work across all platforms:

```typescript theme={null}
// pages/invite.tsx
export default function InvitePage({ code }: { code: string }) {
	useEffect(() => {
		// Redirect to mini app
		window.location.href = `https://world.org/mini-app?app_id=${YOUR_APP_ID}&path=/invite?code=${code}`
	}, [code])

	return <div>Redirecting to mini app...</div>
}
```

Universal-link format

`https://world.org/mini-app?app_id={app_id}&path={path}`

Deep-link (opens World App directly if installed)

`worldapp://mini-app?app_id={app_id}&path={path}`

To force opening in the device browser instead of the native webview, append `open_out_of_window=true` to the URL (works for both universal and deep links).

Note: path should be URL encoded.

### 2. Generate Share Links

Create a shareable link that includes the referral information:

```typescript theme={null}
function generateInviteLink(userId: string): string {
  const baseUrl = "https://world.org/mini-app";
  const appId = "your_app_id";
  const path = encodeURIComponent(`/invite?code=${userId}`);

  return `${baseUrl}?app_id=${appId}&path=${path}`;
}
```

### 3. Implement Share Functionality

Add share buttons at key moments in your user journey:

```typescript theme={null}
import { MiniKit } from "@worldcoin/minikit-js";

async function shareInvite() {
  const inviteLink = generateInviteLink(currentUser.id);

  try {
    await MiniKit.commandsAsync.share({
      title: "Join me on [Your App Name]!",
      text: `I'm using this amazing mini app. Join me and we both get rewards! ðŸŽ`,
      url: inviteLink,
    });

    // Track the share event
    trackEvent("invite_link_created", {
      user_id: currentUser.id,
      share_method: "native",
    });
  } catch (error) {
    console.error("Share failed:", error);
  }
}
```

### 4. Handle Incoming Referrals

Process referral codes when new users sign up:

```typescript theme={null}
// On app initialization
function handleReferral() {
  const urlParams = new URLSearchParams(window.location.search);
  const refCode = urlParams.get("ref");

  if (refCode && !currentUser.referredBy) {
    // Credit the referrer
    fetch("/api/process-referral", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        newUserId: currentUser.id,
        referrerCode: refCode,
      }),
    });
  }
}
```

### 5. Reward System

Implement two-sided rewards that benefit both parties:

```typescript theme={null}
// api/process-referral.ts
export async function processReferral(data: {
  newUserId: string;
  referrerCode: string;
}) {
  const referrer = await getUserByCode(data.referrerCode);
  if (!referrer) {
    return { success: false, reason: "invalid_referrer" };
  }

  // Credit both users
  await Promise.all([
    creditUser(referrer.id, {
      type: "referral_bonus",
      amount: 100,
      reason: "Friend joined via your invite",
    }),
    creditUser(data.newUserId, {
      type: "signup_bonus",
      amount: 50,
      reason: "Welcome bonus for joining via invite",
    }),
  ]);

  return { success: true };
}
```

### 6. Support Deferred Deep Links (Android)

```
https://play.google.com/store/apps/details?id=com.worldcoin&referrer=app_id%3D{app_id}%26path%3D{path}
```

World App prompts the install and then automatically forwards the user to your specified path.

### Optimising Social-Share Previews

World app universal links will forward the og:image from your integration url.

Eg. `world.org/mini-app?app_id=1234&path=/invite?code=abcd` will forward the og:image from `[your-miniapp-url]/invite?code=abcd`.

### Inside World App Discovery

* **Quick Actions**: Mini apps can hand off context to one another. Split distinct flows into focused apps that trigger each other with Quick Actions.

* **Widget**: Your mini app can live on the phone's home screen. Prompt the user to add the mini app as a widget in the home screen.

<div>
  <img alt="Widget" />
</div>

Widget on iOS

## Design Best Practices

### Placement Strategy

* **After first value delivery**: When user completes their first meaningful action
* **Post-achievement**: Right after earning a badge, completing a level, or winning
* **Onboarding finale**: As the last step of user setup

### Copy That Converts

* **Personal benefit first**: "Get 100 coins for each friend who joins"
* **Mutual benefit**: "You both get rewards when they sign up"
* **Social proof**: "Join 10,000+ users already earning rewards"

### Visual Design

* Use prominent, action-oriented buttons ("Invite Friends", "Share & Earn")
* Show potential rewards clearly with icons or progress bars
* Include preview of what the shared content looks like

## Metrics to Track

Monitor these key events to measure your viral loop performance:

```typescript theme={null}
// Essential tracking events
const events = {
  invite_link_created: { user_id, share_method },
  invite_link_clicked: { ref_code, source },
  signup_source_invite: { ref_code, new_user_id },
  referral_reward_granted: { referrer_id, new_user_id, reward_amount },
};
```

### Key Metrics Dashboard

* **Invite Conversion Rate**: (Signups from invites) / (Total invite links clicked)
* **K-Factor**: (New users from invites) / (Total active users)
* **Viral Cycle Time**: Average time from invite sent to new user activated
* **Reward Cost per Acquisition**: Total rewards paid / New users acquired

## Quick A/B Test Ideas

Test these variables to optimize your viral loop:

1. **Reward Amount**: Test 50 vs 100 vs 200 coin rewards
2. **Timing**: Share prompt after first win vs after onboarding
3. **Copy**: Personal benefit vs mutual benefit messaging
4. **Incentive Type**: Coins vs premium features vs exclusive content

<Warning>
  Start with small reward amounts and scale up based on unit economics. Cap
  total lifetime rewards per user to control costs.
</Warning>

## Next Steps

1. Implement universal links for your invite flow
2. Add share buttons after key user achievements
3. Set up two-sided rewards with World ID verification
4. Track invite metrics and run small A/B tests
5. Scale successful invite mechanics across more touchpoints


# Retention via Notifications
Source: https://docs.world.org/mini-apps/growth/notifications



Thoughtful, behaviorâ€‘based notifications keep users engaged long after they close your Mini App. Done right, they lift retention and even earn you a coveted **homeâ€‘screen badge** in World App.

### 1 Â· Why They Matter

| Benefit              | Details                                                              |
| -------------------- | -------------------------------------------------------------------- |
| **Retention boost**  | Targeted pushes can 2â€“3Ã— dayâ€‘7 retention.                            |
| **Free visibility**  | â‰¥ 15 % open rate unlocks a persistent badge on your app icon.        |
| **Strict standards** | \< 10 % open = delivery paused for 7 daysâ€”quality is nonâ€‘negotiable. |

### 2 Â· Quality Thresholds

| Openâ€‘Rate (7â€‘day) | Platform Action   | Your Next Step                    |
| ----------------- | ----------------- | --------------------------------- |
| **\< 10%**        | Paused for 1 week | Audit triggers & copy immediately |
| **10%+**          | Badge displayed   | Maintain & iterate                |
| **25%+**          | "Excellent" tier  | Scale what works, test new ideas  |

### 3 Â· Core Principles

1. **Triggerâ€‘based > Broadcasts** â€“ React to *user actions* (wins, risks) instead of fixed schedules.
2. **Personalize** â€“ Use `${username}` placeholder to personalize notifications with usernames.
3. **Copy rules** â€“ â‰¤ 30â€‘char title, 1â€“2 emojis, clear value + curiosity gap.

### 4 Â· Trigger Library

| Trigger          | Why It Works          | Sample Title                      |
| ---------------- | --------------------- | --------------------------------- |
| **Achievement**  | Users love quick wins | `ðŸŽ‰ Level 2 unlocked!`            |
| **Streak Risk**  | Loss aversion         | `ðŸ”¥ Keep your 5â€‘day streak alive` |
| **Social**       | FOMO / competition    | `ðŸ‘€ Maya just beat your score`    |
| **Limitedâ€‘time** | Urgency               | `â° Double rewards end in 2 h`     |
| **Reâ€‘engage**    | Gentle nudge          | `ðŸš€ Welcome back bonus ready`     |

### 5 Â· Frequency & Control

* **Start** at **â‰¤ 1 push/day**; add more only if retention rises.
* Present a clear **optâ€‘out** path; trust drives longâ€‘term engagement.

### 6 Â· Copy Cheatsheet

* **Lead with benefit**: "Earn 50 coins" beats "Check the app".
* **Curiosity**: "Something new awaits â€¦".
* **Concrete numbers**: "30 s left" > "Hurry up".
* **Avoid** vague, generic, or featureâ€‘only blasts.

### 7 Â· Test & Improve

| Variable       | What to Try           |
| -------------- | --------------------- |
| Emoji          | ðŸ”¥ vs âš¡               |
| Timing         | Instant vs +2 h       |
| CTA            | "Claim" vs "Open now" |
| Content length | Short vs rich preview |

### 8 Â· Integrations

* **Gamification** â€“ Push on badge earned, streak day, leaderboard change.
* **Virality** â€“ Notify referrer when invitee signs up or hits milestones.
* **Core value** â€“ Release drops, new content, feature unlocks.

### 9 Â· Homeâ€‘Screen Badge

<div>
  <img alt="Notification badges on home screen" />
</div>

Maintain â‰¥ 15 % opens to display this permanent badgeâ€”topâ€‘ofâ€‘mind visibility every time users open World App.

### 10 Â· Implementation Checklist

* [ ] Ask permission **after** first value delivered
* [ ] Use `${username}` in every push
* [ ] Include `mini_app_path` deep link
* [ ] Limit to â‰¤ 1 notification/day at launch
* [ ] Monitor 7â€‘day open rate weekly
* [ ] A/B test copy monthly
* [ ] Iterate triggers; retire low performers


# App Guidelines
Source: https://docs.world.org/mini-apps/guidelines/app-guidelines



## Mobile First

Mini apps are inherently accessed via mobile, so your application UI should look and feel like a mobile app.

### Key considerations for a mobile-first experience:

* Use tab navigation to simplify movement within the app.
* Implement snap-to text boxes for easy user input.
* Avoid footers, sidebars, and excessive scrolling.
* Provide clear and direct navigation without hamburger menus.
* Ensure smooth transitions between different screens or sections.
* Use consistent background colors for a cohesive visual experience.
* Provide clear navigation cues to help users understand where they are and how to proceed.
* Ensure all UI elements are responsive and adapt well to different screen sizes.
* Use fonts that are optimized for readability on mobile devices.
* Include a splash page for sign-in if needed.

<div>
  <div>
    <video>
      <source type="video/mp4" />

      Your browser does not support the video tag.
    </video>

    âŒ Bad Example <br /> Footer and long scrolling
  </div>

  <div>
    <video>
      <source type="video/mp4" />

      Your browser does not support the video tag.
    </video>

    âœ… Good Example <br /> Bottom tab navigation and anchored buttons
  </div>
</div>

## Scroll Bounce on IOS.

We recommend you avoid scroll bounce error on iOS devices. Try disabling autoscroll & maybe fixed position elements or using 100dvh instead of 100vh.

If you are not using a bottom navigation bar, you can use the following CSS to disable the scroll bounce error:

```css theme={null}
html,
body {
  width: 100vw;
  height: 100vh;
  overscroll-behavior: none;
  overflow: hidden;
}
```

Alternatively, you can try this approach which allows scrolling while still preventing the bounce effect:

```css theme={null}
html,
body {
  -webkit-overflow-scrolling: touch;
  overscroll-behavior: none;
  overflow: scroll;
}
```

## Design Patterns

Here are some design patterns that we recommend you follow:

1. When a user is authenticated through their wallet, always show their username instead of the wallet address
2. Use the "Verify" command to confirm important actions or identity verification.
3. When dealing with wallet addresses, use an address book to link them to recognizable usernames or other identifiers

## App Icon

Your app icon should be a **square** image with a non white background.

## Content Card

Follow these guidelines when preparing the content card image:

* Content card size is 345x240 px.
* Avoid adding text inside content card images as much as possible.
* Keep the bottom 94 px free of important details; this area is overlaid in app.
* The text and icon on the card are rendered from your app description and app icon automaticallyâ€”no need to add them to the image.
* Export the banner without metadata, and include the blurred foreground element covering the bottom 94 px.
* Export without border radius, as PNG at 3x scale.

<div>
  <img alt="Good content card example" />

  âœ… Good Example <br />

  <br />
</div>

## Load times

For mini apps, 2-3 seconds max for initial load and under 1 second for subsequent actions should be your target.
However, always test for real-world scenarios and provide visual feedback during loading to maintain user trust.

## Branding & Identity

Do not use the term "official" in your app name, description, or interface. Mini apps are third-party applications and should not create the impression that they are officially endorsed by or affiliated with World.
Mini apps should maintain their own distinct brand identity while integrating with the World ecosystem

Additionally, do not use the **World logo** or any modified version of it in your app.

## Chance based

We recommend developers to avoid building chance based games, as these games have a very low likelihood of being approved.

**Chance based** = prize awarded based on chance, not skill. This means you are using a RNG to determine a winner.
You can still have prizes but they need to be awarded based on skill. Not randomness. So winning a game where I get a prize is skill based.

## Memberships & Yield

Selling memberships or subscriptions that grant users access to increased yield, higher returns, or enhanced earning rates is strictly prohibited. Apps must not offer paid access to features or tiers that boost financial returns.

## No Token Pre-sales

Token pre-sales are strictly prohibited. Mini Apps must not offer, promote, or facilitate token pre-sales in any form.

## NFTs on iOS

Mini Apps may allow users to view their own NFTs, provided that NFT ownership does not unlock features or functionality within the app.
Mini Apps may allow users to browse NFT collections owned by others, provided that the mini apps may not include buttons, external links, or other calls to action that direct customers to purchasing mechanisms other than in-app purchase.

## Localization

Many of our users are located around the world. Apps that are localised for each region will perform significantly better.
You can recognize the user's locale by using the [Accept-Language](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language) header

For next.js apps, you can use [Next.js Internationalization](https://nextjs.org/docs/app/building-your-application/routing/internationalization) to localize your app.

These languages are particularly important given our users:

1. English
2. Spanish
3. Thai
4. Japanese
5. Korean
6. Portuguese

## Usernames

You should never display the user's wallet address, always use their username.
If you use Sign in with World ID you should not be doing any transactions with the user's wallet address, instead you should be using the username.
Sign in with World ID and Verify offer the same World ID guarantees, but Verify is more reliable.

## Using the Address Book

World ID inherently allows anonymity between applications. We generally encourage
developers to use their own Verify Command and verify the proof. However, we also offer a World ID
address book. This contract stores a mapping `addressVerifiedUntil` you can query to see if a World App
address is World ID Orb verified.

## UI Kit

The Mini Apps UI Kit is a React-based design system for accelerating the development of mini apps. It provides pre-built, reusable UI components that align with World's design guidelines for consistency and high-quality UX.

### Get Started

Install the UI Kit via NPM:

```bash theme={null}
npm install @worldcoin/mini-apps-ui-kit-react
```

Learn more in the package README and Storybook:

* [Package README](https://www.npmjs.com/package/@worldcoin/mini-apps-ui-kit-react?activeTab=readme)
  href="[https://www.npmjs.com/package/@worldcoin/mini-apps-ui-kit-react?activeTab=readme](https://www.npmjs.com/package/@worldcoin/mini-apps-ui-kit-react?activeTab=readme)"
  target="\_blank"
  > Package README
* [UI Kit Storybook](https://mini-apps-ui-kit.world.org)


# Design Guidelines
Source: https://docs.world.org/mini-apps/guidelines/design-guidelines



This page gives you quick, visual rules to meet a high design standard for mini apps. Each image shows the intended pattern and a short usage note so you can apply it fast.

## Grid and spacing

**Usage**

Padding is set to a default of 24px, providing ample breathing room around elements while maintaining a clean and structured appearance.

<img alt="Base unit" />

## Paddings

**Usage**

Padding is set to a default of 24px, providing ample breathing room around elements while maintaining a clean and structured appearance.

<img alt="Paddings" />

## Navigation bar

**Usage**

Except for the control components of Mini Apps in the upper-right corner, all the other contents can be configured for custom designs. If interactive elements need to be set near the control components of Mini Apps, the developer shall note that whether the interaction area will conflict with the control components, and whether the operation is easy.

<img alt="Navigation bar" />

## Main pages

<div>
  <div>
    <img alt="One clear task per page" />

    <p>
      The default space between a header and its associated content is 16px, and
      the same 16px spacing applies between elements within a section. This
      consistent use of spacing helps create a clean visual structure and
      predictable rhythm across the UI.
    </p>
  </div>

  <div>
    <img alt="Keep CTAs visible" />

    <p>
      The default space between sections is set to 32px, helping to create clear
      separation between distinct areas of content. The space between the search
      bar and the content below is 24px, while the space between a sub-headline
      and its associated content is 16px.
    </p>
  </div>

  <div>
    <img alt="Minimize unnecessary scrolling" />

    <p>
      The default space between header and a section that starts with a sub
      headline is set to 24px.
    </p>
  </div>

  <div>
    <img alt="Prioritize primary actions" />

    <p>
      The default space between last item inside the scrollable area if a bottom
      bar is presented is 32px.
    </p>
  </div>
</div>

## Secondary pages

**Usage**

The default space between a header and its associated content is 24px, while the space between a header and a secondary title is 32px. The space between secondary title and description should be 12px.

<div>
  <img alt="Secondary 1" />

  <img alt="Secondary 2" />
</div>

## Tab bar (Android vs iOS)

**Usage**

Navigation bar is positioned with a 12px space from the iOS & Android bottom bar, ensuring optimal accessibility and a comfortable tap area.

<div>
  <div>
    <img alt="Tab bar Android" />
  </div>

  <div>
    <img alt="Tab bar iOS" />
  </div>
</div>

## Drawers / sheets (Android vs iOS)

**Usage**

Drawer is positioned with a 12px space from the iOS & Android bottom bar, ensuring optimal accessibility and a comfortable tap area.

<div>
  <div>
    <img alt="Drawers Android" />
  </div>

  <div>
    <img alt="Drawers iOS" />
  </div>
</div>

## Toasts (Android vs iOS)

**Usage**

The toast message should be horizontally centered and positioned directly below the header to ensure visibility without disrupting user interaction.

<div>
  <div>
    <img alt="Toast Android" />
  </div>

  <div>
    <img alt="Toast iOS" />
  </div>
</div>

## Keyboard handling (Android vs iOS)

**Usage**

Buttons are placed 24px above the active keyboard. This spacing ensures that buttons remain easily accessible and visually distinct, even when the keyboard is active, preventing accidental taps or overlap.

<div>
  <div>
    <img alt="Keyboard Android" />
  </div>

  <div>
    <img alt="Keyboard iOS" />
  </div>
</div>

## Bottom safe area space (Android vs iOS)

**Usage**

Buttons are positioned with a 24px space from the iOS bottom bar, ensuring optimal accessibility and a comfortable tap area.

<div>
  <div>
    <img alt="Bottom space Android" />
  </div>

  <div>
    <img alt="Bottom space iOS" />
  </div>
</div>

## States

**Usage**

Middle alignment ensures consistency across various screen sizes and component states, making the interface feel polished and intentional. This alignment strategy is especially effective for empty states, loading indicators, or other transient states, providing a seamless and cohesive user experience.

<img alt="Common states" />


# Notification Guidelines
Source: https://docs.world.org/mini-apps/guidelines/features-and-guidelines



## Guidelines

To maintain high-quality notifications, please adhere to the following guidelines:

* Notifications should be purely functional, not marketing-related.
* Notifications must be directly related to the mini app.
* Notifications must be relevant to the user.

## Username Substitution

It's extremely easy to personalize your notifications, by using usernames.
Use the special string `${username}` in your notification message, and it will substitute in
the recipient's username.

<CodeGroup>
  ```bash cURL theme={null}
  curl -X POST "https://developer.worldcoin.org/api/v2/minikit/send-notification" \
      -H "Authorization: Bearer {api_key}" \
      -H "Content-Type: application/json" \
      -d '{
            "app_id": "app_id", 
            "wallet_addresses": ["0x123", "0x456"], 
            "localisations": [
              {
                "language": "en",
                "title": "title",
                "message": "ðŸ§‘â€ðŸ³ We're cooking something special for you ${username}"
              }
            ],
            "mini_app_path": "worldapp://mini-app?app_id=[app_id]&path=[path]"
          }'
  ```
</CodeGroup>

when sent to users, the message becomes:\
`ðŸ§‘â€ðŸ³ We're cooking something special for you mistico`\
`ðŸ§‘â€ðŸ³ We're cooking something special for you tute`\
`ðŸ§‘â€ðŸ³ We're cooking something special for you struck`\
and so on.

<div>
  <div>
    ## Notification Badges

    If a user has pending notifications for your miniapp, and you maintain
    a 7 day rolling average open rate of 15% or higher, we'll show a badge on the user's home screen,
    next to your miniapp's icon.

    It's cleared once the miniapp is opened.

    Notification badges increase your miniapp's visibility on the home screen, leading to higher user engagement and traffic.
  </div>

  <div>
    <img alt="Notification Interface in the Developer Portal" />
  </div>
</div>

## Open Rate Goal

An excellent goal to aim for is a 25% open rate. This % means your notifications drive strong traffic to the miniapp.
You can see this stat in your dashboard in Developer Portal.

## Use Emoji & Curiosity in Titles

Increases visual salience and emotion.\
Examples:\
`ðŸ”¥ You're missing out on rewards`\
`ðŸ•¹ï¸ A new level just unlocked`\
`ðŸ¤” What's waiting inside the vault today?`

## Useful links

* [How To Send Notifications](/mini-apps/commands/how-to-send-notifications)
* [How To Request Notification Permissions](/mini-apps/commands/request-permission)
* [How To Get Notification Permissions](/mini-apps/commands/get-permissions)
* [Send Notification API Reference](/mini-apps/reference/api#send-notification)


# App Review Guidelines
Source: https://docs.world.org/mini-apps/guidelines/policy



World App seeks to foster a diverse and flourishing ecosystem of applications while at the same time ensuring users stay safe, and privacy is maximized. These applications are displayed to users within World App, but users interact with these applications either within a web browser or as a platform native application. World App has sole discretion of determining how apps are presented to users within its platform.

These guidelines dictate the rules for apps which seek to be displayed to users from within World App.

## MiniKit Integration

Integrate MiniKit to supercharge your web app with exclusive features like World ID and Wallet access, making your mini app more engaging and valuable to users.

To get your mini app approved, it's essential to use the MiniKit SDK commands effectively to enhance the user experience.
We're looking for meaningful integrations, whether through *World ID* and *Wallet access* , or other creative uses that add real value.

## Safety

The following content is not permitted for apps:

* **Objectionable Content:**
  * Defamatory, discriminatory, or mean-spirited content, including references or commentary about religion, race, sexual orientation, gender, national/ethnic origin, or other targeted groups
  * Realistic portrayals of people or animals being killed, maimed, tortured, or abused, or content that encourages violence.
  * Depictions that encourage illegal or reckless use of weapons and dangerous objects, or facilitate the purchase of firearms or ammunition.
  * Overtly sexual or pornographic material, defined as "explicit descriptions or displays of sexual organs or activities intended to stimulate erotic rather than aesthetic or emotional feelings."
  * NSFW (Not Safe For Work) content of any kind, including bots or AI generators that can produce, distribute, or facilitate access to NSFW content.
  * Inflammatory religious commentary or inaccurate or misleading quotations of religious texts.
  * False information and features, including inaccurate device data or trick/joke functionality, such as fake location trackers.
  * Harmful concepts which capitalize or seek to profit on recent or current events, such as violent conflicts, terrorist attacks, and epidemics.
  * Impersonating TFH or Worldcoin.
* **Physical Harm**
  * If your app behaves in a way that risks physical harm, we may reject it.
  * Apps that encourage consumption of tobacco and vape products, illegal drugs, or excessive amounts of alcohol are not permitted.

## Naming

Apps must comply with the below naming and description guidelines.

* **App naming:**
  * Keep names short and memorable for optimal recall and display.
  * Don't use "World" in the name.
  * Don't use descriptions as Mini App names.
  * Don't use generic functional terms like "Earn", "Swap", etc. as your Mini App name.
  * Don't try to mimic the name of a popular app, as this can lead to confusion. Apps may be rejected or penalized if their names mimic popular brands by simply swapping numbers or case.
  * Do not include trademarked words, names of other apps, or explicit content.
  * Exclude the use of special characters, or emojis.
  * Ensure the name works well in your primary languages, and isn't offensive in other major markets.
* **App description:**
  * Use plain, approachable language that clearly explains what the Mini App does.
  * Describe the benefit or purpose in a straightforward way.
  * Avoid spammy or misleading descriptions.
  * Keep the tone aligned with World's voice: simple, human, and trustworthy. Avoid exaggerated, tech-heavy, or overly promotional phrasing.
  * Write descriptions that are respectful, globally understandable, and free from language that might be offensive in other regions.
  * Don't list functionality like "Earn", "Swap", or "Send" as standalone descriptions. Instead, explain how the app helps the user in their everyday life.
  * Aim for one or two short sentences (under 25 words total) that communicate the app's value quickly. Users should understand the purpose at a glance e.g. Join real local meetups. No accounts, no spam, just one human per invite.

## Legal

Apps must comply with all legal requirements to be listed within World App. This includes the following:

* **Privacy:**
  * **Consent**: All apps that collect and store data from the user must request access and gain approval from the user before doing so
  * **Data Minimization:** Apps should only request access to data that is relevant to how the app functions
* **Regulatory Compliance:** The application itself is responsible for maintaining regulatory compliance in all jurisdictions where it selects to be shown to users. Although the burden of compliance rests on the submitted application, if TFH determines that an application is non-compliant with jurisdiction(s) it has a right to take down the application and ask for it to be re-submitted in jurisdictions where it is compliant

## App Submission

Applications must be submitted for review on the developer platform. Before submission, please ensure the following:

* Test your app for bugs
* Ensure that your app contains a live integration with a Worldcoin SDK, either IDkit or MiniKit
* Ensure that all app information in your dev portal submission is complete and accurate
* Ensure your contact information is updated so the review team can contact you
* Ensure your app can be accessed by the review team for testing
* Ensure your app complies with laws and regulations in the jurisdictions where it is shown to users.
* Check whether your app follows the [app guidelines](/mini-apps/guidelines/app-guidelines)
* Check whether your app follows the [smart contract development guidelines](/mini-apps/guidelines/smart-contract-development-guidelines) (if applicable)
* Check whether your app follows the [notification guidelines](/mini-apps/guidelines/features-and-guidelines) (if applicable)

Ensure your app does not violate any of these guidelines, otherwise your app will be rejected.

## App Review

The review team has sole discretion of approving applications for Mini Apps.

Apps will be reviewed as quickly as possible, though if the app is complex or difficult to test it may take some time. You will receive an email if the review status of your app changes, and you can view updates in the developer portal as well.

Tools for Humanity will approve all submitted apps if it deems the following are true:

* The data submitted in the form is complete and accurate
* The app is complete and contains all necessary copy and functionality to fulfil itâ€™s purpose outlined in the submission
* The app is a final version, and is not a demo, trial or beta version
* The app contains a live integration with IDkit or MiniKit that functioned properly when tested
* The app abides by the safety and legal guidelines

The review team will provide a rationale for any rejections, to which the developer can re-submit after remediating any concerns. If the application continuously fails review for the same reason, it may take longer for subsequent reviews to occur.

Additionally, World App provides users the ability to report apps. If an app is in violation of the safety and legal guidelines or the review team deems the app should be removed for other reasons, the team has the sole discretion to remove an app from the platform. If an app is removed from the platform or an investigation is in progress, the development team will be alerted.

## Technical Requirements

* On Android and iOS, the World App Mini App should support operation under poor internet connections and handle temporary disconnections properly.
* The World App Mini App must be reliable, with no infinite loading during non-standard user actions.
* The World App Mini App must comply with the rules of both the Android and iOS app stores.
* The World App Mini App must not contain features that are unavailable on certain platforms.
* User progress must synchronize seamlessly between different platform versions.

## User Support

* Developers must provide a valid email address for user support and ensure accessible means of communication for resolving any issues that arise.


# Smart Contract Development Guidelines
Source: https://docs.world.org/mini-apps/guidelines/smart-contract-development-guidelines



These guidelines define the minimum requirements for developing smart contracts for deployment & use within the World App Mini App Store. They are designed to protect users from malicious or negligent behaviors, especially in contracts that custody user funds.

## Applicability

These requirements apply toÂ **all**Â smart contracts submitted to the Mini App Store thatÂ **custody, lock, or manage user-owned assets**Â (fungible tokens, NFTs, or other on-chain value).

Failure to comply may result in rejection or removal from the platform.

## Custody & Upgradeability Rules

### Non-Upgradeable Custody Contracts

* **Requirement:**Â Custody contracts must beÂ **immutable**Â after deployment.

### Controlled Upgradeability (If Needed)

* If upgradeability is essential (e.g., for bug fixes), it must:
  * Use aÂ **multi-signature upgrade authorization**Â whereÂ **Tools For Humanity (TFH)**Â holdsÂ **1 of 2 keys**.
  * RequireÂ **TFH review and written approval**Â before any upgrade is executed.
  * Be subject to aÂ **public notice period**Â (recommended: 48â€“72 hours) before upgrade execution.

## Restricted Owner Privileges

### Prohibition of User Asset Withdrawal by Owner

* **No direct owner/admin functions**Â may exist that allow the developer (or any third party) to:
  * Transfer, withdraw, or seize assets deposited by users.
  * Change accounting logic in a way that reassigns user balances to the developer.

### Exceptions

* **Permitted:**Â Functions to withdrawÂ **protocol fees**Â orÂ **platform earnings**Â that are:
  * Clearly documented.
  * Separately accounted for from user funds.
  * Agreed upon during code review.

## Code Quality & Review Requirements

### Testing

* Contracts must includeÂ **comprehensive automated tests**, ideally in aÂ **Foundry**Â or similar high-quality test framework.
* Tests must cover:
  * Normal operation flows.
  * Edge cases and failure modes.
  * Security-critical logic (access control, withdrawals, deposits, upgrades).
* Code coverage target:Â **â‰¥90%**Â for critical custody logic.

### Repository Access

* Source code must be stored in aÂ **version-controlled repository**.
* The repository must beÂ **shared with the TFH review team**Â prior to deployment.

### Documentation

* Contracts must beÂ **fully documented**Â with:
  * **NatSpec comments**Â for all public/external functions.
  * Clear explanation of any access control roles and permissions.
  * Rationale for any upgradeability or special privilege mechanisms.

## Security Best Practices

### Recommended Patterns

* InheritÂ [**OpenZeppelin contracts**](https://github.com/OpenZeppelin/openzeppelin-contracts) for all token/contract standards
* FollowÂ [**Checks-Effects-Interactions**](https://fravoll.github.io/solidity-patterns/checks_effects_interactions.html)Â pattern ubiquitously

### Audits

* High-value custody contracts areÂ **strongly recommended**Â to undergo anÂ **independent security audit**.
* Audit reports should be shared with TFH prior to mainnet deployment.

### Common Pitfalls to Avoid

* No unbounded loops over user-controlled data.
* No hardcoded privileged addresses.
* Avoid arbitrary external call execution (`call`,Â `delegatecall`) in external facing functions unless strictly necessary and reviewed.

## Compliance & Enforcement

* Contracts failing to comply with these guidelines may be:
  * Rejected during review.
  * Removed from the Mini App Store.
* TFH reserves the right to request code changes or audits before approval.


# What are Mini Apps?
Source: https://docs.world.org/mini-apps/index

Learn what Mini Apps are and how to build native-like apps in World App with MiniKit, distribution, and monetization.

<img alt="Mini Apps" />

Mini apps enable third-party developers to create native-like applications within World App.
Best for small and medium sized developers who want access to a distribution channel of millions of users.
Build with flexible smart contracts and leverage World ID and the World wallet for seamless user experiences.

## How it Works

Mini apps are web applications running inside World App via webview. Using the MiniKit SDK, these applications can become
native-like and interact with the World ecosystem.

## Quick links

<CardGroup>
  <Card title="Mini Apps Statistics" icon="chart-simple" href="https://www.miniapps.world/">
    Statistics about the Mini Apps ecosystem.
  </Card>

  <Card title="World App Status" icon="signal" href="https://status.worldcoin.org/">
    Check the current status of World App.
  </Card>
</CardGroup>


# Community Tools & Perks
Source: https://docs.world.org/mini-apps/more/community-tools-perks



Special perks and integrations from trusted providers supporting the World Mini App ecosystem.

<CardGroup>
  <Card title="Developer Rewards Pilot" icon="cube" href="https://docs.google.com/forms/d/e/1FAIpQLSfgjLhpcUlocct1KwXapL326CDUQ1zOCEudyF5WO4RAD-wn7A/viewform">
    Pilot program rewarding qualifying Mini App developers based on verified
    human usage. \$300K USD equivalent in WLD over three months.
  </Card>

  <Card title="Grants" icon="cube" href="https://world.org/grants">
    Foundation Grants supporting the World Network and novel mini apps (50M WLD
    dedicated). [Learn more](https://world.org/grants)
  </Card>

  <Card title="Oculus Analytics" icon="chart-line" href="https://oculus.humanlabs.world">
    Early builders get \~10,000 real users sent to your Mini App. Free analytics
    and smart push notifications. By [Human Labs](https://x.com/WorldHumanLabs).
  </Card>

  <Card title="Alchemy" icon="flask" href="https://www.alchemy.com/blog/world-mini-app-builder-program">
    4 months free for Enterprise, 3 months free for PAYG, $500â€“$2000 in bonus
    incentives, plus co-marketing and onsite opportunities
  </Card>

  <Card title="Cloudflare" icon="cloud" href="https://www.cloudflare.com/forstartups/">
    Apply for Cloudflare for Startups program. Use 'World Mini App' as your
    partner when applying.
  </Card>

  <Card title="Lazo" icon="rocket" href="https://www.lazo.us/">
    15% discount on any Lazo product, plus 6 months free of Lazo One (Data Room

    * AI for fundraising).
  </Card>

  <Card title="ThirdWeb" icon="cube" href="https://www.thirdweb.com/">
    30 day free trial for all builders on World Chain. Use code: TW-WORLDCHAIN
  </Card>
</CardGroup>


# FAQ
Source: https://docs.world.org/mini-apps/more/faq



## Who covers gas fees for transactions?

World App sponsors gas fees for most transactions on Worldchain, subject to transaction minimums and restrictions.
When someone verifies their identity with World ID and uses the World App, their transactions on Worldchain are automatically covered by the network.
This means users don't need to hold or spend ETH to interact with mini apps, send tokens, or perform on-chain actions.
The sponsorship is handled behind the scenes with a paymaster contract that pays the gas fees whenever a verified user initiates a transaction.

## Do I need approval to launch a Mini App?

Yes. After development, submit your Mini App for review through the [Developer Portal](https://developer.worldcoin.org/). Approval is required before it's publicly listed.

## How does Send transaction command work?

The [Send Transaction command](/mini-apps/commands/send-transaction) is designed to execute on-chain transactions from the Mini App. When developers invoke this command,
they supply the target contract address, the encoded function call (calldata), and transaction parameters such as value.
For security, World App requires that any smart contract or token interactions are pre-approved (whitelisted) in the Developer Portal to prevent unauthorized transfers.
In cases where ERC-20 tokens are involved, instead of directly calling the approve function (which could expose the contract to front-running or manipulation), permits like Permit2 are used.
Permit2 enables users to sign a transaction off-chain that allows a specific allowance without sending an approval transaction, reducing friction and gas costs while providing a secure, non-custodial mechanism for token transfers.

## How does Sign Message command work?

The [Sign Message command](/mini-apps/commands/sign-message) prompts the user to cryptographically sign an arbitrary message using
their wallet's private key. When you call the command (e.g., MiniKit.commands.signMessage()), World App generates a standardized payload that may include a nonce, timestamp, and other context to prevent replay attacks.
The user's wallet then signs this message using ECDSA, producing a signature that proves the user controls the wallet, all without exposing the private key.
This signed message can be sent back to your backend for verification, ensuring the integrity of user actions and serving as secure off-chain authorization for various operations.

## Can I use the simulator to test transactions on mini apps?

No, mini app needs to be developed on mainnet (we don't support testnet). Gas is covered in the World App, so there's only deployment costs for you to develop on mainnet. Deploy "test" contracts to mainnet, and then redeploy "prod" mainnet contracts.

## How do I debug send transaction failed simulation?

Use the [Get Transaction Debug URL endpoint](/mini-apps/reference/api#get-transaction-debug-url) to get the debug URL for the transaction.

## How do I check how commands work and it's implementation?

Check the [Prod QA App](https://world.org/ecosystem/app_dfbe55706a640c82dce839bb0ecae74d) to check commands and the [minikit-js](https://github.com/worldcoin/minikit-js) repository.

## How do I test my mini app on mobile?

Remember that minikit ONLY works inside World App, so in order to test your mini app commands you must open it in World App

To test your Mini App directly on your phone, expose your app publicly using ngrok or any other tunneling service. After the URL is generated, go to the [Developer Portal](https://developer.worldcoin.org/) to configure it.

Example:

```bash theme={null}
ngrok http http://localhost:3000
```

## Why does my command fail when triggered immediately on page load?

This happens due to a race condition where MiniKit hasn't finished installing when you try to call a command. Since MiniKit uses a client-side component to install the provider onto the Window object, triggering a command in a separate useEffect hook right after page load can fail.

Solution: Include any commands you want to trigger on initialization inside the same useEffect hook where you install MiniKit:

```tsx theme={null}
"use client";

import { useEffect, ReactNode } from "react";
import { MiniKit } from "@worldcoin/minikit-js";

export const MiniKitProvider = ({ children }: { children: ReactNode }) => {
  useEffect(() => {
    MiniKit.install();

    // Add any commands you wish to trigger on start here to prevent race conditions
    MiniKit.commands.walletAuth({
      // ...
    });
  }, []);

  return <>{children}</>;
};
```

## What security considerations should I keep in mind when building Mini Apps?

MiniKit is purely a communication channel between the client and the app. Your application should never trust any payloads it receives on the client side by default.

All Verify, Pay, and Wallet Auth operations should be verified on your backend. Never rely solely on client-side validation for sensitive operations, as client-side data can be manipulated.
Always implement server-side verification to ensure the integrity and authenticity of user actions.


# Changelog
Source: https://docs.world.org/mini-apps/more/releases

Weekly updates for Mini Apps, Minikit, Dev Portal, and Docs.

<Update label="May 19, 2025">
  ### Mobile

  * \[Android] Multi-file selection added
  * \[iOS] Improved microphone permissions
  * \[Both] Notification badges for the home screen
  * \[Both] Refactored Mini App impressions work
  * \[Both] Transaction failure messages improved

  ### Dev Portal

  * Notification opt-in rate added to the dashboard
  * Updated draft Mini App logic and notifications
  * Sharing and deferred linking

  ### Minikit 1.9.5

  * Added transaction parallelism
  * Updated signed typed data
  * Fixed versioning issues blocking wallet-auth

  ### Docs

  * Updated Send Transaction implementation guide
  * Updated Sign Typed Data implementation guide
  * New integrations for Worldchain
  * Added Oracles to Worldchain
  * Sharing and deferred linking implementation guidelines
</Update>

<Update label="April 30, 2025">
  ### Mobile

  * \[iOS] Enhanced keyboard interaction within the App Store search
  * \[iOS] Fixes for UI issues, including layering and scrolling behavior
  * \[Both] World App 4.0 update: comprehensive updates for Mini Apps
  * \[Both] Updated App Store
  * \[Both] Fixes on deeplinking both internal and from external apps
  * \[Both] Wallet Auth v2 improvements
  * \[Both] The Contacts tab has been moved into Mini App for streamlined navigation
  * \[Both] Updated settings menu and UI/UX enhancements
  * \[Both] Mini App state management enhancements
  * \[Both] New haptic feedback command implemented for Mini Apps
  * \[Both] Spotlight Search now supported for Mini Apps
  * \[Both] Widgets are now customizable with reordering support
  * \[Both] Add the category ranking of the app to the app store detail page
  * \[Both] Get Started page for new users

  ### Minikit

  * New Web3 template
  * New template `npx @worldcoin/create-mini-app my-first-mini-app`
  * Prod QA Mini App for testing commands

  ### Dev Portal

  * Improved reporting link structure for easier tracking
  * Added metatag images for sharing Mini Apps

  ### Docs

  * Virality section
  * Authentication section
  * New templates (community and official) on docs
  * Developer rewards pilot
  * `llms-full.txt` added on getting started
  * Get transaction debug URL
</Update>

<Update label="March 17, 2025">
  ### Mobile

  * \[Both] Search has gotten much faster in the Mini Apps
  * \[Both] Mini Apps deeplinking fixes
  * \[Both] World Mini Apps widget
  * \[Android] Added `safeTxHash` and `userOpHash` in response from Send Transaction
  * \[Android] Added contacts to Get Permissions command
  * \[Android] Show settings in the pop-up menu on long press

  ### Minikit

  * Added NFC ID support to Minikit. You can now receive a more detailed `verification_level` response

  ### Dev Portal

  * Notification sending from developer portal
  * Import wallets as CSV

  ### Docs

  * New Quick Actions: PUF, World Companies Finder, One Pay, Orbital X
  * Added Send Transaction and Wallet Auth GIFs
  * NSFW prohibition
</Update>

<Update label="March 10, 2025" description="Minikit 1.7.1">
  ### Mobile

  * \[iOS] Notification paths bugs: Fixed
  * \[iOS] Contacts modal bugs: Fixed
  * \[iOS] Added safeTxHash and userOpHash in response from send transaction
  * \[iOS + Android] Include Mini App ID in Transaction Response Payload
  * \[iOS + Android] Added Haptic Feedback
  * \[Android] World Chat Bugs Fixed
  * \[iOS + Android] Mini App rearrange
  * \[iOS + Android] Spotlight Search Fixed
  * \[iOS + Android] Mini App Widget

  ### Minikit

  * Transaction improvements
    * Support for booleans in Send Transaction
    * Auto-formatting of content (no need to stringify manually)
  * Haptics support
  * Get Permissions: command to get notification permission status without requesting first

  ### Docs

  * World Chat Quick Actions Added
    * Pay
    * Request Payment
    * Draft Message
  * Google & Apple Pay Implementation guides
  * Haptic Feedback implementation guide
</Update>


# Webview Specifications
Source: https://docs.world.org/mini-apps/more/webview-spec



The widget is opened within the World App via a WebView. This means providers can tailor their solutions by considering the specific features and restrictions of these platforms.

### **Capabilities:**

* **WebView Engine:**
  * **Android:** Uses Android's native WebView implementation.
  * **iOS:** Uses **WKWebView**, the recommended web rendering engine on iOS, offering enhanced security and performance.
* **File System and Camera Access:**
  * Access to the camera and file system (e.g., for file uploads) is possible if the user grants permission.
* **Cookies and DOM Storage:**
  * Supported on both platforms with explicit activation for Android and default behavior for iOS.
* **Location:**
  * Location is supported on both platforms.
  ```javascript theme={null}
  navigator.geolocation.getCurrentPosition((position) => {
      console.log(position);
  });
  ```

### **Restrictions:**

* **New Windows:**
  * Opening new browser windows is prohibited. All navigation remains within the current WebView instance.
* **Zooming:**
  * **Android:** Not restricted by default.
  * **iOS:** Disabled.
* **Alert Dialogs:**
  * Alert Dialogs are not supported on iOS


# Mini App Store
Source: https://docs.world.org/mini-apps/quick-start/app-store

Submit your Mini App for review and distribution in World App; follow guidelines and resolve rejections.

To ensure a consistent user experience, apps will be rejected unless they follow our [guidelines](/mini-apps/guidelines/app-guidelines).

Once your mini app is ready to be published, you can submit it for review inside of the Developer Portal.
Once approved, your mini app will be available to all World App users to discover in the Mini Apps.

<img alt="Submit an App" />

If your app was rejected please reach out to @MateoSauton on Telegram for more information.


# Commands
Source: https://docs.world.org/mini-apps/quick-start/commands

Overview of Mini App commands: verify with World ID, pay, wallet auth, send transactions, share contacts, notifications, and more.

Commands are actions your mini app can perform in World App. Every command is available as either:

* an async function, that can be awaited, resolves with the result.
* a synchronous function that dispatches an event to an event listener.

Try our preview mini app to get a sense of how commands work. Scan the QR code below with your phone (You must have World App installed).

<div>
  <QRCodeGenerator />
</div>

<table>
  <thead>
    <tr>
      <th>Command</th>
      <th>Description</th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>Verify</td>
      <td>Request a World ID proof.</td>
    </tr>

    <tr>
      <td>Pay</td>
      <td>Request a payment</td>
    </tr>

    <tr>
      <td>Wallet Auth</td>

      <td>
        Authenticate via Sign in with Ethereum
      </td>
    </tr>

    <tr>
      <td>Send Transaction</td>
      <td>Interact with smart contracts</td>
    </tr>

    <tr>
      <td>Sign Message</td>

      <td>
        Sign personal messages with your wallet
      </td>
    </tr>

    <tr>
      <td>Share Contacts</td>

      <td>
        Share individual user contacts (username only)
      </td>
    </tr>

    <tr>
      <td>Request Permissions</td>
      <td>Notifications and Microphone Access</td>
    </tr>

    <tr>
      <td>Get Permissions</td>
      <td>Get user permissions</td>
    </tr>

    <tr>
      <td>Send Haptic Feedback</td>

      <td>
        Send haptic feedback to user's device
      </td>
    </tr>

    <tr>
      <td>Share</td>
      <td>Native OS share modal</td>
    </tr>

    <tr>
      <td>Chat</td>

      <td>
        Send Messages and Create Groups in World Chat
      </td>
    </tr>

    <tr>
      <td>Quick Actions</td>
      <td>Link to other mini apps</td>
    </tr>
  </tbody>
</table>


# Initialization
Source: https://docs.world.org/mini-apps/quick-start/init



When your mini app is initialized in World App, it will receive useful context, device properties and user preferences from World App.
These values can be accessed via the `MiniKit` object or in a raw object format via `window.WorldApp`.

```tsx theme={null}
// Useful metadata you can access from the MiniKit object
export type MiniKit = {
  user: {
    walletAddress?: string;
    username?: string;
    profilePictureUrl?: string;
    permissions?: { // These will be null until you call getPermissions()
      notifications: boolean;
      contacts: boolean;
      microphone: boolean;
    };
    optedIntoOptionalAnalytics?: boolean; // If this is false, you should not collect any analytics for this user.
  } | null;
  deviceProperties: {
    safeAreaInsets?: { // The safe area insets of the device.
      top: number;
      right: number;
      bottom: number;
      left: number;
    };
    deviceOS?: string; // The operating system of the device.
    worldAppVersion?: number; // The version of the World App.
  } | null;
  launchLocation: 'chat' | 'home' | 'app-store' | 'deep-link' | 'wallet-tab' | null; // Where the mini app was launched from.
};
```

### Accessing Mini App Open location

Open location tells you where your mini app was opened from. It can be very helpful for analytics and understanding user behavior. You can access it via:

```typescript theme={null}
import { MiniKit } from "@worldcoin/minikit-js";
console.log(MiniKit.location);
```

The possible values are:

```typescript theme={null}
export enum MiniAppLaunchLocation {
  Chat = 'chat',
  Home = 'home',
  AppStore = 'app-store',
  DeepLink = 'deep-link',
  WalletTab = 'wallet-tab',
}
```

### Accessing the Raw Object

If you chose to access the values via `window.WorldApp`, the structure will be similar.
Some types will not be properly mapped. In addition you'll get context of which version of commands a users World App supports.

Here's an example of what the raw object looks like:

```json theme={null}
{
  "pending_notifications": 0,
  "safe_area_insets": {
    "top": 0,
    "right": 0,
    "bottom": 0,
    "left": 0
  },
  "device_os": "ios",
  "world_app_version": 4000301,
  "is_optional_analytics": true,
  "supported_commands": [
    {
      "supported_versions": [
        1
      ],
      "name": "verify"
    },
    {
      "supported_versions": [
        1,
        2
      ],
      "name": "wallet-auth"
    },
    {
      "supported_versions": [
        1
      ],
      "name": "pay"
    },
    {
      "name": "sign-message",
      "supported_versions": [
        1
      ]
    },
    {
      "name": "sign-typed-data",
      "supported_versions": [
        1
      ]
    },
    {
      "supported_versions": [
        1
      ],
      "name": "send-transaction"
    },
    {
      "name": "share-contacts",
      "supported_versions": [
        1
      ]
    },
    {
      "name": "request-permission",
      "supported_versions": [
        1
      ]
    },
    {
      "supported_versions": [
        1
      ],
      "name": "get-permissions"
    },
    {
      "supported_versions": [
        1
      ],
      "name": "send-haptic-feedback"
    },
    {
      "name": "share",
      "supported_versions": [
        1
      ]
    },
    {
      "supported_versions": [
        1
      ],
      "name": "microphone-stream-started"
    },
    {
      "supported_versions": [
        1
      ],
      "name": "microphone-stream-ended"
    },
    {
      "name": "chat",
      "supported_versions": [
        1
      ]
    }
  ],
  "location": {
    "open_origin": "deeplink"
  }
}
```


# Getting Started
Source: https://docs.world.org/mini-apps/quick-start/installing

Create a Mini App with the official template or install MiniKit-JS manually.

[MiniKit-JS](https://github.com/worldcoin/minikit-js) is our official SDK for creating mini apps that work with World App.

## Quick Start

The fastest way to get started is by using our template next-15 repository.
Run the following command and follow the instructions to create a new mini app. For cleanliness we recommend using `pnpm` as your package manager.

```bash theme={null}
npx @worldcoin/create-mini-app@latest my-first-mini-app
```

<div>
  <img alt="Template" />

  <p>
    Correctly running template should look like this
  </p>
</div>

## Manual Installation

[MiniKit-JS](https://www.npmjs.com/package/@worldcoin/minikit-js) is the core lib, framework agnostic,

<CodeGroup>`pnpm install @worldcoin/minikit-js `</CodeGroup>

Or use a CDN like [jsdelivr](https://www.jsdelivr.com/package/npm/@worldcoin/minikit-js), for inline HTML, make sure to fill in the version.

<CodeGroup>
  ```html minikit-js theme={null}
  <script type="module">
    import { MiniKit } from "https://cdn.jsdelivr.net/npm/@worldcoin/minikit-js@[version]/+esm";
  </script>
  ```
</CodeGroup>

## Usage

1. Wrap your root with the MiniKitProvider component. This will initialize MiniKit and make it available throughout your app.

```tsx src/index.tsx theme={null}
import { MiniKitProvider } from "@worldcoin/minikit-js/minikit-provider";
export default async function Root({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <MiniKitProvider>
        <body className={inter.className}>{children}</body>
      </MiniKitProvider>
    </html>
  );
}
```

2. Check if MiniKit is installed.
   `MiniKit.isInstalled()` will only return true if the mini app is opened and initialized inside the World App. This is useful to distinguish between a user opening your app in the browser or in the World App.

```tsx theme={null}
console.log(MiniKit.isInstalled());
```

## Build with AI

We have generated a [llms-full.txt](https://docs.world.org/llms-full.txt) file that converts all our documentation into a single markdown document following the [https://llmstxt.org/](https://llmstxt.org/) standard.

## Template Repositories

The following template repositories are also available:

* [Vanilla JS (using a CDN) template (featuring a simple backend for verifications)](https://github.com/new?template_name=minikit-js-template\&template_owner=worldcoin),
* [Community example - Wallet Auth using JWT](https://github.com/wlding-blocks/wld-mini-apps-101).
* [Community example - Wallet Auth using NextAuth](https://github.com/supercorp-ai/minikit-wallet-auth-next-auth).

Otherwise, continue below with the installation instructions.

<Note>
  Watch a video tutorial [here](https://www.youtube.com/watch?v=QJ0htHP6lb0).
</Note>


# Responses
Source: https://docs.world.org/mini-apps/quick-start/responses

Handle Mini App responses: await async command results or subscribe to events, then verify proofs on your backend.

World App will return responses to your mini app based on the command sent. You can define custom logic to handle these responses with MiniKit.

There are two ways to handle responses:

1. **Async Handling**: The most common use case is to use async handlers. These let you simply await the commands. The response is returned in the `finalPayload` object.

```tsx Async handlers theme={null}
import { MiniKit } from "@worldcoin/minikit-js";
// ...

const handleVerify = async () => {
  // ...

  // The async versions of commands, return an object that contains the final payload, which is the response from World App,
  // as well as commandPayload, which is the object that is returned after calling the command.
  const { finalPayload } = await MiniKit.verifyAsync({
    //...
  });

  if (finalPayload.status === "error") {
    return console.log("Error payload", finalPayload);
  }

  // Verify the proof in the backend
  const verifyResponse = await fetch("/api/verify", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
    },
    body: {
      // ...
    },
  });
};
```

2. **Synchronous Handling**: Synchronous require you to subscribe to the event.

```tsx Event listeners theme={null}
import { MiniKit, ResponseEvent } from "@worldcoin/minikit-js";

export function ReactComponent() {
  // ...
  useEffect(() => {
    MiniKit.subscribe(ResponseEvent.MiniAppVerifyAction, async (payload) => {
      if (payload.status === "error") {
        return console.log("Error payload", payload);
      }

      // Verify the proof in the backend
      const verifyResponse = await fetch("/api/verify", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: {
          //...
        },
      });
    });

    return () => {
      // Clean up on unmount
      MiniKit.unsubscribe(ResponseEvent.MiniAppVerifyAction);
    };
  }, []);
}
```


# Testing your mini app
Source: https://docs.world.org/mini-apps/quick-start/testing

Enter your App ID and scan the generated QR code to test your mini app.

# Testing

### Testing your mini app

Enter your app id in the text box below and scan the QR code generated with your phone's camera.
Your app id is in the developer portal in the format `app_xxxxxxxxxx`.

<QRCodeGenerator />

### Tips

1. You can use [Ngrok](https://ngrok.com/), [zrok](https://zrok.io/) or [tunnelmole](https://tunnelmole.com/) for local testing.
2. [Eruda](https://github.com/liriliri/eruda) is helpful for showing logs on mobile.
3. You can use the [L2 Faucet](https://www.l2faucet.com/world) to get testnet WLD on Sepolia.


# Address Book
Source: https://docs.world.org/mini-apps/reference/address-book



The Address Book is a contract that stores verified World ID addresses. You can check if a user's address and associated ENS name (if available) is Orb verified using the `getIsUserVerified` helper function.

## Considerations

* Default RPC is `https://worldchain-mainnet.g.alchemy.com/public`
* Contract Address is [0x57b930D551e677CC36e2fA036Ae2fe8FdaE0330D](https://worldscan.org/address/0x57b930D551e677CC36e2fA036Ae2fe8FdaE0330D#readContract).

## Implementation

The helper function connects to the World Chain and checks if a given wallet address is verified by querying the Address Book contract.

## Example Usage

```typescript theme={null}
import { getIsUserVerified } from "@worldcoin/minikit-js"

const userWalletAddress = "0x000000000000000000000000000000000000dEaD"
const isUserVerified = await getIsUserVerified(userWalletAddress) // optionally you can provide your rpc url as a second argument to the function
```

* Returns `true` if the address is verified
* Returns `false` if the address is not verified
* Throws an error if the verification check fails

## React Bindings

For React applications, we provide a hook `useIsUserVerified` that handles the verification check and loading state.


# API Reference
Source: https://docs.world.org/mini-apps/reference/api

Mini Apps API endpoints and playground (OpenAPI-backed)

<Note>
  This section now uses an OpenAPI spec to power endpoint pages and the
  playground. Prefer the endpoint pages in the sidebar for the latest
  parameters, responses, and live requests. Spec:
  <code>/openapi/world-miniapps.json</code>.
</Note>

## Endpoints

* POST /api/v2/create-action/
* POST /api/v2/minikit/send-notification
* POST /api/v2/verify/
* GET /api/v2/minikit/transaction/
* GET /api/v2/minikit/transaction/debug
* GET /api/v2/minikit/user-grant-cycle
* GET /public/v1/miniapps/prices

Below content was removed to avoid duplication. Use the endpoint pages in the sidebar.

## Send Notification

<ParamField type="POST">
  [https://developer.worldcoin.org/api/v2/minikit/send-notification](https://developer.worldcoin.org/api/v2/minikit/send-notification)
</ParamField>

This endpoint lets you send localized notifications to users of your mini app and requires an `api_key`.

### How do localizations work?

The user's language is available to you when they access your mini app
(via [Navigator](https://developer.mozilla.org/en-US/docs/Web/API/Navigator/language)).

All you need to do is provide localizations. Our backend will automatically infer which language is preferred by the user.
Currently we support only a subset of languages, with plans to expand. Find the entire list [here](/mini-apps/reference/api#supported-languages).
You can only specify languages that we support.

* If a user prefers a language that we don't currently support, we will deliver the notification in English.
* If you don't specify a localization for the user's preferred language, the notification will not be delivered.
  The response will include a specific `reason` to inform you of this.

### Body Params

You are required to either specify both `title` and `message` OR `localisations`.

<ParamField type="string[]">
  The `wallet_addresses` is an array of wallet addresses to send the
  notification to. Users must have opted in to notifications for your app. Max
  1000 users per call.
</ParamField>

<ParamField type="object[]">
  `localisations` is an array of objects with properties:

  * `language` (string, required): The language of the notification.
  * `title` (string, required): The localized title of the notification.
  * `message` (string, required): The localized message of the notification.

  It's required to provide at least the `en` language.
</ParamField>

<ParamField type="string">
  Note: This will not localize your notifications. The `title` is the title of
  the notification. It should be 30 characters or less. May contain emojis.
</ParamField>

<ParamField type="string">
  Note: This will not localize your notifications. The `message` is the message
  of the notification. It should be 200 characters or less. You can include the
  special variable `${username}` in your message, which will be replaced with
  the actual username of the recipient when the notification is delivered.
</ParamField>

<ParamField type="string">
  The `mini_app_path` is the url encoded path of the mini app where your
  notification should link to when the user clicks on it. Should be of the
  format `worldapp://mini-app?app_id=[app_id]&path=[path]` (path is optional).
</ParamField>

<ParamField type="string">
  The `app_id` is the identifier of the app initiating the transaction.
</ParamField>

### Request Headers

<ParamField type="string">
  The `Authorization` header should be the `api_key` for your app from the
  Developer Portal. Make sure to prefix it with `Bearer {api_key}`.
</ParamField>

<CodeGroup title="Request">
  ```bash cURL theme={null}
  curl -X POST "https://developer.worldcoin.org/api/v2/minikit/send-notification" \
      -H "Authorization: Bearer {api_key}" \
      -H "Content-Type: application/json" \
      -d '{"app_id": "app_id", "wallet_addresses": ["0x123", "0x456"], "title": "title", "message": "Hello ${username}, your transaction is complete!", "mini_app_path": "mini_app_path"}'
  ```

  ```javascript theme={null}
  fetch(apiUrl, {
    method: "POST",
    headers: {
      Authorization: "Bearer {api_key}",
    },
    body: JSON.stringify({
      app_id: "app_id",
      wallet_addresses: ["0x123", "0x456"],
      title: "title",
      message: "Hello ${username}, your transaction is complete!",
      mini_app_path: "mini_app_path",
    }),
  });
  ```
</CodeGroup>

### Response

<ResponseField name="success" type="boolean">
  Indicates if the API request was successful.
</ResponseField>

<ResponseField name="status" type="number">
  The HTTP status code of the response.
</ResponseField>

<ResponseField name="result" type="array">
  An array of notification delivery results for each wallet address, where each
  item contains: - `walletAddress` (string): The wallet address that the
  notification was attempted to be sent to - `sent` (boolean): Whether the
  notification was successfully sent to this wallet address - `reason` (string,
  optional): If the notification failed to send, this field contains the reason
</ResponseField>

<CodeGroup title="Response">
  ```json theme={null}
  {
      "success": true,
      "status": 200,
      "result": [
          {
              "walletAddress": "0x377da9cab87c04a1d6f19d8b4be9aef8df26fcdd",
              "sent": true
          },
          {
              "walletAddress": "0x444da9cab87c04a1d6f19d8b4be9aef8df26fcdd",
              "sent": false,
              "reason": "User has notification disabled for World App"
          }
      ]
  }
  ```
</CodeGroup>

### Supported Languages

| Language                     | Code     |
| ---------------------------- | -------- |
| English                      | `en`     |
| Catalan                      | `ca`     |
| Chinese Simplified           | `zh_CN`  |
| French                       | `fr`     |
| German                       | `de`     |
| Hindi                        | `hi`     |
| Indonesian                   | `id`     |
| Japanese                     | `ja`     |
| Korean                       | `ko`     |
| Malay                        | `ms`     |
| Polish                       | `pl`     |
| Portuguese                   | `pt`     |
| Spanish                      | `es`     |
| Spanish (Latin America)      | `es_419` |
| Thai                         | `th`     |
| Traditional Chinese (Taiwan) | `zh_TW`  |

***

## Get Transaction

<ParamField type="GET">
  [https://developer.worldcoin.org/api/v2/minikit/transaction/\{transaction\_id}](https://developer.worldcoin.org/api/v2/minikit/transaction/\{transaction_id})
  ?app\_id=\&type=
</ParamField>

This endpoint lets you query your apps transactions for their current status. You will only be able to query for transactions of apps where you possess the `api_key`.

### Query Params

<ParamField type="string">
  The `app_id` corresponding to the transaction that is being queried.
</ParamField>

<ParamField type="string">
  The `type` is either `payment` or `transaction` depending on the command you
  used.
</ParamField>

<CodeGroup title="Request">
  ```bash cURL theme={null}
  curl -X GET "https://developer.worldcoin.org/api/v2/minikit/transaction/{transaction_id}"
  ```

  ```javascript theme={null}
  fetch(apiUrl, {
    method: "GET",
  });
  ```
</CodeGroup>

### Response

<ResponseField name="reference" type="string">
  The `reference` is your specified unique identifier for the transaction.
</ResponseField>

<ResponseField name="transaction_hash" type="string">
  The `transaction_hash` is the hash of the transaction on the blockchain.
</ResponseField>

<ResponseField name="transaction_status" type="string">
  The current `transaction_status`, can be either 'pending', 'mined', or
  'failed'.
</ResponseField>

<ResponseField name="from" type="string">
  The `from` is the address of the sender.
</ResponseField>

<ResponseField name="chain" type="string">
  The `chain` is the name of the blockchain network.
</ResponseField>

<ResponseField name="timestamp" type="string">
  The `timestamp` is the time when the transaction was created, in ISO 8601
  format.
</ResponseField>

<ResponseField name="token_amount" type="string">
  The `token_amount` is the amount of tokens transferred, in BigInt with 6
  decimals.
</ResponseField>

<ResponseField name="token" type="string">
  The `token` is the type of token transferred.
</ResponseField>

<ResponseField name="to" type="string">
  The `to` is the address of the receiver.
</ResponseField>

<ResponseField name="app_id" type="string">
  The `app_id` is the identifier of the app initiating the transaction.
</ResponseField>

<CodeGroup title="Response">
  ```json Payment theme={null}
  {
      "reference": "1fa38f30-8ee1-4e4b-9988-0517a774f96c",
      "transaction_hash": "0xfb25cb74b13d51deeb1a91460619c3d86a7637d40dd29831aa38dd6cbb05e880",
      "transaction_status": "pending",
      "from": "0x0c892815f0B058E69987920A23FBb33c834289cf",
      "chain": "worldchain",
      "timestamp": "2024-01-01T00:00:00.000Z", // ISO 8601
      "token_amount": "100000000", // amount in BigInt with 6 decimals
      "token": "USDC",
      "to": "0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045",
      "app_id": "app_9a73963d73efdf2e7d9472593dc9dffd"
  }
  ```

  ```json Transaction theme={null}
  {
    "reference": "a7e69e1f-1234-4c2a-bb77-0f3b1c9b1e4c",
    "transaction_hash": "0xa8388148b630b49a3d5a739eaad9e98b5766235cdb21a5ec8d3f89053d982a71",
    "transaction_status": "failed",
    "from": "0x2321401e6a175a7236498ab66f25cd1db4b17558",
    "chain": "worldchain",
    "timestamp": "2024-09-09T15:18:25.320Z",
    "token_amount": "0",
    "token": "WLD",
    "to": "0x2321401e6a175a7236498ab66f25cd1db4b17558",
    "app_id": "app_staging_5748c49d2e6c68849479e0b321bc5257"
  }
  ```
</CodeGroup>

***

## Get Transaction Debug URL

<ParamField type="GET">
  [https://developer.worldcoin.org/api/v2/minikit/transaction/debug?app\_id=](https://developer.worldcoin.org/api/v2/minikit/transaction/debug?app_id=)
</ParamField>

This endpoint lets you debug transactions that failed during the prepare stage. It provides Tenderly URLs for permit2 operations with expired permits. You will only be able to query for transactions of apps where you possess the `api_key`.

The debug URL is only available once the permit2 expires. So for development it will be better to set a shorter expiry time so you can get the debug URL quicker.

### Query Params

<ParamField type="string">
  The `app_id` corresponding to the transaction that is being queried.
</ParamField>

### Request Headers

<ParamField type="string">
  The `Authorization` header should be the `api_key` for your app from the
  Developer Portal. Make sure to prefix it with `Bearer {api_key}`.
</ParamField>

<CodeGroup title="Request">
  ```bash cURL theme={null}
  curl -X GET "https://developer.worldcoin.org/api/v2/minikit/transaction/debug?app_id={app_id}" \
      -H "Authorization: Bearer {api_key}"
  ```

  ```javascript theme={null}
  fetch(apiUrl, {
    method: "GET",
    headers: {
      Authorization: "Bearer {api_key}",
    },
  });
  ```
</CodeGroup>

### Response

<ResponseField name="transactions" type="array">
  An array of transaction debug information, where each item contains: -
  `debugUrl` (string): The Tenderly URL for debugging the transaction -
  `createdAt` (string): The timestamp when the transaction was created, in ISO
  8601 format - `block` (number): The block number where the transaction was
  attempted - `simulationRequestId` (string): The ID of the simulation request -
  `simulationError` (string): The error message from the simulation, if any -
  `walletAddress` (string): The wallet address associated with the transaction
</ResponseField>

<CodeGroup title="Response">
  ```json theme={null}
  {
      "transactions": [
          {
              "debugUrl": "https://dashboard.tenderly.co/tx/...",
              "createdAt": "2024-03-21T10:30:00.000Z",
              "block": 12345678,
              "simulationRequestId": "sim_abc123def456",
              "simulationError": "Permit signature expired",
              "walletAddress": "0x1234..."
          }
      ]
  }
  ```
</CodeGroup>

***

## Get Prices

<ParamField type="GET">
  [https://app-backend.worldcoin.dev/public/v1/miniapps/prices?cryptoCurrencies=WLD,USDC\&fiatCurrencies=](https://app-backend.worldcoin.dev/public/v1/miniapps/prices?cryptoCurrencies=WLD,USDC\&fiatCurrencies=)
</ParamField>

This endpoint lets you query the latest prices of the Worldcoin token in various fiat currencies. We offer this as a service to make it easier to use WLD as a currency.

### Query Params

<ParamField type="string">
  The `fiatCurrencies` is a comma-separated list of fiat currencies following
  ISO4217 currency code. eg. `USD,EUR,JPY,ARS`
</ParamField>

<ParamField type="string">
  The `cryptoCurrencies` is a comma-separated list of currencies we support. eg.
  `USDC,WLD`
</ParamField>

<CodeGroup title="Request">
  ```bash cURL theme={null}
  curl -X GET "https://app-backend.worldcoin.dev/public/v1/miniapps/prices?cryptoCurrencies=WLD&fiatCurrencies=USD"
  ```

  ```javascript theme={null}
  fetch(apiUrl, {
    method: "GET",
  });
  ```
</CodeGroup>

### Response (abridged)

Detailed are a just a few values in the return that could be confusing. See the response object in the bottom right column for the full list of fields

<ResponseField name="prices" type="string">
  The `prices` is an object where each key is the respective currency code
</ResponseField>

<ResponseField name="amount" type="string">
  The `amount` represents the non converted value for the price of 1 WLD for a
  given currency
</ResponseField>

<ResponseField name="decimals" type="string">
  The current `decimals`, should be used to calculate the converted price. ie an
  amount of 1000000 with 6 decimals would mean a price of \$1.00 via, 1000000 \*
  10^-6
</ResponseField>

<CodeGroup title="Response">
  ```json theme={null}
  {
      "result": {
          "prices": {
              "WLD": {
                  "USD": {
                      "asset": "USD",
                      "amount": "1510763",
                      "decimals": 6,
                      "symbol": "USD"
                  },
              },
              "USDC": {
                  "USD": {
                      "asset": "USD",
                      "amount": "1000058",
                      "decimals": 6,
                      "symbol": "USD"
                  },
              }
          }
      }
  }
  ```
</CodeGroup>


# Credit Scoring API
Source: https://docs.world.org/mini-apps/reference/credit-api

Real-time creditworthiness for World accounts. Look up by wallet address or World username to get borrower state and a credit score.

World proves there's a real human behind an account. The Credit API tells you whether you can trust them. It provides real-time creditworthiness data for [over half a million](https://credit.cash/analytics) World accounts that have borrowed on [Credit](https://world.org/ecosystem/app_ebdd8475db3238254fca5b25ccba266a). This lets you focus your app and incentives on trustworthy users who are less likely to game or farm your system.

This API derives a userâ€™s credit score solely from their on-chain behavior on Credit, using data sourced directly from smart contract events.

## How to use it

Send a `GET` request to:

```bash theme={null}
https://credit.cash/api/borrower/[identifier]
```

where `[identifier]` is either the user's wallet address or [World username](/mini-apps/reference/usernames).

The response is a JSON object with two keys:

* `state`: the user's status on Credit
* `score`: the user's credit score (integer)

### User state

`state` is one of:

* `INACTIVE`: Borrower has no outstanding loan. They could be a new user or never borrowed.
* `ACTIVE`: Borrower has an outstanding loan that has not yet passed its overdue deadline.
* `DEFAULTED`: Borrower has an outstanding loan that is past due and not fully repaid.

### Credit score

The `score` is an integer that:

* Starts at 0 for new users
* Increases as users successfully repay loans and build a repayment track record

Use these bands to categorize borrowers:

| **Score range** | **Band** | **Description**                              |
| --------------- | -------- | -------------------------------------------- |
| 0               | New      | No loan history or no loans timely repaid    |
| 1-99            | Bronze   | Early borrower with minimal history          |
| 100-299         | Silver   | Developing credit with some successful loans |
| 300-599         | Gold     | Established borrower with solid history      |
| 600-999         | Platinum | Excellent track record                       |
| 1000+           | Diamond  | Elite borrower with extensive history        |

## Example

### Query

Get data for user with wallet address `0x764C890E7D96481cBEa64c64C0F9cFF34bFF2Ce7`:

```bash theme={null}
curl -s "https://credit.cash/api/borrower/0x764C890E7D96481cBEa64c64C0F9cFF34bFF2Ce7"
```

### Response

```json theme={null}
{
  "state": "INACTIVE",
  "score": 1947
}
```

## Tips

* Use score thresholds to shape your rewards and incentives. For example, offer higher rewards to users with high credit scores, who are more likely to be high-quality, and lower rewards to users with low credit scores, who are more likely to engage in fraud.
* Treat `DEFAULTED` as a strong risk signal. These accounts are much more likely to have sold their World account or be banned for fraud, so exclude them from sensitive actions like valuable rewards, referrals, and high-impact features.
* Add extra scrutiny or manual review for low-score users, such as additional verification or smaller caps, instead of blocking them outright. This lets you onboard new but unproven accounts safely.

## Error codes

| **Status** | **Error**                   | **Description**                        |
| ---------- | --------------------------- | -------------------------------------- |
| 400        | Missing identifier          | No wallet address or username provided |
| 404        | Username not found          | World username could not be resolved   |
| 500        | Failed to get borrower info | Internal server error                  |

## Support

For support, questions, or suggestions, contact via Telegram:

* [Diego](http://t.me/antidiego)
* [Monchi](http://t.me/cairoeth)


# Errors
Source: https://docs.world.org/mini-apps/reference/errors



This page is a reference to error codes returned by MiniKit.

## Verify

Below are the error codes you could receive with the `Verify` command

| Code                        | Description                                                                                                                     | How to fix?                                                                                                                                   |
| --------------------------- | ------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------- |
| `verification_rejected`     | User rejected the World ID request in World App.                                                                                | If this was a mistake, trigger the verify command again.                                                                                      |
| `max_verifications_reached` | This person has already verified for this particular action the maximum number of times allowed.                                | Nothing to do. User cannot verify for this action again.                                                                                      |
| `credential_unavailable`    | This user does not have the requested credential.                                                                               | The user must verify at the Orb or verify their unique device in World App to receive the credential required.                                |
| `malformed_request`         | The request payload couldn't be decrypted or did not conform to the standard.                                                   | Ensure MiniKit is configured properly and all parameters are valid.                                                                           |
| `invalid_network`           | The application is configured for a different environment than the verifying user's client.                                     | Ensure you use the [Worldcoin Simulator](https://simulator.worldcoin.org) for Staging applications and World App for Production applications. |
| `inclusion_proof_failed`    | The sequencer returned an unexpected error when retrieving the inclusion proof.                                                 | Ask the user to try again. This may be due to a temporary network issue, or a bug with World App or the Signup Sequencer.                     |
| `inclusion_proof_pending`   | The user might have the requested credential, but it is not available on-chain yet. It might be available for API verification. | Ask the user to verify again in approximately one hour.                                                                                       |
| `unexpected_response`       | There was a problem with the response obtained from the WLD app.                                                                | Try again, though in most cases these will require contacting us to report the bug.                                                           |
| `generic_error`             | An unhandled exception occurred.                                                                                                | Try again, though in most cases these will require contacting us to report the bug.                                                           |

## Pay

Below are the error codes you could receive with the `Pay` command

| Code                   | Description                                                                       | How to fix?                                                                         |
| ---------------------- | --------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------- |
| `input_error`          | There was a problem with this request. Please try again or contact the app owner. | Ensure the request is properly formed and try again.                                |
| `payment_rejected`     | You've cancelled the payment in World App.                                        | If this was a mistake, initiate the payment again.                                  |
| `invalid_receiver`     | The receiver address is invalid. Please contact the app owner.                    | You don't have this address whitelisted inside the Developer Portal.                |
| `insufficient_balance` | You do not have enough balance to complete this transaction.                      | Add more funds to your wallet                                                       |
| `transaction_failed`   | The transaction failed. Please try again.                                         | Try the transaction again. Something failed on-chain.                               |
| `generic_error`        | Something unexpected went wrong. Please try again.                                | Try again, though in most cases these will require contacting us to report the bug. |

## Wallet Auth

Below are the error codes you could receive with the `walletAuth` command

| Code                | Description                                     | How to fix?                                                                                          |
| ------------------- | ----------------------------------------------- | ---------------------------------------------------------------------------------------------------- |
| `malformed_request` | Provided parameters in the request are invalid. | Ensure the request is properly formed and try again. If the problem persists, contact the app owner. |
| `user_rejected`     | User rejected the request.                      | If this was a mistake, initiate the request again.                                                   |
| `generic_error`     | Something unexpected went wrong.                | Try the request again. If the problem persists, contact the app owner.                               |

## Transactions

Below are the error codes you could receive with the `Transaction` command

| Code                                | Description                                                                               | How to fix?                                                                                                                                                 |
| ----------------------------------- | ----------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `invalid_operation`                 | Transaction included an operation that was invalid                                        | Your app tried using a disallowed operation. These include approve, setAllowance, setApprovalForAll, or setApprovalForAll.                                  |
| `invalid_contract`                  | App must whitelist the contract you're calling in the Developer Portal                    | Go to the Developer Portal and whitelist the contract you're calling                                                                                        |
| `user_rejected`                     | User declined the transaction modal                                                       | User closed the transaction modal.                                                                                                                          |
| `input_error`                       | Payload received does not conform to specified type                                       | Ensure the request is properly formed and try again. Note all args must be string. Payload has max size of 8kb so your ABI should just be for your function |
| `simulation_failed`                 | Simulation provider transaction simulation failed (this can include insufficient balance) | Txn simulation failed see the debugUrl returned to understand why                                                                                           |
| `transaction_failed`                | Transaction failed please try again later                                                 | Try again later. Could be blob fees too high or network congestion                                                                                          |
| `generic_error`                     | Request failed for unknown reason                                                         | Try the request again. If the problem persists, contact the app owner.                                                                                      |
| `daily_tx_limit_reached`            | Daily transaction limit reached                                                           | Max 100 transactions per day. Wait until the next day.                                                                                                      |
| `disallowed_operation`              | Transaction included an operation that was disallowed                                     | Make sure you are not calling functions on the user's safe, doing approvals, calling safe admin functions, etc.                                             |
| `permitted_amount_exceeds_slippage` | Permitted amount exceeds slippage                                                         | You must spend at least 90% of the permitted amount                                                                                                         |
| `permitted_amount_not_found`        | Permitted amount not found                                                                | Permitted amount not found in permit2 payload                                                                                                               |

Other helpful things

1. If you get a GS026 error, it means the signature is not valid. Most likely there's something switched in your args vs your permit. Double check each argument usually this is the nonce and timestamp getting mixed up.


# Microphone
Source: https://docs.world.org/mini-apps/reference/microphone



<Note>
  Microphone is only available from World App 2.8.85 and MiniKit 1.9.6.
</Note>

Microphone uses the standard web api [Navigator.mediaDevices](https://developer.mozilla.org/en-US/docs/Web/API/Navigator/mediaDevices).
These two conditions must be met in order to use the microphone:

* The user must grant permission to your mini app to use the microphone.
* The user must grant permission to World App to use the microphone.

## Using the microphone

Request permission from the user to enable microphone for your mini app with the [request permission command](/mini-apps/commands/request-permission).

* If you receive a `world_app_permission_not_enabled` or `permission_disabled` error code, you must prompt the user to enable microphone for World App first.
  This can be done by simply trying to start recording.
* The microphone will automatically be turned off if the user closes your mini app or World App.

```tsx theme={null}
  const [isMicOn, setIsMicOn] = useState(false);
  const [stream, setStream] = useState<MediaStream | null>(null);
  // ...
  const toggleMicrophone = useCallback(async () => {
    if (isMicOn) {
      // Stop microphone access
      if (stream) {
        stream.getTracks().forEach((track) => track.stop());
        setStream(null);
      }
      setIsMicOn(false);
    } else {
      // Start microphone access
      try {
        const newStream = await navigator.mediaDevices.getUserMedia({
          audio: true,
        });
        setStream(newStream);
        setIsMicOn(true);
      } catch (error) {
        console.error('Error accessing microphone:', error);
      }
    }
  }, [isMicOn, stream]);
```

## Debugging

* If you receive a `DomException Error`, it's most likely because the user hasn't granted permission to your mini app to use the microphone.
* If the microphone turns off after a few seconds it's because the user has not granted permission to your mini app to use the microphone.


# Payment Methods
Source: https://docs.world.org/mini-apps/reference/payment-methods



Integrate Apple Pay and Google Pay into your mini-app

<Note>
  Both Apple Pay and Google Pay run directly in the WebView environment of your
  mini-app, using their respective JavaScript APIs.
</Note>

## Environment Setup

First, ensure your mini-app has a secure HTTPS environment, as both Apple Pay and Google Pay require it.

<Tabs>
  <Tab title="Apple Pay">
    For Apple Pay, you must: - Register for an Apple Developer account -
    Configure your merchant ID - Register your domain with Apple - Set up
    merchant validation on your server [Complete setup guide on Apple's
    website](https://applepaydemo.apple.com/)
  </Tab>

  <Tab title="Google Pay">
    For Google Pay, you must: - Set up a Google Pay merchant account - Configure
    your Google Pay API in the Google Pay Business Console - Obtain your
    merchant ID [Complete setup guide on Google's
    website](https://developers.google.com/pay/api/web/guides/resources/demos)
  </Tab>
</Tabs>

### Testing

Test your integration thoroughly using test cards and sandbox environments.

<Tabs>
  <Tab title="Apple Pay">
    **Development Environment:** - Use Apple Pay's sandbox environment - Test
    with Apple's test cards **Test Cards:** - You can use any valid card number
    in the sandbox - No actual charges will be processed **Testing Checklist:**

    * Verify merchant validation works - Test on both iOS devices and Safari on
      macOS - Check error handling - Verify payment completion flows

    <video>
      <source type="video/mp4" />

      Your browser does not support the video tag.
    </video>

    Apple Pay integration demo
  </Tab>

  <Tab title="Google Pay">
    **Development Environment:** - Use Google Pay's TEST environment - Test with
    Google's test cards **Test Cards:** - Use test PAN: 4111 1111 1111 1111 -
    Expiration: Any future date - CVV: Any 3 digits **Testing Checklist:** -
    Verify button displays correctly - Test on Android devices - Check error
    handling - Verify payment completion flows

    <img alt="Google Pay integration example" />

    Google Pay integration example
  </Tab>
</Tabs>

## Limitations and Considerations

* **Platform Restrictions**: Apple Pay only works on iOS/macOS devices with Safari, while Google Pay is primarily for Android
* **Device Support**: Users must have devices that support these payment methods
* **WebView Context**: Some features might behave differently in the mini-app WebView compared to a standard browser

<Warning>
  For Apple Pay merchant validation, your server needs to be accessible via
  HTTPS and properly configured with Apple's developer portal.
</Warning>

## Additional Resources

* [Apple Pay Demo and Documentation](https://applepaydemo.apple.com/)
* [Google Pay API Documentation](https://developers.google.com/pay/api/web/guides/resources/demos)
* [Apple Pay Human Interface Guidelines](https://developer.apple.com/design/human-interface-guidelines/apple-pay/overview/)
* [Google Pay Web Integration Guide](https://developers.google.com/pay/api/web/guides/tutorial)


# Status Page
Source: https://docs.world.org/mini-apps/reference/status-page



You can check the current status of World services at [status.worldcoin.org](https://status.worldcoin.org).

<Note>
  The Networks section is not up to date yet.
</Note>

For transactions, status is determined by:

* **Disruption**: Transactions taking longer than 45 seconds
* **Outage**: Transactions taking longer than 5 minutes

## Get Status

<ParamField type="GET">
  [https://status.worldcoin.org/api/services](https://status.worldcoin.org/api/services)
</ParamField>

This endpoint returns the current status of all World services.

### Query Params

<ParamField type="boolean">
  Include `logs=true` to get historical status logs for each service.
</ParamField>

<CodeGroup title="Request">
  ```bash cURL theme={null}
  curl -X GET "https://status.worldcoin.org/api/services?logs=true"
  ```

  ```javascript theme={null}
  fetch('https://status.worldcoin.org/api/services?logs=true')
  ```
</CodeGroup>

### Response

<ResponseField name="services" type="array">
  Array of service status objects, each containing:
</ResponseField>

<ResponseField name="name" type="string">
  Service name (e.g., "Mini Apps", "World ID Verifications")
</ResponseField>

<ResponseField name="id" type="string">
  Service identifier
</ResponseField>

<ResponseField name="description" type="string">
  Description of the service
</ResponseField>

<ResponseField name="categoryId" type="string">
  Category the service belongs to (e.g., "mini-apps", "world-id", "finance")
</ResponseField>

<ResponseField name="status" type="string">
  Current service status: "ok", "warning", or "error"
</ResponseField>

<ResponseField name="logs" type="array">
  Historical status changes, containing:

  * `datetime`: Unix timestamp
  * `status`: Status at that time
  * `name`: Event name
  * `description`: Event description
  * `downtime`: Duration in seconds (if applicable)
</ResponseField>

<ResponseField name="uptimeRatio" type="object">
  Uptime percentages for different time periods:

  * `1`: Last 24 hours
  * `7`: Last 7 days
  * `30`: Last 30 days
  * `90`: Last 90 days
</ResponseField>

<CodeGroup title="Response">
  ```json theme={null}
  {
      "services": [
          {
              "name": "Crypto Transactions",
              "id": "crypto-transactions",
              "description": "",
              "categoryId": "mini-apps",
              "status": "ok",
              "logs": [
                  {
                      "datetime": 1739546233,
                      "status": "ok",
                      "name": "Running again",
                      "description": "Service outage"
                  }
              ],
              "uptimeRatio": {
                  "1": 99.7,
                  "7": 100,
                  "30": 100,
                  "90": 100
              }
          }
      ],
      "categories": [
          {
              "id": "mini-apps",
              "name": "Mini Apps",
              "status": "ok"
          }
      ],
      "uptimeRatio": {
          "1": 98,
          "7": 98.7,
          "30": 99.6,
          "90": 99.9
      },
      "status": "ok"
  }
  ```
</CodeGroup>


# Usernames
Source: https://docs.world.org/mini-apps/reference/usernames



## Introduction

Usernames are ENS-compatible identifiers for every World App user, ensuring consistency and easy recognition.
For example, when displaying transaction history, show the username instead of the wallet address to make it more user-friendly and private.

The usernames service is public, docs can be found [here](https://usernames.worldcoin.org/docs). This will be mostly useful for more advanced use cases.

## How to get it

To get the user's username you can either complete Wallet Auth and access the username/profile picture url from MiniKit directly:

```tsx theme={null}
const username = MiniKit.user.username
```

Or you can request it manually, using the `getUserByAddress` method on MiniKit:

```tsx theme={null}
const worldIdUser = await MiniKit.getUserByAddress(userAddress)
```

Other ways involve querying the [usernames service](https://usernames.worldcoin.org/docs).


# Add Money
Source: https://docs.world.org/mini-apps/sharing/add-money-qa



Add money to your World Wallet directly from exchanges like Binance and Coinbase. Deposit, withdraw, and swap tokens across multiple exchanges and chains effortlessly.

<div>
  <div>
    <h3>Parameters</h3>

    <ParamField type="string">
      Unique ID for the Add Money mini app.
    </ParamField>

    <ParamField type="string">
      URL-encoded path to the bridge interface (typically `%2Fbridge`).
    </ParamField>

    <ParamField type="string">
      Address of the recipient World Wallet user.
    </ParamField>

    <ParamField type="string">
      Token contract address to deposit (supports USDC or WLD).
    </ParamField>

    <ParamField type="string">
      USD amount to deposit. If omitted, the user selects the amount in-app.
    </ParamField>

    <ParamField type="string">
      App ID of the source app for quick navigation back.
    </ParamField>

    <ParamField type="string">
      Name of the source app displayed in the "Go Back" button.
    </ParamField>

    <ParamField type="string">
      Path within the source app to deeplink back to (URL-encoded).
    </ParamField>
  </div>

  <div>
    <img alt="Add Money Screen" />
  </div>
</div>

Url follows the schema below. Navigate there to use this Quick Action.

```
https://worldcoin.org/mini-app?app_id=app_e7d27c5ce2234e00558776f227f791ef
&path={%2Fbridge}
&toAddress={0xRecipientAddressHere}
&toToken={0xUSDCOrWLDAddress}
&amountUsd={100}
&sourceAppId={app_source1234567890abcdef}
&sourceAppName={My%20App}
&sourceDeeplinkPath={%2Fdashboard}
```


# DNA Send & Swap
Source: https://docs.world.org/mini-apps/sharing/dna-qa



Generate deep links to the DNA app for quick actions like Swap and Send.

[DNA](https://worldcoin.org/ecosystem/app_8e407cfbae7ae51c19b07faff837aeeb) now supports a **Quick Action** to deeplink directly
into the wallet interface, allowing users to perform specific actions like sending tokens or swapping assets with predefined parameters.

<div>
  <div>
    <h3>Parameters</h3>

    <ParamField type="string">
      Supports deep linking to the `swap` and `send` tabs.
    </ParamField>

    <ParamField type="string">
      The contract address of the token being sent (`fromToken`).
    </ParamField>

    <ParamField type="string">
      The contract address of the token being received (`toToken`). This is used
      in **swap** actions.
    </ParamField>

    <ParamField type="string">
      The recipient's wallet address or username for sending tokens.
    </ParamField>

    <ParamField type="string">
      The amount of the `fromToken` to be sent, specified in its **base unit** .
    </ParamField>

    <ParamField type="string">
      The application ID of the source app initiating the deeplink.
    </ParamField>

    <ParamField type="string">
      A deeplink path from the source application, which will be
      **URL-encoded**.
    </ParamField>
  </div>

  <Tabs>
    <Tab title="Send">
      <img alt="Send Screen" />
    </Tab>

    <Tab title="Swap">
      <img alt="Swap Screen" />
    </Tab>
  </Tabs>
</div>

## Helper Function

```tsx theme={null}
const DNA_APP_ID = "app_8e407cfbae7ae51c19b07faff837aeeb";

function getDNADeeplinkUrl({
  tab,
  fromToken,
  toToken,
  recipientAddress,
  amount,
  sourceAppId,
  sourceDeeplinkPath,
}: {
  tab: "swap" | "send";
  fromToken?: string;
  toToken?: string;
  recipientAddress?: string;
  amount?: string;
  sourceAppId?: string;
  sourceDeeplinkPath?: string;
}) {
  let path = `/wallet?tab=${tab}`;

  if (fromToken) {
    path += `&fromToken=${fromToken}`;
    if (amount) {
      path += `&amount=${amount}`;
    }
  }

  if (toToken) {
    path += `&toToken=${toToken}`;
  }

  if (recipientAddress) {
    path += `&recipientAddress=${recipientAddress}`;
  }

  if (sourceAppId) {
    path += `&sourceAppId=${sourceAppId}`;
  }

  if (sourceDeeplinkPath) {
    path += `&sourceDeeplinkPath=${encodeURIComponent(sourceDeeplinkPath)}`;
  }

  const encodedPath = encodeURIComponent(path);
  return `https://worldcoin.org/mini-app?app_id=${DNA_APP_ID}&path=${encodedPath}`;
}
```

## **Returns**

A string representing the complete deeplink URL to the DNA application with the specified parameters.

## **Example Usage**

```typescript theme={null}
const deeplinkUrl = getDNADeeplinkUrl({
  fromToken: "0x79A02482A880bCE3F13e09Da970dC34db4CD24d1",
  toToken: "0x4200000000000000000000000000000000000006",
  recipientAddress: "0xRecipientAddressHere",
  amount: "1235",
  sourceAppId: "app_a4f7f3e62c1de0b9490a5260cb390b56",
  sourceDeeplinkPath: "/path",
});
console.log(deeplinkUrl);
```

## **Generated Deeplink URL:**

```bash theme={null}
https://worldcoin.org/mini-app?app_id=app_8e407cfbae7ae51c19b07faff837aeeb&path=%2Fwallet%3Ftab%3Dsend%26fromToken%3D0x79A02482A880bCE3F13e09Da970dC34db4CD24d1%26amount%3D1234500%26toToken%3D0x4200000000000000000000000000000000000006%26recipientAddress%3D0xRecipientAddressHere%26sourceAppId%3Dapp_a4f7f3e62c1de0b9490a5260cb390b56%26sourceDeeplinkPath%3D%252Fsome%252Fpath
```

## **Note**

* Ensure that the **amount** is specified in the unit of the fromToken (e.g., wei for Ethereum-based tokens).
* The **sourceDeeplinkPath** is URL-encoded to ensure it is correctly interpreted when the deeplink is accessed.
* The **DNA\_APP\_ID** should be defined in your environment to match the application ID assigned to your DNA instance.
* If the tab is **Send**, it is necessary/recommended to provide **fromToken**, **amount**, and **the recipient's address or username** *(toToken is not required)*.
* If the tab is **Swap**, it is necessary/recommended to provide **fromToken**, **toToken**, and **amount** *(in base unit)*.

This function facilitates the creation of deeplink URLs that can be used to direct users seamlessly into specific actions within the DNA application, enhancing the user experience by pre-filling transaction details.


# Earn WLD Pool
Source: https://docs.world.org/mini-apps/sharing/earn-wld-qa



Earn high yields with your WLD token. Put your WLD to work by adding liquidity to the markets and earning large rewards from other traders.
Earn WLD now supports a Quick Action to deeplink directly to their staking screen.

<div>
  <div>
    <h3>Parameters</h3>

    <ParamField type="string">
      Unique ID for the Earn WLD mini app.
    </ParamField>
  </div>

  <div>
    <img alt="Liquidity Pool Screen" />
  </div>
</div>

Url follows the schema below. Navigate there to use this Quick Action.

```
http://worldcoin.org/mini-app?app_id=app_b0d01dd8f2bdfbff06c9e123de487eb8
```


# Holdstation Buy
Source: https://docs.world.org/mini-apps/sharing/holdstation-buy-qa



[Holdstation Wallet](https://worldcoin.org/ecosystem/app_0d4b759921490adc1f2bd569fda9b53a) is a simple, secure token wallet that allows you to buy, sell, swap, or send tokens.

<div>
  <div>
    <ParamField type="string">
      The token address the user wants to buy.
    </ParamField>

    <ParamField type="string">
      The token address the user will use to pay (payment token).
    </ParamField>

    <ParamField type="string">
      The dollar amount the user wants to buy.
    </ParamField>

    <ParamField type="string">
      The unique ID for the Holdstation mini app.
    </ParamField>

    <ParamField type="string">
      URL-encoded path to the buy token screen with parameters.
    </ParamField>
  </div>

  <div>
    <img alt="Buy WLD Screen" />
  </div>
</div>

## Helper function

```tsx theme={null}
const HOLDSTATION_APP_ID = "app_0d4b759921490adc1f2bd569fda9b53a";

function getHoldstationDeeplinkUrl({
  address,
  from,
  amount,
}: {
  address: string;
  from: string;
  amount: string;
}) {
  const path = `/token/buy?address=${address}&from=${from}&amount=${amount}`;
  const encodedPath = encodeURIComponent(path);
  return `https://worldcoin.org/mini-app?app_id=${HOLDSTATION_APP_ID}&path=${encodedPath}`;
}

// Buy $1 worth of WLD using USDC
console.log(
  getHoldstationDeeplinkUrl({
    address: "0x2cFc85d8E48F8EAB294be644d9E25C3030863003", // WLD token address
    from: "0x79A02482A880bCE3F13e09Da970dC34db4CD24d1", // USDC token address
    amount: "1",
  })
);
```

### Example output link : Buy \$1 worth of WLD using USDC

```
https://worldcoin.org/mini-app?app_id=app_0d4b759921490adc1f2bd569fda9b53a&path=%2Ftoken%2Fbuy%3Faddress%3D0x2cFc85d8E48F8EAB294be644d9E25C3030863003%26from%3D0x79A02482A880bCE3F13e09Da970dC34db4CD24d1%26amount%3D1
```


# PUF
Source: https://docs.world.org/mini-apps/sharing/puf-qa



Create & Trade coins on World Chain

PUF enables users to create and launch their own memecoins on World Chain, powered by Worldcoin's Proof of Personhood. This Quick Action provides direct links to token information or creation screens.

<div>
  <div>
    <h3>Parameters</h3>

    <ParamField type="string">
      The path to navigate to within PUF. Format: "app/token/(tokenAddress)"
      where tokenAddress is the contract address of a memecoin.
    </ParamField>
  </div>

  <div>
    <img alt="PUF Token Screen" />
  </div>
</div>

Url follows the schema below. Navigate there to use this Quick Action.

```
https://worldcoin.org/mini-app?app_id=app_15daccf5b7d4ec9b7dbba044a8fdeab5&path=app/token/0x57268aFa4E496684611aAFB1E20D2116283C487e
```


# Quick Actions (Linking to your Mini App)
Source: https://docs.world.org/mini-apps/sharing/quick-actions



### **What Are Quick Actions?**

A Quick Action is a universal deeplink defined by a schema that navigates to a specific path inside your app. It's meant to be used between mini apps, enabling one app (App A) to use a feature or action of another app (App B) seamlessly.
In short, you should create a quick action to link to another mini app.

<Note>
  If a user clicks on your link and has World App installed, it will automatically open the mini app inside of World
  App to the specified path. Otherwise, it will direct them to the app store and prompt them to install World App.
</Note>

### **Benefits of Quick Actions**

1. **Leverage Expertise**: Use other mini apps already working specific features.
2. **Resource & Time Optimization**: Focus on your apps core functionalities while outsourcing supplementary features.
3. **Community Growth**: Integrating another apps functionality opens opportunities for co-marketing.

### **How to Make a Quick Action**

1. **Create a Universal Link Schema**: Define a schema with a custom path that aligns with the functionality you want to provide.

2. **Publish it in our docs for all devs to use**: Fill this [form](https://forms.gle/UBcKMrnxtyxqX4dq6) for our team to test and publish your quick action on this page.

Urls will follow the schema below.

```
https://world.org/mini-app?app_id={app_id}&path={path}
```

### Parameters

<ParamField type="string">
  The `app_id` corresponding to your mini app.
</ParamField>

<ParamField type="string">
  Should be the url encoded path where you want to link to inside of your mini app
</ParamField>


# Sage Support
Source: https://docs.world.org/mini-apps/sharing/sage-qa



[Sage](https://worldcoin.org/ecosystem/app_5dee2f19cd6eef599eb6ab275a0a7523) is an AI chatbot that lets users ask questions and get answers.

Sage Support enables developers to integrate Sage chats seamlessly into their World Mini Apps. Developers get a white label version of Sage that acts as a support assistant for their Mini App using the context they give it.

## Key Features

* **Seamless Integration**: Easily embed Sage chats within any World Mini App.
* **Custom Context Parameters**: Tailor Sage's responses based on Mini App specific data.
* **Logs and Analytics**: Track and understand what types of questions your users are asking.

<div>
  <img alt="Sage Developer Dashboard Analytics" />

  <img alt="Sage Developer Dashboard Settings" />
</div>

***

## Getting Started

### 1. Create a Sage Developer project

Go to the [Sage Developer dashboard](https://dev-dashboard-gamma.vercel.app) and sign in. Create a new project.

### 2. Customizing Sage to fit your app

With a project created, head over to the project's settings, this page is accessible by going into: **Apps > Your App > Settings**. (Navigation is available through the menu bar on the top right or the top left breadcrumbs)

In this page you can find parameters to fine tune Sage to best interact with your users in the context of your app, a comprehensive description of these parameters is present [below](#app-settings).

### 3. Integrating Sage Support in your app

The final step to integrating Sage Support into your React application is to install and make use of the `SageSupport` component.

Add the npm package with the command:

```bash theme={null}
npm install sage-support
```

Once the dependency installed, the simplest way to integrate Sage Support is:

```tsx theme={null}
import { SageSupport } from "sage-support";

<SageSupport projectId={YOUR_APP_ID} />;
```

Where `YOUR_APP_ID` is the App ID (number) you can find in the [Sage Developer Dashboard](https://dev-dashboard-gamma.vercel.app) (top right).

More configuration options for the component are available [below](#sage-support-component).

### 4. Sage Support Link

Generate your app's Support Link using the [Support Link wizard](#support-link-generator) and use it as the Support URL under **Worldcoin Developer > Mini App > Configuration > App Store > Support > Link**.

### Analytics

Once you've started using Sage Support in your Mini App, analytics are also available in the [Sage Developer Dashboard](https://dev-dashboard-gamma.vercel.app), allowing you to identify the usage of Sage Support in your app and understand how users are using it. You can find more information about analytics [below](#app-analytics).

<Note>
  This is all you need to get Sage Support working. If you wish to customize it
  further, or better understand the various parameters continue reading below.
</Note>

***

## App Settings

Located at **Apps > Your App > Settings**, the Settings page allows you to fine tune the Sage Support assistant to meet the needs and context of your Mini App.

### `App Name`

This name only lives in the [Sage Developer dashboard](https://dev-dashboard-gamma.vercel.app) universe and serves the purpose of differentiating between multiple Sage Support integrations, it's recommended that this field is set accordingly.

### `App ID`

Uniquely identifies your Sage Developer App and is used to link your `SageSupport` component to the [Sage Developer dashboard](https://dev-dashboard-gamma.vercel.app). This field is automatically generated and cannot be changed.

### `Introduction Message`

Defines the first message to be sent by the Sage assistant once a new chat is created/open by a user. This field is also capable of encompassing a custom variable (`%USER%`) which Sage will replace by the user's username.

### `App Description`

Provide a solid description about your app and what it focuses on, this field is processed by Sage as an additional context parameter, and is useful to keep the assistant behavior and subject within the landscape of your Mini App.

***

## App Analytics

Located at **Apps > Your App > Analytics**, the Analytics page allows you to view statistics and analytic data about the usage of Sage Support within your Mini App.

### `Messages`

See how many messages were sent to Sage Support chats from your Mini App in each of the last 7 days.

### `Users`

See how many users interacted with Sage Support chats from your Mini App in each of the last 7 days.

### `Keywords`

Currently not available.

### `Next Step`

Currently not available.

### `Logs`

See how users chat with Sage Support inside your app, this data is shown anonymously and provides the developer with a more in-depth tool to explore the interactions between users and Sage Support.

***

## `SageSupport` Component

### Installation

To use the Sage Support React component you must first install it using npm (or your package manager of choice).

```bash theme={null}
npm install sage-support
```

### Basic Usage

From the get go you can use Sage Support by using the basic implementation, the only mandatory parameter to be passed to the component is the `projectId`. This ID (App ID) is retrieve from the Settings page in the [Sage Developer dashboard](https://dev-dashboard-gamma.vercel.app).

```tsx theme={null}
import { SageSupport } from "sage-support";

<SageSupport projectId={YOUR_APP_ID} />;
```

### Props & Personalisation

Other props allow you to customize both the aesthetic and behavior of the Sage Support Chat.

<ParamField type="number">
  Links your component to your Sage Developer project, used for analytics and
  behavior.
</ParamField>

<ParamField type="string">
  Allows you to make use of the return button on the top left of the Sage
  Support chat window. The value to be passed to this prop is a [quick action
  URL](https://docs.world.org/mini-apps/sharing/quick-actions).
</ParamField>

<ParamField type="string">
  Allows you to pass custom CSS classes to affect the fallback default button.
</ParamField>

<ParamField type="React.ReactNode">
  Allows you to pass a custom React element to replace the default button.
</ParamField>

***

## Support Link

You can also integrate Sage Support directly into your World Mini App by using a Support Link. This allows your users to access Sage's AI-powered support without requiring you to install any additional packages or components.

The Support Link is a quick action URL that opens the Sage Support chat interface directly within the World App. When users click on this link, they'll be able to ask questions and get support related to your Mini App.

This link is particularly useful for developers to use Sage as their Mini App's native Support link, available under **Worldcoin Developer > Mini App > Configuration > App Store > Support > Link**

### Base URL & Parameters

The base URL to access a support chat is:

`https://worldcoin.org/mini-app?app_id=app_5dee2f19cd6eef599eb6ab275a0a7523&path=/support-chat`

This support link, akin to the [`SageSupport` component](#sage-support-component), accepts and requires some parameters to be passed, in this case URL Query Parameters, for the Support Chat to work like expected.

<ParamField type="number">
  Links your Support Link to your Sage Developer project, used for analytics and behavior.
</ParamField>

<ParamField type="string">
  Allows you to make use of the return button on the top left of the Sage Support chat window by passing a Mini App quick atcion URI/URL. Due to some encoding functionalities and implementation caveats, the value to be passed to this parameter has to be formatted accordingly beforehand:

  1. The URL must be submitted to a [UTF-8 encoding](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent).

  2. All ampersand characters (such as the one in `&path`) have to be replaced with the sequence `(amps)`.

  To make this process easier, you can make use of the generator below or inside the [Sage Developer Dashboard](https://dev-dashboard-gamma.vercel.app). Any URIs outside of the `worldcoin.org/mini-app` space are not allowed.
</ParamField>

### Support Link Generator

<Note>
  The Support Link Generator component would be inserted here in the actual
  implementation.
</Note>


# Swap
Source: https://docs.world.org/mini-apps/sharing/swap-qa



Use this Quick Action to deep link into the Swap interface with prefilled parameters.

<div>
  <div>
    <h3>Parameters</h3>

    <ParamField type="string">
      Target app id for the Swap quick action:
      <code>app\_6c5c5717c77abe83be8814c032c3a6f9</code>.
    </ParamField>

    <ParamField type="string">
      Path inside the target app. Use <code>'/'</code> for Swap.
    </ParamField>

    <ParamField type="string | 0x${string}">
      Token address for the "from" token.
    </ParamField>

    <ParamField type="string | 0x${string}">
      Token address for the "to" token.
    </ParamField>

    <ParamField type="string">
      Amount of the from token in base token units.
    </ParamField>

    <ParamField type="string">
      app\_id of the app that uses this quick action.
    </ParamField>

    <ParamField type="string">
      Name of the app that uses this quick action.
    </ParamField>
  </div>

  <div>
    <img alt="Swap Screen" />
  </div>
</div>

### Helper function

```ts theme={null}
export interface ActionLinkProps {
  targetAppId: string; // app_6c5c5717c77abe83be8814c032c3a6f9 for Swap quick action
  path: string; // '/' for Swap quick action
  params: Record<string, string>;
}

const MAIN_ACTION_URL = "https://worldcoin.org/mini-app";

export function getActionLink({ targetAppId, path, params }: ActionLinkProps) {
  let fullPath = path;

  if (Object.keys(params).length > 0) {
    const paramParts = Object.entries(params).map(([key, value]) => {
      return `${key}=${value}`;
    });
    fullPath += `?${paramParts.join("&")}`;
  }

  const queryString = `${MAIN_ACTION_URL}?app_id=${targetAppId}&path=${encodeURIComponent(fullPath)}`;

  return queryString;
}

// Example usage
const link = getActionLink({
  targetAppId: "app_6c5c5717c77abe83be8814c032c3a6f9",
  path: "/",
  params: {
    fromToken: "0x2cFc85d8E48F8EAB294be644d9E25C3030863003",
    toToken: "0x4200000000000000000000000000000000000006",
    amount: "1234500",
    sourceAppId: "app_source1234567890abcdef",
    sourceAppName: "My%20App",
  },
});
console.log(link);
```

### Example link

```
https://worldcoin.org/mini-app?app_id=app_6c5c5717c77abe83be8814c032c3a6f9&path=%2F%3FfromToken%3D0x2cFc85d8E48F8EAB294be644d9E25C3030863003
```


# UNO Swap
Source: https://docs.world.org/mini-apps/sharing/uno-qa



[UNO](https://worldcoin.org/ecosystem/app_a4f7f3e62c1de0b9490a5260cb390b56) is your simple, secure token wallet.
View your token balances and check prices all in one place. Buy, Sell, Swap, or Send tokens in a fun and simple interface.

Uno now supports a Quick Action to deeplink directly to the swap tab, with a specific swap ready to be executed.

<div>
  <div>
    <h3>Parameters</h3>

    <ParamField type="string">
      Currently only supports "swap"; this allows deep linking to the swap tab.
    </ParamField>

    <ParamField type="string">
      Token address for the from token.
    </ParamField>

    <ParamField type="string">
      Base units amount of the from token.
    </ParamField>

    <ParamField type="string">
      Token address for the to token.
    </ParamField>

    <ParamField type="string">
      World Miniapp App id of the referring World Miniapp. When provided, a "Go
      Back" deeplink button will appear in the top left of the header that takes
      the user back to the referring Miniapp.
    </ParamField>

    <ParamField type="string">
      Deeplink path for referring World Miniapp Quick Actions. When provided,
      this path will be added to the "Go Back" deeplink button so that the
      referring Miniapp can execute a Quick Action when the user taps "Go Back"
      in Uno.
    </ParamField>
  </div>

  <div>
    <img alt="Swap Screen" />
  </div>
</div>

## Helper function

```tsx theme={null}
const UNO_APP_ID = "app_a4f7f3e62c1de0b9490a5260cb390b56";

function getUnoDeeplinkUrl({
  fromToken,
  toToken,
  amount,
  referrerAppId,
  referrerDeeplinkPath,
}: {
  fromToken?: string;
  toToken?: string;
  amount?: string;
  referrerAppId?: string;
  referrerDeeplinkPath?: string;
}) {
  let path = `?tab=swap`;
  if (fromToken) {
    path += `&fromToken=${fromToken}`;
    if (amount) {
      path += `&amount=${amount}`;
    }
  }
  if (toToken) {
    path += `&toToken=${toToken}`;
  }
  if (referrerAppId) {
    path += `&referrerAppId=${referrerAppId}`;
  }
  if (referrerDeeplinkPath) {
    path += `&referrerDeeplinkPath=${encodeURIComponent(referrerDeeplinkPath)}`;
  }
  const encodedPath = encodeURIComponent(path);
  return `https://worldcoin.org/mini-app?app_id=${UNO_APP_ID}&path=${encodedPath}`;
}

// create a trade for 1.2345 USDC to WETH
console.log(
  getUnoDeeplinkUrl({
    fromToken: "0x79A02482A880bCE3F13e09Da970dC34db4CD24d1",
    amount: "1234500",
    toToken: "0x4200000000000000000000000000000000000006",
  })
);
```

### Example output link

```
https://worldcoin.org/mini-app?app_id=app_a4f7f3e62c1de0b9490a5260cb390b56&path=%3Ftab%3Dswap%26fromToken%3D0x79A02482A880bCE3F13e09Da970dC34db4CD24d1%26amount%3D1234500%26toToken%3D0x4200000000000000000000000000000000000006
```

### Appendix

**Terminology**

* **fromToken** - token that is being swapped away for another token. Other names for this parameter are "sell token", or "input token".
* **toToken** - token that is being swapped into for another token. Other names for this parameter are "buy token", or "output token".
* **referrer** - In the cases that the UNO Quick Action link is used from a different Miniapp, the referrer is the Miniapp where that link was used.
  Specifying the referrerAppId allows UNO to provide a "Go back" to the Miniapp that provided the link to the UNO Quick Action.

**Caveats/Warnings** Swap will not work if not taken into consideration.

* If the user does not have the fromToken (sell token).
* Amount should be in the base units of the fromToken.


# World Chat
Source: https://docs.world.org/mini-apps/sharing/world-chat-qa



World Chat is a messaging platform in the World App ecosystem.
Quick Actions let you link to specific chat features.

Url follows the schema below.

```
https://worldcoin.org/mini-app?app_id=app_e293fcd0565f45ca296aa317212d8741
```

<div>
  <div>
    <h3>Parameters</h3>

    <ParamField type="string">
      The username of the recipient you want to chat with. You can resolve a
      username using the user's [wallet
      address](/mini-apps/reference/address-book).
    </ParamField>

    <ParamField type="string">
      Predefined message text to include in the draft chat.
    </ParamField>

    <ParamField type="string">
      When included, opens a draft chat with the send payment option
      pre-selected. You can optionally specify an amount by using `pay=amount`
      where amount is the numeric value in USDC.
    </ParamField>

    <ParamField type="string">
      When included, opens a draft chat with the payment request option
      pre-selected. You can optionally specify an amount by using
      `request=amount` where amount is the numeric value in USDC.
    </ParamField>
  </div>

  <div>
    <img alt="World Chat Screen" />
  </div>
</div>

## Helper function

```tsx theme={null}
const WORLD_CHAT_APP_ID = "app_e293fcd0565f45ca296aa317212d8741";

function getWorldChatDeeplinkUrl({
  username,
  message,
  pay,
  request,
}: {
  username: string;
  message?: string;
  pay?: string | number;
  request?: string | number;
}) {
  let path = `/${username}/draft`;

  if (message) {
    path += `?message=${message}`;
  } else if (pay !== undefined) {
    if (pay === "true" || pay === true) {
      path += `?pay`;
    } else {
      path += `?pay=${pay}`; // Pay with amount
    }
  } else if (request !== undefined) {
    if (request === "true" || request === true) {
      path += `?request`;
    } else {
      path += `?request=${request}`; // Request with amount
    }
  }

  const encodedPath = encodeURIComponent(path);
  return `https://worldcoin.org/mini-app?app_id=${WORLD_CHAT_APP_ID}&path=${encodedPath}`;
}

// Create a chat with predefined message
console.log(
  getWorldChatDeeplinkUrl({
    username: "johndoe",
    message: "Hello from my mini app!",
  })
);

// Create a chat with send payment option
console.log(
  getWorldChatDeeplinkUrl({
    username: "johndoe",
    pay: "true",
  })
);

// Create a chat with send payment option and amount
console.log(
  getWorldChatDeeplinkUrl({
    username: "johndoe",
    pay: 5.25,
  })
);

// Create a chat with payment request option
console.log(
  getWorldChatDeeplinkUrl({
    username: "johndoe",
    request: "true",
  })
);

// Create a chat with payment request option and amount
console.log(
  getWorldChatDeeplinkUrl({
    username: "johndoe",
    request: 10,
  })
);
```

### Example output links

```
// Message draft
https://worldcoin.org/mini-app?app_id=app_e293fcd0565f45ca296aa317212d8741&path=%2Fjohndoe%2Fdraft%3Fmessage%3DHello

// Payment draft with amount
https://worldcoin.org/mini-app?app_id=app_e293fcd0565f45ca296aa317212d8741&path=%2Fjohndoe%2Fdraft%3Fpay%3D5.25

// Request draft with amount
https://worldcoin.org/mini-app?app_id=app_e293fcd0565f45ca296aa317212d8741&path=%2Fjohndoe%2Fdraft%3Frequest%3D10
```

### Appendix

**Caveats/Warnings**

* The username must be a valid World ID username.
* Only one quick action type (message, pay, or request) can be used at a time.
* If the recipient does not exist, the app will show an appropriate error message.
* Only USDC & WLD are supported for payments.
* Currency amounts should be specified as decimal numbers (e.g., 5.25 for 5.25 USDC).


# Deploy Smart Contracts
Source: https://docs.world.org/world-chain/developers/deploy

Deploy a HelloWorldChain smart contract to World Chain Sepolia using Foundry: setup, build, test, fund, and create.

In this tutorial, we will use the [Solidity programming language](https://docs.soliditylang.org/en/v0.8.28/) to write the `HelloWorldChain` smart contract for World Chain.
Solidity is a programming language that can compile to EVM (Ethereum Virtual Machine) bytecode which can be executed on the World Chain EVM.
We will also be using the [Foundry CLI](https://book.getfoundry.sh/) toolkit, which has a lot of tools to help build, test and interact with Solidity programs.

## Download development tools

First, we need to install the Foundry CLI toolkit and the Solidity compiler. Solidity comes with a compiler called `solc` which we will use to compile the `HelloWorldChain` contract. The Foundry CLI
will automatically download the right version of the Solidity compiler for you during the compilation process using `forge build`.

<CodeGroup>
  `bash Install Foundry curl -L https://foundry.paradigm.xyz | bash `
</CodeGroup>

## Create a Foundry project

Open your terminal of choice, navigate to a directory where you want to create your project, and run the following command to create a new Foundry project:

<CodeGroup>
  ````bash Create a new Foundry project forge init hello-world-chain && cd theme={null}
  hello-world-chain ```
  </CodeGroup>

  Now that you have created a new Foundry project, you can start writing your smart contract. All smart contracts in Foundry projects are stored in the `src` directory.
  If you are using VSCode, it should look something like this:

  ![Foundry 1](/images/docs/world-chain/foundry-1.png)

  ## Write the HelloWorldChain contract

  First, delete the template file called Counter.sol in the /src directory:

  <CodeGroup>```bash Delete Template rm src/Counter.sol ```</CodeGroup>

  Next, create a new file called HelloWorldChain.sol in the /src directory and add the following code to it:

  <CodeGroup>
  ```solidity HelloWorldChain.sol
  // SPDX-License-Identifier: MIT
  pragma solidity ^0.8.28;

  contract HelloWorldChain {
  string private word;

    // Constructor that sets the initial word to "Hello World Chain!"
    constructor() {
        word = "Hello World Chain!";
    }

    // Setter function to update the word
    function setWord(string memory newWord) public {
        word = newWord;
    }

    // Getter function to return the current word
    function getWord() public view returns (string memory) {
        return word;
    }

  }

  ````
</CodeGroup>

This contract has a `word` variable that stores a string and two functions: `setWord` to update the word and `getWord` to return the current word.

## Update Scripts and Tests

Since we deleted `Counter.sol`, we need to update or remove the scripts and tests that reference it to prevent compilation errors.

**Delete the `script` directory**

The script directory contains scripts that import `Counter.sol`. Since we no longer have `Counter.sol`, we can delete the entire script directory to avoid any compilation issues:

<CodeGroup>
  ```bash Delete Script Directory theme={null}
  rm -rf script
  ```
</CodeGroup>

**Replace** `Counter.t.sol` with `HelloWorldChain.t.sol`

In the test directory, delete the existing `Counter.t.sol` and create a new test file called `HelloWorldChain.t.sol` and add the following simple tests:

<CodeGroup>
  ```solidity HelloWorldChain.t.sol theme={null}
  // SPDX-License-Identifier: MIT
  pragma solidity ^0.8.28;

  import "forge-std/Test.sol";
  import "../src/HelloWorldChain.sol";

  contract HelloWorldChainTest is Test {
  HelloWorldChain helloWorldChain;

      function setUp() public {
          helloWorldChain = new HelloWorldChain();
      }

      function testInitialWord() public view {
          string memory expected = "Hello World Chain!";
          string memory actual = helloWorldChain.getWord();
          assertEq(actual, expected);
      }

      function testSetWord() public {
          string memory newWord = "Hello Foundry!";
          helloWorldChain.setWord(newWord);
          string memory actual = helloWorldChain.getWord();
          assertEq(actual, newWord);
      }

  }

  ```
</CodeGroup>

**Now You can Run tests:**

<CodeGroup>
  ```bash Test the contract theme={null}
  forge test
  ```
</CodeGroup>

## Compile the contract

To compile the `HelloWorldChain` contract, run the following command:

<CodeGroup>`bash Compile the contract forge build `</CodeGroup>

The `forge build` command will compile the contract using the Solidity compiler and generate the necessary artifacts in the `artifacts` directory.

## Generate a wallet

To deploy the `HelloWorldChain` contract to World Chain Sepolia, you will need a wallet with some World Chain Sepolia ETH. An easy way to generate a
wallet using the Foundry CLI is to run the following command:

<CodeGroup>`bash Generate a wallet cast wallet new `</CodeGroup>

`cast` is a versatile set of utility functions and commands for Solidity development. In this case, we are using one of its many built-in features to generate a wallet with one account.

<Note>
  Never share your private key with anyone and always make sure that you don't
  upload them to code versioning tools like Git and hosting platforms like
  GitHub. Research best practices for private key management in order to avoid
  loss of funds.
</Note>

The output of the command will look something like this:

````
Successfully created new keypair.
Address:     0xB815A0c4bC23930119324d4359dB65e27A846A2d
Private key: 0xcc1b30a6af68ea9a9917f1dda20c927704c5cdb2bbe0076901a8a0e40bf997c5
```

## Fund your wallet

Now that you have a wallet, you need to fund it with some World Chain Sepolia ETH. You can get some World Chain Sepolia ETH from the [World Chain Sepolia faucet](https://www.alchemy.com/faucets/world-chain-sepolia) operated by Alchemy.
In the form on the faucet page, enter the address of your wallet which you generated above and click the "Send me ETH" button. If you have any issues please send us a message in the developer
group chat on [Telegram](https://t.me/worldcoindevelopers) or [Discord](https://world.org/discord).

## Deploy the contract

Now that you have a wallet and you funded it with World Chain Sepolia ETH, you can deploy the `HelloWorldChain` contract to World Chain Sepolia using the following `forge create` command:

<CodeGroup>
  ```bash Deploy the contract forge create
  src/HelloWorldChain.sol:HelloWorldChain --rpc-url
  https://worldchain-sepolia.g.alchemy.com/public --private-key
  0xcc1b30a6af68ea9a9917f1dda20c927704c5cdb2bbe0076901a8a0e40bf997c5 ```
</CodeGroup>

Here, we are using the `<path>:<contractname>` format to specify the contract. This tells Foundry where to find the contract file (src/HelloWorldChain.sol) and which contract within the file (HelloWorldChain) to deploy.
We also use the `--rpc-url` flag to specify the RPC URL of the World Chain Sepolia network and the `--private-key` flag to specify the private key of the wallet we generated earlier.
On top of this we can also provide other flags like `-vvvvv` to get more verbose output from the deployment process, `--verify` to verify the contract on [Worldscan](https://worldscan.org) or [Blockscout](https://worldchain-sepolia.explorer.alchemy.com/) (alongside with an `--etherscan-api-key` flag) and
several other flags to toggle different features that you can find more about in the [Foundry documentation](https://book.getfoundry.sh/).

And that's it! You have successfully deployed a smart contract to World Chain Sepolia. You can interact with the contract using `forge script` scripts, using a block explorer or any other EVM library like [ethers.js](https://docs.ethers.io/v5/), [alloy-rs](https://github.com/alloy-rs/alloy/), and many others.
````


# EVM Equivalence
Source: https://docs.world.org/world-chain/developers/evm-equivalence

How World Chain achieves EVM equivalence via OP Stack, plus key parameter differences vs OP Mainnet and Ethereum.

World Chain is EVM-equivalent because it utilizes the [OP Stack](https://docs.optimism.io/stack/getting-started), a modular framework developed by Optimism,
which ensures compatibility with the [Ethereum Virtual Machine (EVM)](https://ethereum.org/en/developers/docs/evm/). By leveraging the OP Stack,
World Chain can execute smart contracts and interact with decentralized applications designed for Ethereum
without any modifications. This equivalency enables seamless interoperability with Ethereum's ecosystem of applications and protocols.
The OP Stack's modularity also allows World Chain to implement scaling solutions and other customizations while maintaining the fundamental EVM equivalence,
ensuring a flexible yet consistent environment for developers and users alike.

## Differences between World Chain, OP Mainnet and Ethereum

Though the EVM remains unchanged across OP Stack (Superchain) chains compared to the Ethereum layer 1, there are some configurations of the execution clients that
do differ.

<table>
  <thead>
    <tr>
      <th>Parameter</th>
      <th>World Chain</th>
      <th>OP Mainnet</th>
      <th>Ethereum</th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>Block time in seconds</td>
      <td>2</td>
      <td>2</td>
      <td>12</td>
    </tr>

    <tr>
      <td>Block gas limit</td>
      <td>30,000,000</td>
      <td>30,000,000</td>
      <td>30,000,000</td>
    </tr>

    <tr>
      <td>Block gas target</td>
      <td>10,000,000</td>
      <td>5,000,000</td>
      <td>15,000,000</td>
    </tr>

    <tr>
      <td>EIP-1559 elasticity multiplier</td>
      <td>6</td>
      <td>6</td>
      <td>2</td>
    </tr>

    <tr>
      <td>EIP-1559 denominator</td>
      <td>250</td>
      <td>250</td>
      <td>8</td>
    </tr>

    <tr>
      <td>
        Maximum base fee increase (per block)
      </td>

      <td>0.8%</td>
      <td>2%</td>
      <td>12.5%</td>
    </tr>

    <tr>
      <td>
        Maximum base fee decrease (per block)
      </td>

      <td>0.4%</td>
      <td>0.4%</td>
      <td>12.5%</td>
    </tr>
  </tbody>
</table>

For more information check out the [OP Stack docs](https://docs.optimism.io/stack/getting-started).


# Transaction Fees
Source: https://docs.world.org/world-chain/developers/fees

Understand World Chain fees: L2 execution vs L1 security costs, variability, and ways to optimize gas.

Every World Chain transaction consists of two costs: an L2 (execution) fee and an L1 (security) fee. The L2 fee is the cost to execute your transaction on the L2, while the L1 fee covers the estimated cost of publishing the transaction on the L1. Typically, the L1 security fee is higher than the L2 execution fee.

The L1 fee fluctuates depending on the volume of transactions on the L1. If your transaction timing is flexible, you can save on costs by submitting during periods of lower gas fees on the L1 (for example, weekends) or using products like [GasHawk](https://gashawk.io/) which schedule transactions during periods of low demand.

Similarly, the L2 fee can vary based on the number of transactions submitted to the L2. This dynamic adjustment works similarly to the L1; you can learn more about it [here](https://blog.thirdweb.com/eip-1559-ethereum-gas-fees/).

For additional details about fee calculation on World Chain, please refer to the relevant [op-stack developer documentation](https://docs.optimism.io/stack/transactions/fees).


# Grants Program
Source: https://docs.world.org/world-chain/developers/grants

Apply for Worldcoin Foundation grants: areas of interest, continuous grants program, and how to submit.

The [Worldcoin Foundation](https://worldcoin.foundation) runs the [Human Collective Grants](https://world.org/community-grants) program
which gives grants to builders that help accelerate the [Worldcoin Tech Tree](https://world.org/tech-tree) and [related RFPs](https://world.org/rfp).
The grants program switched from a quarterly waves format to a continuous format where builders can apply for a grant at any point in time. For more information
you can read the [Continuous Grants program announcement blogpost](https://world.org/blog/announcements/worldcoin-foundation-introduces-new-continuous-grants-program-spur-innovation).

## Areas of interest for applications

* Rustification of the [OP Stack](https://docs.optimism.io/stack/getting-started)
* Futhering [the gigagas roadmap](https://www.google.com/url?q=https://www.paradigm.xyz/2024/04/reth-perf\&sa=D\&source=editors\&ust=1726507097184499\&usg=AOvVaw34fUyrLcoigheJlrfbIDM2)
* ZK-ifying the OP Stack (efforts like [OP Succinct](https://blog.succinct.xyz/op-succinct/), [Zeth from Risc0](https://risczero.com/blog/zeth-release) and [Mina's ZK fault proof RFP]())
* Scalability research and engineering (can be Ethereum core as well)
* Embedding priority blockspace for humans into the OP Stack derivation pipeline + fault proof program (open R\&D)
* Separate eip1559 fee market for humans on OP Stack
* L2 Execution client development (especially [reth](https://github.com/paradigmxyz/reth)) and benchmarking
* Improving UX and interoperability
* Chain-level experiments with digital identity and the OP Stack (things like [human priority blockspace](/world-chain/quick-start/features#priority-blockspace-for-humans) and [free gas allowances](/world-chain/quick-start/features#gas-allowance-for-humans) for unique humans)
* Interesting applications on World Chain (past examples include proof aggregators like [Nebra](https://nebra.one/), storage proofs like [Herodotus](https://herodotus.dev/) and [Axiom](https://www.axiom.xyz/), Passkeys module for Safe, and others)
* and more...

### If you are interested [apply here](https://airtable.com/appftNMpv819abvTc/pag0uKCtjQAPJgaEB/form) or send us an email to [grants@worldcoin.org](mailto:grants@worldcoin.org)!


# Deploy a World ID Template App
Source: https://docs.world.org/world-chain/developers/template

Deploy the World ID on-chain template to a World Chain Sepolia fork with Foundry; configure env, contracts, and local web.

In this tutorial we are going to deploy a [World ID template app](https://github.com/worldcoin/world-id-onchain-template) on a World Chain Sepolia local fork using anvil.
This app will be a simple web application that allows users to create a World ID proof of personhood and verify it.
The app will be deployed on World Chain Sepolia and will interact with the `WorldIDRouter` smart contract
to verify the ZK proofs of personhood.

## Prerequisites

Before we start, make sure you have the following tools installed:

* [Git](https://git-scm.com/) (usually pre-installed on most systems)
* [Node.js](https://nodejs.org/en/)
* [pnpm](https://yarnpkg.com/) (or equivalent like npm, yarn or bun)
* [Foundry CLI](https://book.getfoundry.sh/)

## Clone template

First, clone the World ID template app repository from GitHub:

```bash theme={null}
git clone https://github.com/worldcoin/world-id-onchain-template.git && cd world-id-onchain-template
```

## Install dependencies

Next, install the dependencies for the World ID template app:

```bash theme={null}
pnpm install
```

## Build the smart contracts

Next we are going to compile the smart contracts for the World ID template app:

```bash theme={null}
cd contracts && forge build
```

## Understanding World ID

Before we deploy the World ID template app, let's take a look at the smart contracts that are part of the app:

<CodeGroup>
  ```solidity contracts/src/Contract.sol theme={null}
  // SPDX-License-Identifier: MIT
  pragma solidity ^0.8.13;

  import { ByteHasher } from "./helpers/ByteHasher.sol";
  import { IWorldID } from "./interfaces/IWorldID.sol";

  contract Contract {
  using ByteHasher for bytes;

      ///////////////////////////////////////////////////////////////////////////////
      ///                                  ERRORS                                ///
      //////////////////////////////////////////////////////////////////////////////

      /// @notice Thrown when attempting to reuse a nullifier
      error DuplicateNullifier(uint256 nullifierHash);

      /// @dev The World ID instance that will be used for verifying proofs
      IWorldID internal immutable worldId;

      /// @dev The contract's external nullifier hash
      uint256 internal immutable externalNullifier;

      /// @dev The World ID group ID (always 1)
      uint256 internal immutable groupId = 1;

      /// @dev Whether a nullifier hash has been used already. Used to guarantee an action is only performed once by a single person
      mapping(uint256 => bool) internal nullifierHashes;

      /// @param nullifierHash The nullifier hash for the verified proof
      /// @dev A placeholder event that is emitted when a user successfully verifies with World ID
      event Verified(uint256 nullifierHash);

      /// @param _worldId The WorldID router that will verify the proofs
      /// @param _appId The World ID app ID
      /// @param _actionId The World ID action ID
      constructor(IWorldID _worldId, string memory _appId, string memory _actionId) {
      	worldId = _worldId;
      	externalNullifier = abi.encodePacked(abi.encodePacked(_appId).hashToField(), _actionId).hashToField();
      }

      /// @param signal An arbitrary input from the user, usually the user's wallet address (check README for further details)
      /// @param root The root of the Merkle tree (returned by the JS widget).
      /// @param nullifierHash The nullifier hash for this proof, preventing double signaling (returned by the JS widget).
      /// @param proof The zero-knowledge proof that demonstrates the claimer is registered with World ID (returned by the JS widget).
      /// @dev Feel free to rename this method however you want! We've used `claim`, `verify` or `execute` in the past.
      function verifyAndExecute(address signal, uint256 root, uint256 nullifierHash, uint256[8] calldata proof) public {
      	// First, we make sure this person hasn't done this before
      	if (nullifierHashes[nullifierHash]) revert DuplicateNullifier(nullifierHash);

      	// We now verify the provided proof is valid and the user is verified by World ID
      	worldId.verifyProof(
      		root,
      		groupId,
      		abi.encodePacked(signal).hashToField(),
      		nullifierHash,
      		externalNullifier,
      		proof
      	);

      	// We now record that the user has done this, so they can't do it again (proof of uniqueness)
      	nullifierHashes[nullifierHash] = true;

      	// Finally, execute your logic here, for example issue a token, NFT, etc...
      	// Make sure to emit some kind of event afterwards!

      	emit Verified(nullifierHash);
      }

  }

  ```
</CodeGroup>

This contract has all the necessary pieces that any app that wants to integrate World ID proofs of personhood will require.
The World ID docs have a [detailed explanation](https://docs.worldcoin.org/world-id) of how the World ID system works and how to integrate it into your app.
But we will go over the main parts of the contract here:

1. The `Contract` contract is the main contract that will be deployed to World Chain Sepolia. It has a constructor that
   takes the `IWorldID` interface, the app ID and the action ID as parameters. The `IWorldID` interface is the World ID router
   that will verify the proofs, the app ID is the ID of the app can be created by the developer using the
   [World ID Developer Portal](https://developer.worldcoin.org/login) and that the action ID is the ID of the action that the user
   is performing which will be generated automatically by the [IDKit SDK](https://docs.worldcoin.org/reference/idkit) and derived
   from `action` string defined in the Developer Portal.
2. The [`nullifierHashes` mapping](https://docs.worldcoin.org/reference/contracts#sybil-resistance) is used to keep track of
   the nullifier hashes that have been used already. This is used to guarantee that an action is only performed once by a single
   person in order to achieve sybil resistance.
3. The `verifyAndExecute` function is the main function that will be called by the user to verify their proof of personhood.
   It takes the user's wallet address, the root of the Merkle tree, the nullifier hash, and the proof as parameters.
4. The function first checks if the nullifier hash has been used already and reverts if it has.
5. It then verifies the proof using the `worldId.verifyProof` function which is part of the `IWorldID` interface.
6. If the proof is valid, the function records the nullifier hash and executes the logic of the app. In this case, it emits
   the `Verified` event.

If you want an example of a production application which uses the World ID protocol, you can check out the
[Worldcoin grants contracts](https://github.com/worldcoin/worldcoin-grants-contracts).
Specifically, the [`RecurringGrantDrop.sol`](https://github.com/worldcoin/worldcoin-grants-contracts/blob/main/src/RecurringGrantDrop.sol)
contract which uses the World ID protocol to verify that the user is a unique human before they can claim a grant.

## Deploy template app

First, you have to go to a node provider that supports World Chain Sepolia. You can use [Alchemy](https://www.alchemy.com/)
or any of the other providers listed in the [World Chain documentation](/world-chain/providers/nodes). Once you have a node provider
account, you need to get an RPC URL for the World Chain Sepolia network. For a simple deployment, the public RPC URL is sufficient.
However, for doing a fork deployment, you will need to run a local fork of World Chain Sepolia using anvil which requires higher
requirements on the RPC provider for forking the network.

First, we will fork the World Chain Sepolia network using anvil:

```bash theme={null}
# Substitute the RPC_URL with the RPC URL of the World Chain Sepolia network
anvil -f $RPC_URL
```

We also need to set three important environment variables that are required for the deployment of the World ID template app:

* `WORLD_ID_ROUTER`: The address of the World ID router contract that will verify the proofs (can be found in the [World ID documentation](https://docs.worldcoin.org/world-chain/reference/useful-contracts))
* `NEXT_PUBLIC_APP_ID`: The app ID that was generated in the [Developer Portal](https://developer.worldcoin.org/login)
* `NEXT_PUBLIC_ACTION`: The action ID as configured in the [Developer Portal](https://developer.worldcoin.org/login)

Once the fork is running, you can deploy the World ID template app to the World Chain Sepolia network using the Foundry CLI:

```bash theme={null}
# cd into the contracts directory
cd contracts
forge create --rpc-url http://localhost:8545 --private-key 0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80 src/Contract.sol:Contract --constructor-args $WORLD_ID_ROUTER $NEXT_PUBLIC_APP_ID $NEXT_PUBLIC_ACTION
```

This command will deploy the `Contract` contract to the World Chain Sepolia network using the provided RPC URL and private key.

## Local Web Setup

Set up your environment variables in the `.env` file. You will need to set the following variables:

* `NEXT_PUBLIC_APP_ID`: The app ID as configured in the [Worldcoin Developer Portal](https://developer.worldcoin.org).
* `NEXT_PUBLIC_ACTION`: The action ID as configured in the Worldcoin Developer Portal.
* `NEXT_PUBLIC_WALLETCONNECT_ID`: Your WalletConnect ID.
* `NEXT_PUBLIC_CONTRACT_ADDRESS`: The address of the contract deployed in the previous step.

Back in the root directory of the World ID template app, you can start the local web server:

```bash theme={null}
pnpm dev
```

The Contract ABI will be automatically re-generated and saved to `src/abi/ContractAbi.json` on each run of `pnpm dev`.

## Iterating

After making changes to the contract, you should:

* re-run the `forge create` command from above
* replace the `NEXT_PUBLIC_CONTRACT_ADDRESS` environment variable with the new contract address
* if your contract ABI has changed, restart the local web server

## Testing

You'll need to import the private keys on the local testnet into your wallet used for local development. The default development seed phrase is `test test test test test test test test test test test junk`.

<Note>
  This is only for local development. Do not use this seed phrase on mainnet or
  any public testnet.
</Note>

When connecting your wallet to the local development environment, you will be prompted to add the network to your wallet.

Use the [Worldcoin Simulator](https://simulator.worldcoin.org) in place of World App to scan the IDKit QR codes and generate the zero-knowledge proofs.

## Further resources

If you want to learn more about the World ID protocol, you can check out the [World ID documentation](/world-id). If you want to build an application
that uses World ID and targets existing World App users, check out [miniapps](/mini-apps)!


# World Chain Contracts
Source: https://docs.world.org/world-chain/developers/world-chain-contracts



## World Chain Mainnet

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Address</th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>L2ToL1MessagePasser</td>
      <td>[`0x4200000000000000000000000000000000000016`](https://worldscan.org/address/0x4200000000000000000000000000000000000016)</td>
    </tr>

    <tr>
      <td>L2CrossDomainMessenger</td>
      <td>[`0x4200000000000000000000000000000000000007`](https://worldscan.org/address/0x4200000000000000000000000000000000000007)</td>
    </tr>

    <tr>
      <td>L2StandardBridge</td>
      <td>[`0x4200000000000000000000000000000000000010`](https://worldscan.org/address/0x4200000000000000000000000000000000000010)</td>
    </tr>

    <tr>
      <td>L2ERC721Bridge</td>
      <td>[`0x4200000000000000000000000000000000000014`](https://worldscan.org/address/0x4200000000000000000000000000000000000014)</td>
    </tr>

    <tr>
      <td>SequencerFeeVault</td>
      <td>[`0x4200000000000000000000000000000000000011`](https://worldscan.org/address/0x4200000000000000000000000000000000000011)</td>
    </tr>

    <tr>
      <td>OptimismMintableERC20Factory</td>
      <td>[`0x4200000000000000000000000000000000000012`](https://worldscan.org/address/0x4200000000000000000000000000000000000012)</td>
    </tr>

    <tr>
      <td>OptimismMintableERC721Factory</td>
      <td>[`0x4200000000000000000000000000000000000017`](https://worldscan.org/address/0x4200000000000000000000000000000000000017)</td>
    </tr>

    <tr>
      <td>L1Block</td>
      <td>[`0x4200000000000000000000000000000000000015`](https://worldscan.org/address/0x4200000000000000000000000000000000000015)</td>
    </tr>

    <tr>
      <td>GasPriceOracle</td>
      <td>[`0x420000000000000000000000000000000000000F`](https://worldscan.org/address/0x420000000000000000000000000000000000000F)</td>
    </tr>

    <tr>
      <td>ProxyAdmin</td>
      <td>[`0x4200000000000000000000000000000000000018`](https://worldscan.org/address/0x4200000000000000000000000000000000000018)</td>
    </tr>

    <tr>
      <td>BaseFeeVault</td>
      <td>[`0x4200000000000000000000000000000000000019`](https://worldscan.org/address/0x4200000000000000000000000000000000000019)</td>
    </tr>

    <tr>
      <td>L1FeeVault</td>
      <td>[`0x420000000000000000000000000000000000001A`](https://worldscan.org/address/0x420000000000000000000000000000000000001A)</td>
    </tr>

    <tr>
      <td>GovernanceToken</td>
      <td>[`0x4200000000000000000000000000000000000042`](https://worldscan.org/address/0x4200000000000000000000000000000000000042)</td>
    </tr>

    <tr>
      <td>SchemaRegistry</td>
      <td>[`0x4200000000000000000000000000000000000020`](https://worldscan.org/address/0x4200000000000000000000000000000000000020)</td>
    </tr>

    <tr>
      <td>EAS</td>
      <td>[`0x4200000000000000000000000000000000000021`](https://worldscan.org/address/0x4200000000000000000000000000000000000021)</td>
    </tr>
  </tbody>
</table>

## Ethereum Mainnet

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Address</th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>AnchorStateRegistryProxy</td>
      <td>[`0xD4D7A57DCC563756DeD99e224E144A6Bf0327099`](https://etherscan.io/address/0xD4D7A57DCC563756DeD99e224E144A6Bf0327099)</td>
    </tr>

    <tr>
      <td>Batch Submitter</td>
      <td>[`0xdBBE3D8c2d2b22A2611c5A94A9a12C2fCD49Eb29`](https://etherscan.io/address/0xdBBE3D8c2d2b22A2611c5A94A9a12C2fCD49Eb29)</td>
    </tr>

    <tr>
      <td>Challenger</td>
      <td>[`0xA4fB12D15Eb85dc9284a7df0AdBC8B696EdbbF1d`](https://etherscan.io/address/0xA4fB12D15Eb85dc9284a7df0AdBC8B696EdbbF1d)</td>
    </tr>

    <tr>
      <td>DelayedWETHProxy</td>
      <td>[`0xF9adF7c9502C5C60352C20a4d22683422DbD061F`](https://etherscan.io/address/0xF9adF7c9502C5C60352C20a4d22683422DbD061F)</td>
    </tr>

    <tr>
      <td>DisputeGameFactoryProxy</td>
      <td>[`0x069c4c579671f8c120b1327a73217D01Ea2EC5ea`](https://etherscan.io/address/0x069c4c579671f8c120b1327a73217D01Ea2EC5ea)</td>
    </tr>

    <tr>
      <td>L1CrossDomainMessengerProxy</td>
      <td>[`0xf931a81D18B1766d15695ffc7c1920a62b7e710a`](https://etherscan.io/address/0xf931a81D18B1766d15695ffc7c1920a62b7e710a)</td>
    </tr>

    <tr>
      <td>L1ERC721BridgeProxy</td>
      <td>[`0x1Df436AfDb2fBB40F1fE8bEd4Fc89A0D0990a8E9`](https://etherscan.io/address/0x1Df436AfDb2fBB40F1fE8bEd4Fc89A0D0990a8E9)</td>
    </tr>

    <tr>
      <td>L1StandardBridgeProxy</td>
      <td>[`0x470458C91978D2d929704489Ad730DC3E3001113`](https://etherscan.io/address/0x470458C91978D2d929704489Ad730DC3E3001113)</td>
    </tr>

    <tr>
      <td>L2OutputOracleProxy</td>
      <td>[`0x19A6d1E9034596196295CF148509796978343c5D`](https://etherscan.io/address/0x19A6d1E9034596196295CF148509796978343c5D)</td>
    </tr>

    <tr>
      <td>MIPS</td>
      <td>[`0x16e83cE5Ce29BF90AD9Da06D2fE6a15d5f344ce4`](https://etherscan.io/address/0x16e83cE5Ce29BF90AD9Da06D2fE6a15d5f344ce4)</td>
    </tr>

    <tr>
      <td>OptimismMintableERC20FactoryProxy</td>
      <td>[`0x82Cb528466cF22412d89bdBE9bCF04856790dD0e`](https://etherscan.io/address/0x82Cb528466cF22412d89bdBE9bCF04856790dD0e)</td>
    </tr>

    <tr>
      <td>OptimismPortalProxy</td>
      <td>[`0xd5ec14a83B7d95BE1E2Ac12523e2dEE12Cbeea6C`](https://etherscan.io/address/0xd5ec14a83B7d95BE1E2Ac12523e2dEE12Cbeea6C)</td>
    </tr>

    <tr>
      <td>PermissionedDisputeGame</td>
      <td>[`0x48cf980849a7eEA03180f7dea4E21C112097b03E`](https://etherscan.io/address/0x48cf980849a7eEA03180f7dea4E21C112097b03E)</td>
    </tr>

    <tr>
      <td>PreimageOracle</td>
      <td>[`0x9c065e11870B891D214Bc2Da7EF1f9DDFA1BE277`](https://etherscan.io/address/0x9c065e11870B891D214Bc2Da7EF1f9DDFA1BE277)</td>
    </tr>

    <tr>
      <td>ProtocolVersionsProxy</td>
      <td>[`0x8eeF04eef96fef1050702453f75F0Fc4f8F70973`](https://etherscan.io/address/0x8eeF04eef96fef1050702453f75F0Fc4f8F70973)</td>
    </tr>

    <tr>
      <td>ProxyAdmin</td>
      <td>[`0xd7405BE7f3e63b094Af6C7C23D5eE33Fd82F872D`](https://etherscan.io/address/0xd7405BE7f3e63b094Af6C7C23D5eE33Fd82F872D)</td>
    </tr>

    <tr>
      <td>SafeProxyFactory</td>
      <td>[`0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2`](https://etherscan.io/address/0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2)</td>
    </tr>

    <tr>
      <td>SuperchainConfigProxy</td>
      <td>[`0x95703e0982140D16f8ebA6d158FccEde42f04a4C`](https://etherscan.io/address/0x95703e0982140D16f8ebA6d158FccEde42f04a4C)</td>
    </tr>

    <tr>
      <td>SystemConfigProxy</td>
      <td>[`0x6ab0777fD0e609CE58F939a7F70Fe41F5Aa6300A`](https://etherscan.io/address/0x6ab0777fD0e609CE58F939a7F70Fe41F5Aa6300A)</td>
    </tr>

    <tr>
      <td>OpUSDCBridgeAdapter</td>
      <td>[`0x153A69e4bb6fEDBbAaF463CB982416316c84B2dB`](https://etherscan.io/address/0x153A69e4bb6fEDBbAaF463CB982416316c84B2dB)</td>
    </tr>
  </tbody>
</table>

## World Chain Sepolia Testnet

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Address</th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>L2ToL1MessagePasser</td>
      <td>[`0x4200000000000000000000000000000000000016`](https://worldchain-sepolia.explorer.alchemy.com/address/0x4200000000000000000000000000000000000016)</td>
    </tr>

    <tr>
      <td>L2CrossDomainMessenger</td>
      <td>[`0x4200000000000000000000000000000000000007`](https://worldchain-sepolia.explorer.alchemy.com/address/0x4200000000000000000000000000000000000007)</td>
    </tr>

    <tr>
      <td>L2StandardBridge</td>
      <td>[`0x4200000000000000000000000000000000000010`](https://worldchain-sepolia.explorer.alchemy.com/address/0x4200000000000000000000000000000000000010)</td>
    </tr>

    <tr>
      <td>L2ERC721Bridge</td>
      <td>[`0x4200000000000000000000000000000000000014`](https://worldchain-sepolia.explorer.alchemy.com/address/0x4200000000000000000000000000000000000014)</td>
    </tr>

    <tr>
      <td>SequencerFeeVault</td>
      <td>[`0x4200000000000000000000000000000000000011`](https://worldchain-sepolia.explorer.alchemy.com/address/0x4200000000000000000000000000000000000011)</td>
    </tr>

    <tr>
      <td>OptimismMintableERC20Factory</td>
      <td>[`0x4200000000000000000000000000000000000012`](https://worldchain-sepolia.explorer.alchemy.com/address/0x4200000000000000000000000000000000000012)</td>
    </tr>

    <tr>
      <td>OptimismMintableERC721Factory</td>
      <td>[`0x4200000000000000000000000000000000000017`](https://worldchain-sepolia.explorer.alchemy.com/address/0x4200000000000000000000000000000000000017)</td>
    </tr>

    <tr>
      <td>L1Block</td>
      <td>[`0x4200000000000000000000000000000000000015`](https://worldchain-sepolia.explorer.alchemy.com/address/0x4200000000000000000000000000000000000015)</td>
    </tr>

    <tr>
      <td>GasPriceOracle</td>
      <td>[`0x420000000000000000000000000000000000000F`](https://worldchain-sepolia.explorer.alchemy.com/address/0x420000000000000000000000000000000000000F)</td>
    </tr>

    <tr>
      <td>ProxyAdmin</td>
      <td>[`0x4200000000000000000000000000000000000018`](https://worldchain-sepolia.explorer.alchemy.com/address/0x4200000000000000000000000000000000000018)</td>
    </tr>

    <tr>
      <td>BaseFeeVault</td>
      <td>[`0x4200000000000000000000000000000000000019`](https://worldchain-sepolia.explorer.alchemy.com/address/0x4200000000000000000000000000000000000019)</td>
    </tr>

    <tr>
      <td>L1FeeVault</td>
      <td>[`0x420000000000000000000000000000000000001A`](https://worldchain-sepolia.explorer.alchemy.com/address/0x420000000000000000000000000000000000001A)</td>
    </tr>

    <tr>
      <td>GovernanceToken</td>
      <td>[`0x4200000000000000000000000000000000000042`](https://worldchain-sepolia.explorer.alchemy.com/address/0x4200000000000000000000000000000000000042)</td>
    </tr>

    <tr>
      <td>SchemaRegistry</td>
      <td>[`0x4200000000000000000000000000000000000020`](https://worldchain-sepolia.explorer.alchemy.com/address/0x4200000000000000000000000000000000000020)</td>
    </tr>

    <tr>
      <td>EAS</td>
      <td>[`0x4200000000000000000000000000000000000021`](https://worldchain-sepolia.explorer.alchemy.com/address/0x4200000000000000000000000000000000000021)</td>
    </tr>
  </tbody>
</table>

## Ethereum Sepolia Testnet

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Address</th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>AnchorStateRegistryProxy</td>
      <td>[`0x1333d5E5201D760444A399E77b3D337eBDB0DD07`](https://sepolia.etherscan.io/address/0x1333d5E5201D760444A399E77b3D337eBDB0DD07)</td>
    </tr>

    <tr>
      <td>Batch Submitter</td>
      <td>[`0x0f3ff4731D7a10B89ED79AD1Fd97844d7F66B96d`](https://sepolia.etherscan.io/address/0x0f3ff4731D7a10B89ED79AD1Fd97844d7F66B96d)</td>
    </tr>

    <tr>
      <td>Challenger</td>
      <td>[`0x945185C01fb641bA3E63a9bdF66575e35a407837`](https://sepolia.etherscan.io/address/0x945185C01fb641bA3E63a9bdF66575e35a407837)</td>
    </tr>

    <tr>
      <td>DelayedWETHProxy</td>
      <td>[`0x4F4B8Adf1af4b61bb62F68b7aF1c37f8A6311663`](https://sepolia.etherscan.io/address/0x4F4B8Adf1af4b61bb62F68b7aF1c37f8A6311663)</td>
    </tr>

    <tr>
      <td>DisputeGameFactoryProxy</td>
      <td>[`0x8Ec1111f67Dad6b6A93B3F42DfBC92D81c98449A`](https://sepolia.etherscan.io/address/0x8Ec1111f67Dad6b6A93B3F42DfBC92D81c98449A)</td>
    </tr>

    <tr>
      <td>L1CrossDomainMessengerProxy</td>
      <td>[`0x7768c821200554d8F359A8902905Ba9eDe5659a9`](https://sepolia.etherscan.io/address/0x7768c821200554d8F359A8902905Ba9eDe5659a9)</td>
    </tr>

    <tr>
      <td>L1ERC721BridgeProxy</td>
      <td>[`0x3580505c56f8560E3777E92Fb27f70fD20c5B493`](https://sepolia.etherscan.io/address/0x3580505c56f8560E3777E92Fb27f70fD20c5B493)</td>
    </tr>

    <tr>
      <td>L1StandardBridgeProxy</td>
      <td>[`0xd7DF54b3989855eb66497301a4aAEc33Dbb3F8DE`](https://sepolia.etherscan.io/address/0xd7DF54b3989855eb66497301a4aAEc33Dbb3F8DE)</td>
    </tr>

    <tr>
      <td>L2OutputOracleProxy</td>
      <td>[`0xc8886f8BAb6Eaeb215aDB5f1c686BF699248300e`](https://sepolia.etherscan.io/address/0xc8886f8BAb6Eaeb215aDB5f1c686BF699248300e)</td>
    </tr>

    <tr>
      <td>MIPS</td>
      <td>[`0x69470D6970Cd2A006b84B1d4d70179c892cFCE01`](https://sepolia.etherscan.io/address/0x69470D6970Cd2A006b84B1d4d70179c892cFCE01)</td>
    </tr>

    <tr>
      <td>OptimismMintableERC20FactoryProxy</td>
      <td>[`0x2D272eF54Ee8EF5c2Ff3523559186580b158cd57`](https://sepolia.etherscan.io/address/0x2D272eF54Ee8EF5c2Ff3523559186580b158cd57)</td>
    </tr>

    <tr>
      <td>OptimismPortalProxy</td>
      <td>[`0xFf6EBa109271fe6d4237EeeD4bAb1dD9A77dD1A4`](https://sepolia.etherscan.io/address/0xFf6EBa109271fe6d4237EeeD4bAb1dD9A77dD1A4)</td>
    </tr>

    <tr>
      <td>PermissionedDisputeGame</td>
      <td>[`0x552334Bf0B124bD89BFF744f33Ca7e49d44a80Ac`](https://sepolia.etherscan.io/address/0x552334Bf0B124bD89BFF744f33Ca7e49d44a80Ac)</td>
    </tr>

    <tr>
      <td>PreimageOracle</td>
      <td>[`0x92240135b46fc1142dA181f550aE8f595B858854`](https://sepolia.etherscan.io/address/0x92240135b46fc1142dA181f550aE8f595B858854)</td>
    </tr>

    <tr>
      <td>ProtocolVersionsProxy</td>
      <td>[`0x01DBC9aBe8e59f021d47Cf79143DE830820CbA29`](https://sepolia.etherscan.io/address/0x01DBC9aBe8e59f021d47Cf79143DE830820CbA29)</td>
    </tr>

    <tr>
      <td>ProxyAdmin</td>
      <td>[`0x3a987FE1cb587B0A1808cf9bB7Cbe0E341838319`](https://sepolia.etherscan.io/address/0x3a987FE1cb587B0A1808cf9bB7Cbe0E341838319)</td>
    </tr>

    <tr>
      <td>SafeProxyFactory</td>
      <td>[`0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2`](https://sepolia.etherscan.io/address/0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2)</td>
    </tr>

    <tr>
      <td>SuperchainConfigProxy</td>
      <td>[`0xC2Be75506d5724086DEB7245bd260Cc9753911Be`](https://sepolia.etherscan.io/address/0xC2Be75506d5724086DEB7245bd260Cc9753911Be)</td>
    </tr>

    <tr>
      <td>SystemConfigProxy</td>
      <td>[`0x166F9406e79A656f12F05247fb8F5DfA6155bCBF`](https://sepolia.etherscan.io/address/0x166F9406e79A656f12F05247fb8F5DfA6155bCBF)</td>
    </tr>
  </tbody>
</table>


# World Chain Overview
Source: https://docs.world.org/world-chain/index

Overview of World Chain: a human-centric L2 with free gas for verified users, Mini Apps distribution, and sybil resistance.

<img alt="World Chain" />

World Chain is a blockchain for humans. World chain offers several unique primitives:

* Free gas fees for all verified humans
* Native mobile distribution to all World App users through [mini-apps](/mini-apps)
* Simplified crypto transactions [through mini apps](/mini-apps/commands/verify)
* Sybil resistance for developers via [World ID](/world-id)
* Airdrop of WLD tokens to all verified humans

These primitives enable World Chain builders to build never before possible applications and reach a global audience.

World Chain is built on the [Superchain](https://docs.optimism.io/superchain/superchain-explainer).

To learn more about what is World Chain, watch our presentation from the [A New World](https://www.youtube.com/watch?v=_RWvsCZ17x8\&ab_channel=World) event: <br />
[A New World: World Chain and Priority Blockspace for Humans ft. Liam Horne](https://www.youtube.com/watch?v=NSxyKsSwjsc\&ab_channel=World) on our [YouTube channel](https://www.youtube.com/@worldnetworkofficial).

<Note>
  Is anything missing in the documentation? Please reach out on our [Telegram
  for World Chain developers](https://t.me/worldcoindevelopers)
</Note>


# Bridges
Source: https://docs.world.org/world-chain/providers/bridges



## Superchain Bridges

The Superchain bridge is the native bridge for World Chain as it comes with the OP Stack smart contracts which power the network. There are several interface providers for this bridge and it allows users to bridge assets from Ethereum mainnet and onto World Chain and vice versa.

### Superbridge Core

[Superbridge.app](https://superbridge.app/world-chain) is a blockchain bridging platform that enables users to transfer Ethereum (ETH) and ERC20 tokens between different blockchain networks, primarily focusing on OP Stack Layer 2 rollups chains including the World Chain network.

### Alchemy Bridge

The [native bridge interface for World Chain mainnet](https://worldchain-mainnet.bridge.alchemy.com/) provided by [Alchemy](https://alchemy.com/) is the rollup as a service (RaaS) provider for World Chain. As part of this service it also provides a World Chain bridge interface for users to deposit to and withdraw assets from the network. There is also a [testnet bridge](https://worldchain-sepolia.bridge.alchemy.com/) available for developers and users to bridge assets to the World Chain Sepolia testnet.

## Third-party bridges

<Note>
  Across is the recommended provider for bridging WLD between World Chain and other networks.
</Note>

### Across

[Across](https://app.across.to/bridge?) is an intent-based cross-chain bridging protocol that allows users to transfer tokens between different blockchain networks, particularly focusing on Layer 2 solutions and Ethereum-compatible chains.

### Brid.gg

[Brid.gg](https://brid.gg/) facilitates cross-chain transactions and aims to improve interoperability between different blockchain networks. It primarily connects Ethereum Mainnet to OP Chains including World Chain, allowing for transfers of digital assets across various blockchains.

### Superbridge fast

[Superbridge Fast](https://superbridge.app/fast) is a service offered by Superbridge that allows users to deposit and withdraw assets to and from World Chain quickly using third party bridges like [Synapse](/world-chain/providers/bridges#synapse), [Across](/world-chain/providers/bridges#across), and [Hyperlane](/world-chain/providers/bridges#hyperlane) which are directly integrated with the Superchain bridge interface. This is the fastest way to bridge assets to and from World Chain.
The next best method is to use the native Superchain bridge for which both Alchemy and Superbridge Core provide interfaces.

### Synapse

[Synapse](https://synapseprotocol.com/) is a cross-chain communication protocol that enables seamless asset transfers and messaging across different blockchain networks. It provides a secure and efficient infrastructure for interoperability, allowing users to move tokens and data between various chains without the need for centralized intermediaries.

### Hyperlane

[Hyperlane](https://hyperlane.xyz/) is an innovative interoperability protocol designed to facilitate seamless cross-chain communication and enable the development of interchain applications.

Hyperlane provides permissionless infrastructure for sending arbitrary data between blockchains, allowing developers to create applications that can be accessed from any connected chain.
It supports general asset transfers and custom cross-chain messaging, enabling users to interact with assets and applications across different networks including World Chain.

### LayerZero

[LayerZero](https://layerzero.network/) is an omnichain interoperability protocol that enables seamless communication between different blockchains.

### Chainlink CCIP

[Chainlink CCIP](https://chain.link/cross-chain) is a blockchain interoperability protocol that enables developers to build secure applications that can transfer tokens, messages (data), or both tokens and messages across chains.
You can see World Chain-specific documentation for CCIP [here](https://docs.chain.link/ccip/directory/mainnet/chain/ethereum-mainnet-worldchain-1).

### Thirdweb Universal Bridge

Thirdweb's [Universal Bridge](https://portal.thirdweb.com/connect/pay/overview) is a comprehensive Web3 payment solution that allows your users to onramp, bridge, and swap on any EVM chain â€” with any EVM token or fiat â€” thanks to its automatic cross-chain routing.

## Liquidity Layers

### Cortex Protocol

[Cortex Protocol](https://cortexprotocol.com/) is a decentralized, non-custodial liquidity protocol built on Ethereum that enables users to lend and borrow crypto assets. The protocol is designed to provide a secure and efficient platform for decentralized finance (DeFi) activities.


# Data Indexing and Analytics
Source: https://docs.world.org/world-chain/providers/data



Data indexing solutions and other APIs streamline access to blockchain data, enabling efficient querying and real-time analysis of on-chain events. This is crucial for decentralized applications built on World Chain, as it reduces the cost of processing, and presenting data. APIs also facilitate
third-party integration, enhancing developer experiences and expanding the ecosystem with more accessible, decentralized apps (dApps) and services.

## Allium

[Allium](https://allium.so/) is an enterprise blockchain data platform designed to provide accurate, fast, and simple access to blockchain data across over 70 blockchains and more than 1,000 enriched schemas. It offers tools for developers and analysts to build real-time applications and perform cross-chain data exploration with low-latency APIs and customizable workflows.

Allium features:

* Low-Latency APIs
* Data Freshness
* Real-Time Data Streams
* Decoded logs and traces

### Supported networks

* World Chain

## Dune

[Dune Analytics](https://dune.com/) is a blockchain data platform that enables users to query, visualize, and share insights from on-chain data.
It provides a powerful interface for querying blockchain information using SQL-like queries, allowing users
to create custom dashboards and visualizations.

Dune's enhanced data accessibility and insights will give developers and non-developers on World Chain the
ability to:

* Explore metrics related to real humans interacting on the chain
* Track the performance of DeFi protocols and DEXes
* Explore onchain data of any public blockchain project

With Dune's comprehensive dataset and web-based app, anyone (with a little SQL knowledge) may quickly query World Chain data and create insightful dashboards.

For more data on [World](https://world.org/) and [World Chain](https://world.org/world-chain), visit the World Data Dashboards on Dune:

* [World Chain](https://dune.com/blockchains/worldchain)
* [World](https://dune.com/world/world)

### Supported networks

* World Chain

## Zerion API

[The Zerion API](https://zerion.io/api) can be used to build feature-rich web3 apps, wallets, and protocols with ease.
Across all major blockchains, you can access wallets, assets, and chain data for web3 portfolios.

### Supported networks

* World Chain

## GoldSky Subgraphs

GoldSky Subgraphs is a data indexing service designed to simplify querying blockchain data. It provides developers with scalable, customizable subgraphs for
efficiently indexing and retrieving on-chain data from various blockchain networks. GoldSky streamlines data access for decentralized applications (dApps),
offering a user-friendly interface and advanced APIs that help developers query blockchain data faster and more accurately.

### Supported networks

* World Chain

## Alchemy Subgraphs

[Alchemy Subgraphs](https://docs.alchemy.com/reference/subgraphs-quickstart) provide fast, reliable blockchain indexing and community APIs.

### Supported networks

* World Chain
* World Chain Sepolia

## QuickNode

Build real-time data processing pipelines with QuickNode Streams. Get instant access to World Chain data feeds with custom webhooks, filtering, and automatic retries. Backfill historical blockchain data in minutes with our ETL tools. Perfect for indexers, analytics platforms, and data-intensive applications.

### Supported Resources

* [Streams](https://www.quicknode.com/streams)
* [Backfills](https://www.quicknode.com/streams/backfills)

### Supported networks

* World Chain
* World Chain Sepolia

## Noves

[Noves](https://www.noves.fi/) provides easy-to-use APIs for a variety of data on World Chain. You can find documentation for Noves APIs [here](https://docs.noves.fi/reference/api-overview).

### Supported networks

* World Chain
* World Chain Sepolia


# Developer Tooling
Source: https://docs.world.org/world-chain/providers/developer-tooling



## Alchemy

Alchemy provides a suite of data tools to make it easy to build on World Chain:

* [APIs](https://docs.alchemy.com/reference/token-api-quickstart) provide out-of-the-box solutions to retrieve fungible token balances, metadata, and historical transaction activity.
* [Webhooks](https://docs.alchemy.com/reference/notify-api-quickstart) allow you to configure real-time push notifications for on-chain activity.
* [Subgraphs](https://docs.alchemy.com/reference/subgraphs-quickstart) provide fast, reliable blockchain indexing and community APIs.
* [Account Kit](https://accountkit.alchemy.com/) provides smart wallets to grow your app. Securely onboard and activate users with no seed phrase or gas fees with easy-to-use, enterprise-grade wallets.

### Supported networks

* World Chain
* World Chain Sepolia

## Blocknative

[Blocknative's Gas Price API](https://docs.blocknative.com/gas-prediction/gas-platform) predicts next-block gas prices.

### Supported networks

* World Chain

## QuickNode

Access comprehensive developer tools built for World Chain:

* [RPC API](https://www.quicknode.com/core-api)
* [Streams](https://www.quicknode.com/streams)
* [Functions](https://www.quicknode.com/functions)
* [Dedicated Clusters](https://www.quicknode.com/clusters)
* [Rollup Deployer](https://www.quicknode.com/rollup)

Each tool is designed for production-grade applications with enterprise-level support and documentation.

### Supported networks

* World Chain
* World Chain Sepolia

## Tenderly

[Tenderly](https://tenderly.co/) is a blockchain development platform that provides tools for building, monitoring,
and managing smart contracts on Ethereum and other EVM-compatible chains.
It offers features like real-time transaction monitoring, debugging, and advanced analytics
to help developers optimize and maintain their decentralized applications (dApps).

### Supported networks

* World Chain
* World Chain Sepolia

## Thirdweb

[Thirdweb](https://thirdweb.com/) is a comprehensive web3 development platform that provides a full-stack, open-source toolkit for building decentralized applications on EVM-compatible chains. It offers frontend SDKs for connecting users to web3, backend APIs for scalable smart contract interactions, and a suite of pre-built, audited smart contracts. Thirdweb's platform simplifies the development process by providing tools for wallet integration, NFT minting, payment processing, and user onboarding, allowing developers to create sophisticated web3 applications with ease across various verticals including gaming, creator platforms, and enterprise solutions.

### Supported networks

* World Chain
* World Chain Sepolia

## Worldscan (Etherscan)

[Worldscan](https://worldscan.org/) (provided by [Etherscan](https://etherscan.io/)) provides several valuable features for developers working with the Ethereum blockchain.
Here are some key developer-focused features offered by Etherscan:

* API access to the World Chain Blockchain explorer
* Smart contract verification
* Smart contract analytics
* Gas Tracking

### Supported networks

* [World Chain](https://worldscan.org/)
* [World Chain Sepolia](https://sepolia.worldscan.org/)


# Block Explorers
Source: https://docs.world.org/world-chain/providers/explorers



## Blockscout

A [Blockscout](https://blockscout.com/) explorer is available for [World Chain](https://worldchain-mainnet.explorer.alchemy.com/) provided by Alchemy.

Blockscout is a comprehensive, open-source blockchain explorer designed for inspecting and analyzing EVM (Ethereum Virtual Machine) based blockchains.

A testnet explorer is also available for [World Chain Sepolia](https://worldchain-sepolia.explorer.alchemy.com/).

## Dora

[Dora](https://www.ondora.xyz/network/worldchain/interactions) is an advanced multi-chain block explorer and unified search engine designed for the evolving blockchain ecosystem.
It offers users the ability to search and interact with data across more than 10 different networks, including World Chain.

It is an innovative blockchain explorer and search engine designed for the multichain and multi-VM world.

## Worldscan (Etherscan)

[Worldscan](https://worldscan.org) (provided by [Etherscan](https://etherscan.io)) is a comprehensive blockchain explorer and analytics platform specifically designed for the World Chain network.
It allows users to search, verify, and analyze transactions, addresses, smart contracts, and tokens on the World Chain blockchain. [World Chain Sepolia](https://sepolia.worldscan.org/) is also supported.

Worldscan provides tools to help you view transaction data and debug smart contracts:

* Search by address, transaction hash, batch, or token
* View, verify, and interact with smart contract source code
* View detailed transaction information
* View L1-to-L2 and L2-to-L1 transactions


# Nodes
Source: https://docs.world.org/world-chain/providers/nodes



## Alchemy

[Alchemy](https://alchemy.com/) is a leading blockchain development platform that provides robust node provisioning services for Web3 applications on World Chain.
Alchemy's node infrastructure services simplify the process of building, deploying, and scaling
blockchain applications by providing developers with access to a network of nodes on an on-demand basis.

For access to a World Chain node, check out the [World Chain Alchemy page](https://www.alchemy.com/world-chain).

### Supported networks

* World Chain
* World Chain Sepolia

## Blast API

Blast API offers standardized blockchain API services for Web3 development, allowing users to generate dedicated endpoints (RPC/WSS/REST) for supported blockchain networks. The platform employs geographically distributed third-party nodes to ensure reliability, low latency, and decentralization.

### Supported networks

* World Chain

## QuickNode

Enterprise-grade infrastructure for World Chain development with global edge delivery. Build with high-performance RPC APIs, real-time data streaming/ETL capabilities, decentralized storage via IPFS, and extensive developer tools through our marketplace. Ideal for teams building production-grade applications on World Chain.

QuickNode offers several benefits for developers building on World Chain, read more [here](https://quicknode.notion.site/QuickNode-Benefits-for-WorldChain-Developers-14b15a82e84c807ba912cc1a6a8a5c4a)!

### Supported networks

* [World Chain](https://www.quicknode.com/chains/worldchain)
* [World Chain Sepolia](https://www.quicknode.com/chains/worldchain)
* [Documentation](https://www.quicknode.com/chains/worldchain)

## Tenderly RPC

[Tenderly](https://tenderly.co/) is a blockchain development platform that provides tools for building, monitoring, and managing smart contracts on Ethereum and other EVM-compatible chains. They also provide node infrastructure services for World Chain.

### Supported networks

* World Chain
* World Chain Sepolia


# Onramps
Source: https://docs.world.org/world-chain/providers/onramps



## Ramp Network

[Ramp Network](https://ramp.network/) is a fintech company that provides a seamless, non-custodial fiat-to-crypto and crypto-to-fiat onramp solution for decentralized applications, wallets, and platforms. It enables users to buy, sell, and trade cryptocurrencies directly through integrated services without leaving the app they are using. Ramp focuses on simplifying the process for users by handling complex regulatory compliance, identity verification (KYC), and liquidity provisioning,
making it easier for businesses to integrate crypto transactions into their services.
Their API is widely used by developers to onboard users into the crypto ecosystem with minimal friction.

## Alfred pay

[Alfred Pay](https://www.alfredpay.io/) is a fintech company focused on bridging the gap between traditional financial systems and digital assets, specifically across Latin America. It offers a fiat-to-crypto and crypto-to-fiat gateway service, enabling users and businesses to easily move between digital currencies and local fiat currencies.

## Moonpay

[MoonPay](https://www.moonpay.com/) is a global fintech platform that simplifies the process of buying and selling cryptocurrencies. It provides a seamless fiat-to-crypto and crypto-to-fiat service, allowing users to purchase digital assets like Bitcoin and Ethereum using traditional payment methods such as credit cards, bank transfers, and mobile payment options. MoonPay also offers APIs and SDKs for developers to integrate crypto transactions into their applications.


# Oracles
Source: https://docs.world.org/world-chain/providers/oracles



Blockchain oracles are essential middleware that allow smart contracts to access external data and systems that exist outside the blockchain. They act as a secure bridge between blockchains and external sources, enabling smart contracts to use data that primarily exists off-chain.

## Api3

[Api3](https://api3.org/) provides 200+ push-based data feeds on World Chain.

You can enable any of Api3's data feeds on World Chain using the [Api3 Market](https://market.api3.org/world). Find the Api3 Market documentation [here](https://docs.api3.org/dapps/integration/).

### Supported networks

* World Chain

## Chainlink Data Streams

[Chainlink Data Streams](https://chain.link/) delivers low-latency market data offchain, which you can verify onchain.

You can find documentation for Chainlink Data Streams Direct [here](https://docs.chain.link/data-streams/streams-direct).

### Supported networks

* World Chain

## Pyth

[Pyth](https://www.pyth.network/) provides 1300+ pull-based price feeds on World Chain.

You can find documentation for Pyth Price Feeds [here](https://docs.pyth.network/price-feeds).

### Supported networks

* World Chain
* World Chain Sepolia

## RedStone

[RedStone](https://www.redstone.finance/)'s Pull Model provides price data for 200+ assets that can be verified on World Chain.

You can find documentation for RedStone's Pull Model [here](https://docs.redstone.finance/docs/dapps/redstone-pull/).

### Supported networks

* World Chain

## WitNet

[WitNet](https://witnet.io/) provides 6 price feeds on World Chain with Wit/Price Feeds, in addition to secure random data with Wit/Randomness and securely retrieving arbitrary data via HTTP from within smart contracts using Wit/Oracle.

Documentation for these products can be found below:

* [Wit/Price Feeds Documentation](https://docs.witnet.io/intro/tutorials/data-feeds-tutorial)
* [Wit/Randomness Documentation](https://docs.witnet.io/intro/tutorials/randomness)
* [Wit/Oracle Documentation](https://docs.witnet.io/intro/tutorials/apis-and-http-get-post)

### Supported networks

* World Chain
* World Chain Sepolia


# Paymasters
Source: https://docs.world.org/world-chain/providers/paymasters



## Alchemy

[Alchemy Paymasters](https://www.alchemy.com/overviews/what-is-a-paymaster) are smart contracts that enable decentralized applications (dApps) to implement flexible gas policies, including:

* Sponsoring gas fees for users
* Accepting gas payments in ERC-20 tokens instead of native blockchain currency

### Supported Networks

* World Chain
* World Chain Sepolia

## Pimlico

[Pimlico](https://pimlico.io/) provides account abstraction infrastructure including [paymasters](https://docs.pimlico.io/infra/paymaster) and [bundlers](https://docs.pimlico.io/infra/bundler). They offer two types of paymasters to abstract away gas fees for users in the ERC-4337 ecosystem.
A verifying paymaster allows developers to sponsor on-chain gas fees for users, it utilizes an off-chain Pimlico balance loaded through a dashboard and an ERC-20 paymaster which is a permissionless on-chain smart contract that enables users to pay gas fees using their ERC-20 tokens and operates without requiring developer intervention.

Pimlico's paymasters can be seamlessly integrated with [permissionless.js](https://docs.pimlico.io/permissionless), a TypeScript library built on [viem](https://github.com/wevm/viem/) for ERC-4337 development .

### Supported Networks

* World Chain
* World Chain Sepolia

## Thirdweb

Not only does [Thirdweb](https://thirdweb.com/) provide developer tools, but they also have [ERC-4337 compliant smart contract accounts](https://portal.thirdweb.com/contracts/build/base-contracts/erc-4337) with role-based permission control. They offer two main types: Simple and Managed smart accounts.

### Supported Networks

* World Chain
* World Chain Sepolia


# World Chain Data Dashboards
Source: https://docs.world.org/world-chain/quick-start/data



Worldcoin has partnered with several [data providers](/world-chain/providers/data) which have indexed World Chain data and serve it to
developers and data analysts through their APIs. As part of our ongoing efforts for transparency and accountability through open-sourcing
our technologies like the orb hardware, orb firmware, biometrics pipeline, World ID protocol and most other components of the Worldcoin ecosystem,
we believe that having open-source data and dashboards that showcase the progress of the Worldcoin project is essential.

You can find all of the main dashboards that track World Chain, World App and Worldcoin metrics in the [World Dune dashboard](https://dune.com/world/world).
If you want to see Dune dashboards that are specific to World Chain, check out [this Dune page](https://dune.com/blockchains/worldchain).

Another very important dashboard is the [L2BEAT World Chain dashboard](https://l2beat.com/scaling/projects/world) which shows all the metrics related to the OP Stack which includes a security,
decentralization and scalability assessment, risk analysis table and a TVL dashboard.


# Unique Features
Source: https://docs.world.org/world-chain/quick-start/features



World Chain is built on the OP Stack and is part of the Superchain, it uses the EVM for execution and Ethereum for data availability and finality.
These are standard properties of all Superchain networks, however, there are several features that make World Chain unique. World Chain is a network
built for unique humans and its features reflect that.

## Priority Blockspace for Humans

While it's open for everyone, World Chain was designed to prioritize anonymously verified human interactions over bots and AI through direct protocol integrations
with [World ID](https://world.org/world-id) for proof-of-human verification. One of the initial protocol integrations being worked on is Priority Blockspace for Humans (PBH).
PBH enables verified users to execute transactions guaranteeing top of block inclusion, enabling a more frictionless user experience.
PBH ensures that ordinary users aren't unfairly disadvantaged by automated systems, greatly mitigates the impact of [MEV](https://ethereum.org/en/developers/docs/mev/) attacks and exploits,
and reduces the need to pay significant gas fees to be included in a block. PBH also enables future flexibility, allowing for a separate EIP-1559-style
market for human transactions.

If you want to learn the details of how Priority Blockspace for Humans will work, please read the [World Blog PBH article](https://world.org/blog/engineering/introducing-pbh-priority-blockspace-for-humans).

If you are interested in PBH, how it works or if you would like to apply for a grant to help contribute to the roadmap, check out the [Human Collective Grants section](/world-chain/developers/grants)
or send us a message to [grants@worldcoin.org](mailto:grants@worldcoin.org).

## Gas Allowance for Humans

Not only do humans get priority inclusion on World Chain through PBH, but they also will have a gas stipend to transact on World Chain for free.
Initially the stipend to fund this gas allowance will be provided by the [World Foundation](https://worldcoin.foundation) with the goal of progressive
decentralization allowing World governance to set it.

There are two main approaches to implement the gas allowance, one option is on the app/wallet level through the use of account abstraction and the other one
is to set it at the OP Stack level through sequencer reimbursements or separate fee markets for unique humans where unique humans are not charged or their fees are paid for
by non-human transactions in the mempool which are executed by the sequencer. The simplest one is to implement a World ID gatekept [EIP4337](https://www.erc4337.io/) [paymaster](https://www.alchemy.com/overviews/what-is-a-paymaster)
where each `userOp` or group of `userOps` per user requires a World ID proof. More details on gas allowance for humans coming soon.


# Funding a Wallet
Source: https://docs.world.org/world-chain/quick-start/fund-wallet

Learn how to fund your wallet on World Chain

<Note>
  Make sure that whatever assets you are bridging to and from World Chain are always supported by your wallet and the exchange you are using.
  Depositing an unsupported asset on an unsupported chain to an unsupported wallet or exchange will result in loss of funds.
</Note>

In order to use World Chain you will need an [EVM-compatible wallet](https://ethereum.org/en/wallets/) such as MetaMask, Rabby, or any other wallet where you can add custom EVM networks.
If you are a user of World App then you can use the built-in wallet to interact with World Chain as well as the existing onramps and offramps which are integrated into the app.
The [Ethereum.org website](https://ethereum.org/en/) has [a great explainer on wallets](https://ethereum.org/en/wallets/) which goes into more detail on how to choose a wallet that is right for you.

## Bridging from Ethereum

If you are coming from Ethereum, you can bridge your assets to World Chain using the bridge interface provided by [Alchemy](https://worldchain-mainnet.bridge.alchemy.com/) which is an interface to the native OP Stack bridge contract that allows you to move assets between Ethereum and World Chain natively.
Since World Chain is an optimistic rollup, built on the [OP Stack](https://docs.optimism.io/stack/getting-started) and part of the [Superchain](https://docs.optimism.io/superchain/superchain-explainer) it takes about 7 days to withdraw from World Chain back to Ethereum through the native bridge as
the OP Stack needs to wait for [the fault proof period](https://docs.optimism.io/stack/fault-proofs/explainer) to expire before the L2 finalizes and the assets can be withdrawn back to Ethereum.

## Bridging from another network

There are several other bridges live between different L2s that are provided by multiple third parties that leverage different bridging mechanisms. The World Chain documentation has a [bridge section](/world-chain/providers/bridges) that lists several bridges that support the network.

## Bridging from an exchange or onramp provider

If you are coming from an exchange or [onramp provider](/world-chain/providers/onramps) that supports World Chain and you already have a wallet that supports the network then you can deposit your assets directly to your wallet.


# Getting Started
Source: https://docs.world.org/world-chain/quick-start/index

Add World Chain to your wallet and start using mainnet or Sepolia, with manual network details and helpful links.

In order to start using World Chain, you need to add the World Chain network to your wallet of choice. Either by clicking the button below:

<div>
  <a href="https://chainlist.org/chain/480">
    Add World Chain
  </a>

  <a href="https://chainlist.org/chain/4801">
    Add World Chain Sepolia
  </a>
</div>

Or by manually adding the information available in the [World Chain network section below](/world-chain/quick-start/info).


# Network Information
Source: https://docs.world.org/world-chain/quick-start/info

World Chain network configuration and technical details

## World Chain Mainnet

<Note type="info">World Chain Mainnet's per-block gas limit and target are regularly increased to accommodate the growing number of users and transactions. You can always find the current gas limit [here](https://etherscan.io/address/0x6ab0777fD0e609CE58F939a7F70Fe41F5Aa6300A#readProxyContract#F18).</Note>

<table>
  <thead>
    <tr>
      <th>Property</th>
      <th>Value</th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>Framework</td>

      <td>
        <a href="https://docs.optimism.io/">OP Stack</a>
      </td>
    </tr>

    <tr>
      <td>Chain ID</td>

      <td>
        <a href="https://chainlist.org/?search=World+Chain&testnets=false">
          ID480 (<code>0x1e0</code>)
        </a>
      </td>
    </tr>

    <tr>
      <td>EIP-3770 Short Name</td>

      <td>
        <code>wc</code>
      </td>
    </tr>

    <tr>
      <td>Settlement layer</td>
      <td>Ethereum</td>
    </tr>

    <tr>
      <td>Data availability</td>
      <td>Ethereum</td>
    </tr>

    <tr>
      <td>Gas Limit</td>
      <td>80M</td>
    </tr>

    <tr>
      <td>Gas Target</td>
      <td>40M</td>
    </tr>

    <tr>
      <td>Block Time</td>
      <td>2s</td>
    </tr>
  </tbody>
</table>

<table>
  <thead>
    <tr>
      <th>Important Links</th>
      <th>URLs</th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>Bridge</td>

      <td>
        <a href="https://worldchain-mainnet.bridge.alchemy.com">
          worldchain-mainnet.bridge.alchemy.com
        </a>
      </td>
    </tr>

    <tr>
      <td>Block Explorer</td>

      <td>
        <a href="https://worldscan.org">worldscan.org</a>
      </td>
    </tr>

    <tr>
      <td>Status Page</td>

      <td>
        <a href="https://worldchain-mainnet-status.alchemy.com">
          worldchain-mainnet-status.alchemy.com
        </a>
      </td>
    </tr>

    <tr>
      <td>RPC</td>

      <td>
        <a href="https://worldchain-mainnet.g.alchemy.com/public">
          worldchain-mainnet.g.alchemy.com/public
        </a>
      </td>
    </tr>

    <tr>
      <td>Developer Telegram</td>

      <td>
        <a href="https://t.me/worldcoindevelopers">@worldcoindevelopers</a>
      </td>
    </tr>
  </tbody>
</table>

<table>
  <thead>
    <tr>
      <th>Hardfork</th>
      <th>Timestamp</th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>Fjord</td>

      <td>
        1721826000 (Wed 24 Jul 2024 13:00:00 UTC)
      </td>
    </tr>

    <tr>
      <td>Granite</td>

      <td>
        1727780400 (Tue 1 Oct 2024 11:00:00 UTC)
      </td>
    </tr>

    <tr>
      <td>Holocene</td>

      <td>
        1738238400 (Thu 30 Jan 2025 12:00:00 UTC)
      </td>
    </tr>
  </tbody>
</table>

## World Chain Sepolia Testnet

<table>
  <thead>
    <tr>
      <th>Property</th>
      <th>Value</th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>Framework</td>

      <td>
        <a href="https://docs.optimism.io/">OP Stack</a>
      </td>
    </tr>

    <tr>
      <td>Chain ID</td>

      <td>
        <a href="https://chainlist.org/?search=World+Chain&testnets=true">
          ID4801 (<code>0x12C1</code>)
        </a>
      </td>
    </tr>

    <tr>
      <td>EIP-3770 Short Name</td>

      <td>
        <code>wcsep</code>
      </td>
    </tr>

    <tr>
      <td>Settlement layer</td>
      <td>Ethereum Sepolia</td>
    </tr>

    <tr>
      <td>Data availability</td>
      <td>Ethereum Sepolia</td>
    </tr>

    <tr>
      <td>Gas Limit</td>
      <td>30M</td>
    </tr>

    <tr>
      <td>Gas Target</td>
      <td>15M</td>
    </tr>

    <tr>
      <td>Block Time</td>
      <td>2s</td>
    </tr>
  </tbody>
</table>

<table>
  <thead>
    <tr>
      <th>Important Links</th>
      <th>URLs</th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>Bridge</td>

      <td>
        <a href="https://worldchain-sepolia.bridge.alchemy.com">
          worldchain-sepolia.bridge.alchemy.com
        </a>
      </td>
    </tr>

    <tr>
      <td>Block Explorer</td>

      <td>
        <a href="https://worldchain-sepolia.explorer.alchemy.com">
          worldchain-sepolia.explorer.alchemy.com
        </a>
      </td>
    </tr>

    <tr>
      <td>Status Page</td>

      <td>
        <a href="https://worldchain-sepolia-status.alchemy.com">
          worldchain-sepolia-status.alchemy.com
        </a>
      </td>
    </tr>

    <tr>
      <td>Faucet</td>

      <td>
        <a href="https://www.alchemy.com/faucets/world-chain-sepolia">
          alchemy.com/faucets/world-chain-sepolia
        </a>
      </td>
    </tr>

    <tr>
      <td>RPC</td>

      <td>
        <a href="https://worldchain-sepolia.g.alchemy.com/public">
          worldchain-sepolia.g.alchemy.com/public
        </a>
      </td>
    </tr>
  </tbody>
</table>

<table>
  <thead>
    <tr>
      <th>Hardfork</th>
      <th>Timestamp</th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>Fjord</td>

      <td>
        1721739600 (Tue 23 Jul 2024 13:00:00 UTC)
      </td>
    </tr>

    <tr>
      <td>Granite</td>

      <td>
        1726570800 (Tue 17 Sep 2024 11:00:00 UTC)
      </td>
    </tr>

    <tr>
      <td>Holocene</td>

      <td>
        1737633600 (Thu 23 Jan 2025 12:00:00 UTC)
      </td>
    </tr>

    <tr>
      <td>Pectra Blob Fix</td>

      <td>
        1742486400 (Thu 20 Mar 2025 16:00:00 UTC)
      </td>
    </tr>
  </tbody>
</table>


# Why World Chain?
Source: https://docs.world.org/world-chain/quick-start/why



The [World App](https://world.org/world-app) has undergone several transitions and it has lived on multiple chains over time.
First it was [Hubble](https://github.com/worldcoin/hubble-commander), an open-source optimismtic rollup with [BLS signature aggregation](https://hackmd.io/@benjaminion/bls12-381) of ERC20 transfers,
then it was [Polygon PoS](https://polygon.technology/polygon-pos), recently [OP mainnet](https://www.optimism.io/) and now [World Chain](https://world.org/world-chain). There were several motivating
factors for all of these changes.

<img alt="Onchain Evolution of World App" />

## Onchain evolution

Originally, the main target use case of World App was payments and WLD grants (pre-launch beta version), but as we required other applications such as DeFi and identity,
World App was migrated to Polygon PoS as it provided full EVM programmability and access to tools, infrastructure and applications like
[Safe smart contract wallets](https://world.org/blog/announcements/introducing-world-chain) DEXes and liquidity like [Uniswap](https://app.uniswap.org/),
and plenty of others that directly provided utility to World App, [World ID](https://world.org/world-id), their users and the wider
World ecosystem of applications and integrations. Another big motivating factor is cost, security,
decentralization and ecosystem network effects which were the main motivators behind the switch from Polygon PoS
to OP mainnet.

As the rollup-centric roadmap became the foundation of Ethereum scalability, solutions became adopted enough and reached a
certain point of maturity, it made sense to migrate World App over as it benefits a lot from all of the other
integrations, applications and infrastructure that were and are available on OP mainnet. We migrated over ahead of
our launch on July 24th 2023 and over the upcoming year World App reached a peak of [60% of OP mainnet blockspace consumption](https://dune.com/queries/491942/932394) (over a 30 day period).

As World App starts demanding more and more blockspace in order to support the goal of the largest digital identity and financial network with over a billion unique humans,
it will require further scaling the network it operates under. Which is why World Chain exists, it has pristine blockspace for the World App and the World ID ecosystem of applications. For more details on
World Chain you can read our [Introducing World Chain blogpost](https://world.org/blog/announcements/introducing-world-chain).

World Chain will allow World App, World ID and their ecosystems to scale throughput, increase gas limits, data availability and its overall scalability as the OP Stack improves with better execution clients, higher Ethereum blob counts and sizes (more DA) and plenty
of other technological improvements.

## What is different about World Chain?

The main differentiating properties of World Chain compared to other L2s or other Superchain members are that World Chain is a blockchain made for humans, where the transactions of unique humans have priority and where they also have a free allowance, just for being
a World ID verified unique human using proof of personhood. More on these features in the [Priority Blockspace for Humans and Free Gas Allowance sections](/world-chain/quick-start/features) Compared to other L2s one other very big differentiator is the number of unique users that World App brings with it,
and the possibilities for use cases and applications used by millions of unique humans will bring.

## Further resources

If you want to learn more about World Chain, OP Stack and the Superchain, you can take a look at the resources below:

* [A New World: World Chain and Priority Blockspace for Humans ft. Liam Horne](https://www.youtube.com/watch?v=NSxyKsSwjsc\&ab_channel=World)
* [Encode x World Educate Series: World Chain and the OP Stack](https://www.youtube.com/watch?v=7pt8c5fy-xg\&ab_channel=EncodeClub)
* [OP Mainnet docs](https://docs.optimism.io/app-developers/building-apps)
* [OP Stack docs](https://docs.optimism.io/stack/getting-started)
* [Superchain docs](https://docs.optimism.io/superchain/superchain-explainer)


# How to Set Up a World Chain Node
Source: https://docs.world.org/world-chain/reference/node-setup



Follow this guide to set up your own World Chain node.

<Note>
  Anyone running a World Chain node is encouraged to join this Telegram channel for notifications of required software updates or other relevant information: [World Chain Node Updates Telegram Channel](https://t.me/world_chain_updates)
</Note>

## Overview

World Chain mainnet and testnet run on the OP Stack as part of the Superchain. We provide a simple Docker Compose configuration for running World Chain nodes, [simple-worldchain-node](https://github.com/worldcoin-foundation/simple-worldchain-node). If you're interested in building a node from source, see the [documentation from Optimism](https://docs.optimism.io/operators/node-operators/tutorials/node-from-source).

## Using `simple-worldchain-node`

`simple-worldchain-node` supports World Chain Mainnet and Sepolia, full nodes and archive nodes, and two execution clients: [op-geth](https://github.com/ethereum-optimism/op-geth) and [op-reth](https://github.com/paradigmxyz/reth).

<Note>
  World Chain archive node snapshots for `op-geth` are available from Bware Labs [here](https://bwarelabs.com/snapshots/worldchain).
</Note>

### Installation

First, download [`simple-worldchain-node`](https://github.com/worldcoin-foundation/simple-worldchain-node) and create your `.env` file.

<CodeGroup>
  ```bash Download simple-worldchain-node theme={null}
  git clone https://github.com/worldcoin-foundation/simple-worldchain-node.git
  cd simple-worldchain-node
  cp .env.example .env
  ```
</CodeGroup>

Ensure you have installed Docker and Docker Compose by following [this guide](https://docs.docker.com/compose/install/#scenario-three-install-the-docker-compose-standalone).

### Configuration

Open your `.env` file in an editor of your choice. The following values must be configured before starting your node.

<ParamField type="worldchain-mainnet | worldchain-sepolia">
  Used to select which network the node connects to, either `worldchain-mainnet` or `worldchain-sepolia`.
</ParamField>

<ParamField type="geth | reth">
  Used to select your execution client, either `geth` (default) or `reth` (recommended for archive nodes).
</ParamField>

<ParamField type="full | archive">
  When using `op-geth`, determines which type of node to run. Either `full` (less storage, but only recent history) or `archive` (more storage, all history).
</ParamField>

<ParamField type="URL">
  An L1 (Ethereum) RPC endpoint. We recommend using [Alchemy](https://www.alchemy.com/) or [QuickNode](https://www.quicknode.com), but any Ethereum RPC provider or archive node will work.
</ParamField>

<ParamField type="URL">
  An L1 Beacon Archive RPC endpoint. Note that this is not the same as a standard RPC endpoint, as this is used to retrieve Blobs from the Ethereum Beacon Chain. We recommend using [QuickNode](https://www.quicknode.com/).
</ParamField>

<ParamField type="string">
  Selects which RPC provider is set in `OP_NODE__RPC_ENDPOINT`. This allows for more efficient syncing given different RPC capabilities. Choose from `alchemy`, `quicknode`, `erigon`, or `basic` for other RPC providers.
</ParamField>

<ParamField type="string">
  Selects whether `op-geth` will use snap sync or full sync. Defaults to `snap` for non-archival nodes and `full` for archive nodes.
</ParamField>

<ParamField type="string">
  Selects whether `op-geth` uses hash-based or path-based storage. As of `op-geth` v1.101602.0, path-based storage is supported for archive nodes and is enabled by default, leading to lower disk usage. The `eth_getProof` RPC method is not supported when using path-based storage.
</ParamField>

For details on additional settings, see the `simple-worldchain-node` [README](https://github.com/worldcoin-foundation/simple-worldchain-node?tab=readme-ov-file#optional-configurations).

### Running your node

To start your node in the background, run the following command from the `simple-worldchain-node` folder:

```bash theme={null}
docker compose up -d --build
```

To view logs for your node, run the following command:

```bash theme={null}
docker compose logs -f --tail 10
```

To shut down your node:

```bash theme={null}
docker compose down
```

### Monitoring your node

A Grafana dashboard is included to monitor your node. Access it by visiting [http://localhost:3000](http://localhost:3000) and logging in with these credentials:

* Username: `admin`
* Password: `worldchain`

### Upgrading your Node

When new versions of `op-geth`, `op-reth`, or `op-node` are released, we will update the `simple-worldchain-node` repository to use these new versions. You can then update your node to use these versions with the following commands:

```bash theme={null}
git pull
docker compose pull
docker compose up -d --build
```


# Useful Contract Deployments
Source: https://docs.world.org/world-chain/reference/useful-contracts



## Tokens

<table>
  <thead>
    <tr>
      <th>Contract</th>

      <th>
        World Chain Mainnet Address
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>WLD</td>

      <td>
        [`0x2cfc85d8e48f8eab294be644d9e25c3030863003`](https://worldscan.org/address/0x2cFc85d8E48F8EAB294be644d9E25C3030863003)
      </td>
    </tr>

    <tr>
      <td>WBTC</td>

      <td>
        [`0x03c7054bcb39f7b2e5b2c7acb37583e32d70cfa3`](https://worldscan.org/address/0x03c7054bcb39f7b2e5b2c7acb37583e32d70cfa3)
      </td>
    </tr>

    <tr>
      <td>SDAI</td>

      <td>
        [`0x859dbe24b90c9f2f7742083d3cf59ca41f55be5d`](https://worldscan.org/address/0x859dbe24b90c9f2f7742083d3cf59ca41f55be5d)
      </td>
    </tr>

    <tr>
      <td>WETH</td>

      <td>
        [`0x4200000000000000000000000000000000000006`](https://worldscan.org/address/0x4200000000000000000000000000000000000006)
      </td>
    </tr>

    <tr>
      <td>USDC</td>

      <td>
        [`0x79A02482A880bCE3F13e09Da970dC34db4CD24d1`](https://worldscan.org/address/0x79A02482A880bCE3F13e09Da970dC34db4CD24d1)
      </td>
    </tr>

    <tr>
      <td>
        L1 OpUSDCBridgeAdapter (Ethereum mainnet)
      </td>

      <td>
        [`0x153A69e4bb6fEDBbAaF463CB982416316c84B2dB`](https://etherscan.io/address/0x153A69e4bb6fEDBbAaF463CB982416316c84B2dB)
      </td>
    </tr>
  </tbody>
</table>

## World ID

You can find the World ID Address Book for all chains [here](https://docs.world.org/world-id/reference/address-book).

<table>
  <thead>
    <tr>
      <th>Contract</th>

      <th>
        World Chain Mainnet Address
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>WorldIDAddressBook</td>

      <td>
        [`0x57b930D551e677CC36e2fA036Ae2fe8FdaE0330D`](https://worldscan.org/address/0x57b930D551e677CC36e2fA036Ae2fe8FdaE0330D)
      </td>
    </tr>

    <tr>
      <td>WorldIDRouter</td>

      <td>
        [`0x17B354dD2595411ff79041f930e491A4Df39A278`](https://worldscan.org/address/0x17B354dD2595411ff79041f930e491A4Df39A278)
      </td>
    </tr>
  </tbody>
</table>

## Gnosis Safe 1.3.0

<table>
  <thead>
    <tr>
      <th>Contract</th>

      <th>
        World Chain Mainnet Address
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>HelperBatch Contract</td>

      <td>
        [`0x8d98006269238CAEd033b2d94661B29312AD09b7`](https://worldscan.org/address/0x8d98006269238CAEd033b2d94661B29312AD09b7)
      </td>
    </tr>

    <tr>
      <td>SafeL2Singleton</td>

      <td>
        [`0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552`](https://worldscan.org/address/0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552)
      </td>
    </tr>

    <tr>
      <td>SafeProxyFactory</td>

      <td>
        [`0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2`](https://worldscan.org/address/0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2)
      </td>
    </tr>
  </tbody>
</table>

## Gnosis Safe 1.4.1

<table>
  <thead>
    <tr>
      <th>Contract</th>

      <th>
        World Chain Mainnet Address
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>HelperBatch Contract</td>

      <td>
        [`0x866087c23a7eE1fD5498ef84D59aF742f3d4b322`](https://worldscan.org/address/0x866087c23a7eE1fD5498ef84D59aF742f3d4b322)
      </td>
    </tr>

    <tr>
      <td>SafeL2Singleton</td>

      <td>
        [`0x29fcB43b46531BcA003ddC8FCB67FFE91900C762`](https://worldscan.org/address/0x29fcB43b46531BcA003ddC8FCB67FFE91900C762)
      </td>
    </tr>

    <tr>
      <td>SafeProxyFactory</td>

      <td>
        [`0x4e1DCf7AD4e460CfD30791CCC4F9c8a4f820ec67`](https://worldscan.org/address/0x4e1DCf7AD4e460CfD30791CCC4F9c8a4f820ec67)
      </td>
    </tr>
  </tbody>
</table>

## Gnosis Modules

<table>
  <thead>
    <tr>
      <th>Contract</th>

      <th>
        World Chain Mainnet Address
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>TimeBasedAllowance Module</td>

      <td>
        [`0xa9bcF56d9FCc0178414EF27a3d893C9469e437B7`](https://worldscan.org/address/0xa9bcF56d9FCc0178414EF27a3d893C9469e437B7)
      </td>
    </tr>

    <tr>
      <td>4337 Module</td>

      <td>
        [`0x75cf11467937ce3F2f357CE24ffc3DBF8fD5c226`](https://worldscan.org/address/0x75cf11467937ce3F2f357CE24ffc3DBF8fD5c226)
      </td>
    </tr>

    <tr>
      <td>AddModules Helper</td>

      <td>
        [`0x4e1DCf7AD4e460CfD30791CCC4F9c8a4f820ec67`](https://worldscan.org/address/0x4e1DCf7AD4e460CfD30791CCC4F9c8a4f820ec67)
      </td>
    </tr>
  </tbody>
</table>

## Uniswap

<table>
  <thead>
    <tr>
      <th>Contract</th>

      <th>
        World Chain Mainnet Address
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>ApprovalSwap</td>

      <td>
        [`0xf4305dd6256dc2b0d07caaf2953688defbc86e9d`](https://worldscan.org/address/0xf4305dd6256dc2b0d07caaf2953688defbc86e9d)
      </td>
    </tr>

    <tr>
      <td>v3CoreFactoryAddress</td>

      <td>
        [`0x7a5028BDa40e7B173C278C5342087826455ea25a`](https://worldscan.org/address/0x7a5028BDa40e7B173C278C5342087826455ea25a)
      </td>
    </tr>

    <tr>
      <td>AddModules Helper</td>

      <td>
        [`0x091AD9e2e6e5eD44c1c66dB50e49A601F9f36cF6`](https://worldscan.org/address/0x091AD9e2e6e5eD44c1c66dB50e49A601F9f36cF6)
      </td>
    </tr>

    <tr>
      <td>Multicall2Address</td>

      <td>
        [`0x0a22c04215c97E3F532F4eF30e0aD9458792dAB9`](https://worldscan.org/address/0x0a22c04215c97E3F532F4eF30e0aD9458792dAB9)
      </td>
    </tr>

    <tr>
      <td>ProxyAdminAddress</td>

      <td>
        [`0x8B52DaCB7B5d9A959CDcD5419061c0eDD1296c29`](https://worldscan.org/address/0x8B52DaCB7B5d9A959CDcD5419061c0eDD1296c29)
      </td>
    </tr>

    <tr>
      <td>TickLensAddress</td>

      <td>
        [`0xE61df0CaC9d85876aCE5E3037005D80943570623`](https://worldscan.org/address/0xE61df0CaC9d85876aCE5E3037005D80943570623)
      </td>
    </tr>

    <tr>
      <td>NftDescriptorLibraryAddressV1\_3\_0</td>

      <td>
        [`0x38c68A1D60C47973EcE5bc1725B65D8Bec438192`](https://worldscan.org/address/0x38c68A1D60C47973EcE5bc1725B65D8Bec438192)
      </td>
    </tr>

    <tr>
      <td>
        NonfungibleTokenPositionDescriptorAddressV1\_3\_0
      </td>

      <td>
        [`0x70410a302c4a5c52C659b780941c947Abd437FeB`](https://worldscan.org/address/0x70410a302c4a5c52C659b780941c947Abd437FeB)
      </td>
    </tr>

    <tr>
      <td>DescriptorProxyAddress</td>

      <td>
        [`0xe6FcB4952b2d3Fab6DA4BC165831f5575e093feC`](https://worldscan.org/address/0xe6FcB4952b2d3Fab6DA4BC165831f5575e093feC)
      </td>
    </tr>

    <tr>
      <td>
        NonfungibleTokenPositionManagerAddress
      </td>

      <td>
        [`0xec12a9F9a09f50550686363766Cc153D03c27b5e`](https://worldscan.org/address/0xec12a9F9a09f50550686363766Cc153D03c27b5e)
      </td>
    </tr>

    <tr>
      <td>V3MigratorAddress</td>

      <td>
        [`0x9EBDdCBa71C9027E1eB45135672a30bcFEec9de3`](https://worldscan.org/address/0x9EBDdCBa71C9027E1eB45135672a30bcFEec9de3)
      </td>
    </tr>

    <tr>
      <td>V3StakerAddress</td>

      <td>
        [`0x053956ab1618EcaCc135Ebc18Fd7564979aD4295`](https://worldscan.org/address/0x053956ab1618EcaCc135Ebc18Fd7564979aD4295)
      </td>
    </tr>

    <tr>
      <td>QuoterV2Address</td>

      <td>
        [`0x10158D43e6cc414deE1Bd1eB0EfC6a5cBCfF244c`](https://worldscan.org/address/0x10158D43e6cc414deE1Bd1eB0EfC6a5cBCfF244c)
      </td>
    </tr>
  </tbody>
</table>

## Grants

<table>
  <thead>
    <tr>
      <th>Contract</th>

      <th>
        World Chain Mainnet Address
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>WLDGrant</td>

      <td>
        [`0x7DD5B6B5A574EFd452AC0cfE3e1B69384a03C6f9`](https://worldscan.org/address/0x7DD5B6B5A574EFd452AC0cfE3e1B69384a03C6f9?tab=contract)
      </td>
    </tr>

    <tr>
      <td>RecurringGrantDrop</td>

      <td>
        [`0x2c1Ca1FBbD5f28e5492Cc6bF8C4e8c57354eb162`](https://worldscan.org/address/0x2c1Ca1FBbD5f28e5492Cc6bF8C4e8c57354eb162?tab=contract)
      </td>
    </tr>

    <tr>
      <td>WLDGrantReservations</td>

      <td>
        [`0x3a00fe3254c94c4689cb5163c91ee501d942e710`](https://worldscan.org/address/0x3a00fE3254c94C4689CB5163c91Ee501D942E710?tab=contract)
      </td>
    </tr>

    <tr>
      <td>RecurringGrantDropReservations</td>

      <td>
        [`0xc2D270651cEF0AA3734c9A7fEaCd3b3B39e36e18`](https://worldscan.org/address/0xc2D270651cEF0AA3734c9A7fEaCd3b3B39e36e18?tab=contract)
      </td>
    </tr>

    <tr>
      <td>Grants4FirstBatch</td>

      <td>
        [`0xae3f204c75e46c27f66c843bc9f3bbd04a6374c5`](https://worldscan.org/address/0xaE3f204c75E46C27f66C843bC9F3Bbd04a6374c5?tab=contract)
      </td>
    </tr>

    <tr>
      <td>WLDVault</td>

      <td>
        [`0x14a028cC500108307947dca4a1Aa35029FB66CE0`](https://worldscan.org/address/0x14a028cC500108307947dca4a1Aa35029FB66CE0?tab=contract)
      </td>
    </tr>
  </tbody>
</table>

## MiniKit

<table>
  <thead>
    <tr>
      <th>Contract</th>

      <th>
        World Chain Mainnet Address
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>MinikitTransfer</td>

      <td>
        [`0x9CC547e0Ca60dC249Eea2d91Ba12F00C4ca12787`](https://worldscan.org/address/0x9CC547e0Ca60dC249Eea2d91Ba12F00C4ca12787?tab=contract)
      </td>
    </tr>
  </tbody>
</table>

## Account Abstraction

<table>
  <thead>
    <tr>
      <th>Contract</th>

      <th>
        World Chain Mainnet Address
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>Entrypoint v0.7</td>

      <td>
        [`0x0000000071727De22E5E9d8BAf0edAc6f37da032`](https://worldscan.org/address/0x0000000071727De22E5E9d8BAf0edAc6f37da032#code)
      </td>
    </tr>
  </tbody>
</table>

## Oracles

<table>
  <thead>
    <tr>
      <th>Contract</th>

      <th>
        World Chain Mainnet Address
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>WLD/USD</td>

      <td>
        [`0x8Bb2943AB030E3eE05a58d9832525B4f60A97FA0`](https://worldscan.org/address/0x8Bb2943AB030E3eE05a58d9832525B4f60A97FA0)
      </td>
    </tr>

    <tr>
      <td>ETH/USD</td>

      <td>
        [`0xe1d72a719171DceAB9499757EB9d5AEb9e8D64A6`](https://worldscan.org/address/0xe1d72a719171DceAB9499757EB9d5AEb9e8D64A6)
      </td>
    </tr>

    <tr>
      <td>BTC/USD</td>

      <td>
        [`0xdD91675235C37a47597c053807d61Da27Ae1AE6C`](https://worldscan.org/address/0xdD91675235C37a47597c053807d61Da27Ae1AE6C)
      </td>
    </tr>

    <tr>
      <td>USDC/USD</td>

      <td>
        [`0xF4301686AfF4eE36d70c718a9e62309b53862BE8`](https://worldscan.org/address/0xF4301686AfF4eE36d70c718a9e62309b53862BE8)
      </td>
    </tr>

    <tr>
      <td>ezETH/USD</td>

      <td>
        [`0x78ce3664d1582e14270092ea9817f111ac53524b`](https://worldscan.org/address/0x78ce3664d1582e14270092ea9817f111ac53524b#code)
      </td>
    </tr>
  </tbody>
</table>


# Resources
Source: https://docs.world.org/world-chain/resources



## Status Links

* [World Chain Mainnet Status](https://worldchain-mainnet-status.alchemy.com/)
* [World Chain Sepolia Status](https://worldchain-sepolia-status.alchemy.com/)

## Documentation

* [Brand Kit](https://world.org/press)
* [World Whitepaper](https://whitepaper.world.org/)

## Legal

* [Terms of Service](https://vault.pactsafe.io/s/8a18d792-fd76-44db-9b92-b0bb7981c248/legal.html#contract-byutjvtyt)
* [Privacy Policy](https://vault.pactsafe.io/s/8a18d792-fd76-44db-9b92-b0bb7981c248/legal.html#contract-s1ytru6kk)


# Token Bridging Guide
Source: https://docs.world.org/world-chain/tokens/bridging



## 1. Deploy your token on World Chain

Choose your preferred bridging framework and use it to deploy an ERC-20 for your token on World Chain.
We recommend using the framework provided by World Chain's [standard bridge contracts](https://github.com/ethereum-optimism/specs/blob/main/specs/protocol/bridges.md),
and deploying your token with the [OptimismMintableERC20Factory](/world-chain/developers/world-chain-contracts).
This deployment method offers guarantees that will streamline the approval process. If you opt for a different bridging framework,
it must be compatible with the standard bridge interface, or we may have difficulty supporting it.

## 2. Submit details for your token

Follow the instructions in the [GitHub repository](https://github.com/ethereum-optimism/ethereum-optimism.github.io) and submit a PR with the required details for your token.
You must specify a section for `worldchain-sepolia` and/or `worldchain` in your token's data.json file.
The submission is straightforward if your token is already listed on the Superchain token list.

## 3. Await final approval

The World team regularly reviews submissions, and you should receive a response within 24-72 hours, depending on whether the PR is submitted on a weekday, weekend, or holiday.


# Superchain Token Bridging (Coming Soon)
Source: https://docs.world.org/world-chain/tokens/superchain-token



<Note>
  The SuperchainERC20 standard will become the default standard for issuing tokens on the Superchain once the OP Stack Interop features are live on mainnet.
  Currently the [Superchain token bridging standard](https://github.com/ethereum-optimism/specs/blob/main/specs/interop/token-bridging.md) documentation is a work in progress, so please stay tuned.
</Note>

The [Superchain token bridging standard](https://github.com/ethereum-optimism/specs/blob/main/specs/interop/token-bridging.md) (`SuperchainERC20`) is a set of properties and an interface designed to enable ERC20 tokens
to be fungible across the Superchain using the official `SuperchainERC20Bridge`. This standard builds
upon the existing [ERC20 token standard](https://docs.openzeppelin.com/contracts/4.x/erc20) and implements the `ICrosschainERC20` interface, which includes
two key properties: only allowing the `SuperchainERC20Bridge` to call `crosschainMint` and `crosschainBurn` functions,
and ensuring the token is deployed at the same address on every chain in the Superchain.

The `SuperchainERC20Bridge` is a predeploy that works as an abstraction on top of the `L2ToL2CrossDomainMessenger` for token bridging.
It includes two main functions: `sendERC20`, which initiates a cross-chain transfer by burning tokens locally and sending a message
to the target chain, and `relayERC20`, which processes incoming messages and mints the corresponding amount of tokens on the destination
chain. This bridge utilizes the `L2ToL2CrossDomainMessenger` for replay protection, domain binding, and access to additional message information.

By implementing the `SuperchainERC20` standard, tokens can achieve fungibility across the Superchain while maintaining a trust-minimized bridging
solution. The standard's design ensures liquidity availability, which is fundamental to achieving fungibility, and removes the need for cross-chain
access control lists. Additionally, the standard allows for potential future enhancements, such as cross-chain transferFrom functionality and concatenated
actions for more complex cross-chain operations.


# USDC Quick Start
Source: https://docs.world.org/world-chain/tokens/usdc



USDC is a digital dollar issued by Circle, also known as a stablecoin, designed to represent US dollars on the internet and operate seamlessly across many of the world's leading blockchains, including World Chain. Backed 100% by highly liquid cash and cash-equivalent assets, USDC is always redeemable 1:1 for USD. Circle provides monthly attestation reports for USDC reserve holdings on its [Transparency page](https://www.circle.com/en/transparency).

On World Chain, USDC can be transferred using its token contract, enabling fast, secure, and programmable digital dollar transactions. This guide will walk you through building a simple script to perform your first USDC transaction on World Chain.

## Prerequisites

* Node.js (v16 or higher)
* npm or yarn

## Part 1: Setup up your project

### Step 1: Create a new project directory:

```bash theme={null}
mkdir usdc-world-transfer
cd usdc-world-transfer
npm init -y
```

### Step 2: Enable ES module support:

In your `package.json`, add the following line:

```json theme={null}
{
  "type": "module"
}
```

This allows you to use the modern ES module syntax (`import/export`) in your script.

**Tip:** Alternatively, you can use the following command to set `"type": "module"` directly:

### Step 3: Install required dependencies:

```bash theme={null}
npm install viem @inquirer/prompts
```

### Step 4: Create your script file:

Create a new file called `index.js`:

```bash theme={null}
touch index.js
```

## Part 2: Build the script

Open `index.js` and complete the following sections:

### Step 1: Import Dependencies

```javascript theme={null}
import { createWalletClient, http, formatEther, createPublicClient } from 'viem';
import { privateKeyToAccount, generatePrivateKey } from 'viem/accounts';
import { worldchainSepolia } from 'viem/chains';
import { input } from '@inquirer/prompts';
import fs from 'fs';
import path from 'path';
```

These imports include:

* `viem` for blockchain interactions
* `@inquirer/prompts` for interactive CLI prompts
* `fs` and `path` for saving private key backups

### Step 2: Define Constants

```javascript theme={null}
// USDC contract address on World Chain Sepolia
const USDC_CONTRACT = '0x66145f38cBAC35Ca6F1Dfb4914dF98F1614aeA88';
const USDC_DECIMALS = 6;
```

* `USDC_CONTRACT` is the address of the USDC token on World Chain Sepolia
* `USDC_DECIMALS` is the number of decimals used in USDC calculations

```javascript theme={null}
// USDC ABI (minimal for transfer)
const USDC_ABI = [
  {
    name: 'transfer',
    type: 'function',
    stateMutability: 'nonpayable',
    inputs: [
      { name: 'to', type: 'address' },
      { name: 'amount', type: 'uint256' }
    ],
    outputs: [{ name: '', type: 'bool' }]
  },
  {
    name: 'balanceOf',
    type: 'function',
    stateMutability: 'view',
    inputs: [{ name: 'account', type: 'address' }],
    outputs: [{ name: '', type: 'uint256' }]
  },
  {
    name: 'decimals',
    type: 'function',
    stateMutability: 'view',
    inputs: [],
    outputs: [{ name: '', type: 'uint8' }]
  }
];
```

The above ABI defines the minimum required functions for:

* Transferring USDC
* Checking USDC balance
* Getting USDC decimals

### Step 3: Add Helper Functions

```javascript theme={null}
async function generateWallet() {
  const privateKey = generatePrivateKey();
  const account = privateKeyToAccount(privateKey);
  return { privateKey, address: account.address };
}
```

```javascript theme={null}
async function savePrivateKeyBackup(sourceWallet, destinationWallet) {
  const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
  const backupDir = path.join(process.cwd(), 'backups');

  if (!fs.existsSync(backupDir)) {
    fs.mkdirSync(backupDir);
  }

  const backupFile = path.join(backupDir, `wallet-backup-${timestamp}.txt`);
  const content = `Wallet Backup (${timestamp})

Source Wallet:
Address: ${sourceWallet.address}
Private Key: ${sourceWallet.privateKey}

Destination Wallet:
Address: ${destinationWallet.address}
Private Key: ${destinationWallet.privateKey}

âš ï¸ IMPORTANT: Keep this file secure and delete it after use.
`;

  fs.writeFileSync(backupFile, content);
  return backupFile;
}
```

These functions:

* Generate new wallets
* Save them as JSON files for backup

### Step 4: Add Main Function

```javascript theme={null}
async function main() {
  try {
    console.log('\n1. Creating source wallet...');
    await input({ message: 'Press Enter to generate source wallet...' });
    const sourceWallet = await generateWallet();
    console.log('Source Address:', sourceWallet.address);
    await input({ message: 'Press Enter to continue...' });

    console.log('\n2. Creating destination wallet...');
    await input({ message: 'Press Enter to generate destination wallet...' });
    const destinationWallet = await generateWallet();
    console.log('Destination Address:', destinationWallet.address);
    await input({ message: 'Press Enter to continue...' });

    console.log('\n3. Saving wallet information...');
    const backupFile = await savePrivateKeyBackup(sourceWallet, destinationWallet);
    console.log('Backup saved to:', backupFile);

    console.log('\n4. Fund your source wallet:');
    console.log('Get testnet ETH from: https://www.alchemy.com/faucets/world-chain-sepolia');
    console.log('Get testnet USDC from: https://faucet.circle.com');
    console.log('Source Wallet Address:', sourceWallet.address);
    
    await input({ message: 'Press Enter after funding your wallet...' });

    console.log('\n5. Checking wallet balances...');
    const publicClient = createPublicClient({
      chain: worldchainSepolia,
      transport: http()
    });

    let ethBalance, usdcBalance;
    let isFunded = false;

    while (!isFunded) {
      ethBalance = await publicClient.getBalance({ address: sourceWallet.address });
      usdcBalance = await publicClient.readContract({
        address: USDC_CONTRACT,
        abi: USDC_ABI,
        functionName: 'balanceOf',
        args: [sourceWallet.address]
      });

      console.log('ETH Balance:', formatEther(ethBalance), 'ETH');
      console.log('USDC Balance:', Number(usdcBalance) / 10 ** USDC_DECIMALS, 'USDC');

      if (ethBalance === 0n || usdcBalance === 0n) {
        console.log('\nPlease fund your wallet with testnet ETH and USDC before proceeding.');
        await input({ message: 'Press Enter after funding your wallet...' });
      } else {
        isFunded = true;
      }
    }

    console.log('\n6. Ready to transfer USDC to Destination Address:', destinationWallet.address);
    const amount = await input({
      message: 'Enter amount of USDC to transfer:',
      validate: (value) => {
        const num = Number(value);
        if (isNaN(num) || num <= 0) return 'Please enter a valid positive number';
        if (num > Number(usdcBalance) / 10 ** USDC_DECIMALS) return 'Insufficient USDC balance';
        return true;
      }
    });

    const amountInDecimals = BigInt(Math.floor(Number(amount) * 10 ** USDC_DECIMALS));
    
    const walletClient = createWalletClient({
      account: privateKeyToAccount(sourceWallet.privateKey),
      chain: worldchainSepolia,
      transport: http()
    });

    console.log('\nExecuting transfer...');
    const hash = await walletClient.writeContract({
      address: USDC_CONTRACT,
      abi: USDC_ABI,
      functionName: 'transfer',
      args: [destinationWallet.address, amountInDecimals]
    });

    console.log('\nTransfer successful!');
    console.log('Transaction Hash:', hash);
    console.log('View on Explorer:', `https://sepolia.worldscan.org/tx/${hash}`);

  } catch (error) {
    console.error('\nError:', error.message);
  }
}

main();
```

This function drives the full flow to:

* Create wallets
* Back up credentials
* Prompt you to fund the source wallet
* Send USDC to the destination
* Print the transaction hash

## Part 3: Run the Script

Enter the following command:

```bash theme={null}
node index.js
```

Follow the prompts in your terminal.

## What This Script Does

1. Creates source and destination wallets
2. Saves wallet information securely
3. Prompts you to fund the source wallet
4. Transfers USDC between wallets
5. Displays the transaction hash and link to the explorer

## Important Notes

* Keep your private keys secure
* Delete backup files after use
* Always test with small amounts first
* This script uses World Chain Sepolia testnet, not mainnet


# Core Concepts
Source: https://docs.world.org/world-id/concepts

Core concepts behind World ID: proof of personhood, verification levels, and key terms for integrating verification.

World ID is built for easy integration, but here are a few core concepts that are helpful to understand before you start.

## Proof of Personhood

"Proof of Personhood" is distinct from many existing identity systems. It is a way to prove that a person is unique, without revealing any personal information. World ID is not KYC, and it does not disclose your identity or previous actions to anyone.

World ID supports multiple "Verification Levels" to prove that a person is a unique human. These levels provide different degrees of humanness assurance, accessibility, and protection against fraud.

| Verification Level                                                   | <span>Humanness Level</span> | Description                                                                                                                                                 |
| :------------------------------------------------------------------- | :--------------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------- |
| <div><img alt="Orb+" /><span>Orb+</span></div>                       | Very Strong                  | \[Coming soon] Orb verification, plus authentication which verifies the person using World ID is the legitimate holder.                                     |
| <div><img alt="Orb" /><span>Orb</span></div>                         | Strong                       | Biometric verification, uniqueness through iris ([details](https://world.org/blog/engineering/opening-orb-look-inside-worldcoin-biometric-imaging-device)). |
| <div><img alt="Secure Document" /><span>Secure Document</span></div> | High                         | Document verification eg. Passport with security chip verification                                                                                          |
| <div><img alt="Document" /><span>Document</span></div>               | High                         | Document verification eg. Passport                                                                                                                          |
| <div><img alt="Device" /><span>Device</span></div>                   | Medium                       | Unique mobile device check.                                                                                                                                 |

## Vocabulary

Some terms are used throughout the World ID documentation. Here are a few of the most important ones:

* **World ID**: A user's self-custodial identity, as well as the name of the protocol.
* **App ID**: The ID of your app that is assigned in our [Developer Portal](https://developer.worldcoin.org/).
* **Action**: A developer-facing primitive that lets you put any app operation behind a unique-human gate. An app can have one or more actions depending on your use case.
* **Zero-Knowledge Proof (ZKP)**: A cryptographic method to prove that a statement is true without revealing any information about the statement itself. World ID uses ZKPs to prove that a user is verified without revealing the user's identity.
* **Nullifier Hash**: A component of the World ID ZKP; a unique identifier for a combination of a user, `app_id`, and `action`.
* **Signal**: A component of the World ID ZKP; data attached to the proof that cannot be tampered with. An example may be a user's choice for an election.
* **Merkle Root**: A component of the World ID ZKP; The root of the [Merkle Tree](https://en.wikipedia.org/wiki/Merkle_tree) that identity commitments are inserted to.

It's important to note the difference between the two types of verification, depending on the context:

* **Orb/Passport Verification**: A user's identity can be verified through either an Orb, Device or Passport and their identity commitment is then recorded on the blockchain.
* **Proof Verification**: The process of validating a user's Zero-Knowledge Proof (ZKP) either off-chain via a REST endpoint we host or on-chain using our Smart Contracts.


# Cloud Verification
Source: https://docs.world.org/world-id/id/cloud

Verify World ID proofs in your backend using the Developer Portal API; hashing signals, REST endpoints, and request examples.

After receiving the user's proof from IDKit, you must verify it in your backend. Cloud Verification is a solution hosted in our Developer Portal to make this easier for you.

## Optional: Hashing the signal

In you backend you need to hash the signal passed in the IDKit. If you want to implement the hashing yourself you need to use `keccak256` hash function and 64 minimum padding. Take a look at how we implemented it [here](https://github.com/worldcoin/idkit-js/blob/main/packages/core/src/lib/hashing.ts).

```javascript title="IDKit Core" theme={null}
import { hashToField } from "@worldcoin/idkit-core/hashing";

const signalHash = hashToField("my_signal");
```

## Rest Endpoint

Find the full API reference [here](/world-id/reference/api#verify-proof).

```bash title="cURL" theme={null}
curl -X POST "/api/v2/verify/{app_id}" \
    -H "Content-Type: application/json" \
    -d '{
        "nullifier_hash": "0x2bf8406809dcefb1486dadc96c0a897db9bab002053054cf64272db512c6fbd8",
        "merkle_root": "0x2264a66d162d7893e12ea8e3c072c51e785bc085ad655f64c10c1a61e00f0bc2",
        "proof": "0x1aa8b8f3b2d2de5ff452c0e1a83e29d6bf46fb83ef35dc5957121ff3d3698a1119090fb...",
        "verification_level": "orb",
        "action": "my_action",
        "signal_hash": "hashed_signal" // optional: only add this parameter if you added a custom signal
    }'
```


# Design Guidelines
Source: https://docs.world.org/world-id/id/design-guidelines



## Figma Library

<a href="https://www.figma.com/design/XmNRhspQ3Gfsze5WRjV1PB/ID-Kit-Library?node-id=1-213&t=73AKSDqCV4ZXrGRH-1">
  <div>
    <div>
      <svg>
        <path />

        <path />

        <path />

        <path />
      </svg>
    </div>

    <div>
      <h3>
        ID Kit Figma Library
      </h3>

      <p>
        Access design components and templates for World ID integration
      </p>
    </div>
  </div>

  <svg>
    <path />
  </svg>
</a>

## **Core structure:**

* **World ID logo**
* **Partner logo** (Optional)
* **Title:** "Connect your World ID"
* **Description:** "Scan the QR code to connect your World ID"
* **QR code container** (central and prominent)
* **Footer:** "Terms & Privacy" link
* **Dismiss (X)** icon for closing the modal or window

**Note:** The QR code is dynamically generated and time-limited. Always ensure it's up to date.

## Customization Guidelines

**âœ… Partners may:**

* Adjust **typography** to match brand styles, but retain clear hierarchy (title > body)
* Modify **corners or shadows** to match their brand
* Modify **colors**, so long as contrast and accessibility are preserved
* Customize **container shape** (e.g., rounded corners) and **shadow**
* Add a **light/dark mode** toggle or theme-matching behavior
* Localize the **copy if needed** (preferably keeping semantic structure)
* Add their **brand logo** above the title

**âŒ Partners must not:**

* Remove or replace the **World ID logo**
* Alter or obscure the **QR code**
* Change the **copy** in a way that misrepresents World ID
* Make the QR code **too small**

## Size & Spacing

<table>
  <thead>
    <tr>
      <th>Element</th>
      <th>Recommendation</th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>QR Code</td>
      <td>Minimum 160 x 160px</td>
    </tr>

    <tr>
      <td>Padding</td>
      <td>Min. 24px all sides</td>
    </tr>

    <tr>
      <td>Logo size</td>
      <td>32-48px width</td>
    </tr>

    <tr>
      <td>Font (title)</td>
      <td>Minimum 16px</td>
    </tr>

    <tr>
      <td>Font (description)</td>
      <td>Minimum 14px</td>
    </tr>
  </tbody>
</table>

### **Accessibility checklist:**

* QR code must meet minimum sizing for easy scanning
* All text must meet WCAG AA contrast
* Modal should be **keyboard-navigable** and screen-reader friendly
* "Terms & Privacy" must be a focusable link

### Behavior checklist

* Modal should open centered and dim the background
* Auto-refresh or invalidate QR code after a set time (e.g., 5 mins)
* Optional callback/event on QR scan success
* X button should close the modal gracefully

## States

**Default** Waiting for user to scan the QR code

<img alt="Default state - Waiting for user to scan the QR code" />

**Success** - Successful connection

<img alt="Success - Successful connection" />

**Request canceled** - User manually canceled request in World App

<img alt="Request canceled - User manually canceled request in World App" />

**Connection lost** - Lost connection to server or user offline

<img alt="Connection lost - Lost connection to server or user offline" />

**Error** - Generic technical error or proof failure

<img alt="Error - Generic technical error or proof failure" />

### Partnership example

<img alt="Partnership example" />

## Verified Human Badge

The **Human Verified Badge** signals that an account or user has been verified as a unique human via **World ID**. It builds trust, improves authenticity, and can be embedded into products across industries (social, gaming, commerce, identity, etc.).

<a href="https://www.figma.com/design/XmNRhspQ3Gfsze5WRjV1PB/ID-Kit-Library?node-id=1-216">
  <div>
    <img alt="Human Verified Badge" />
  </div>

  <div>
    <h3>
      Human Badge Figma Assets
    </h3>

    <p>
      Access all badge variants, sizes, and implementation guidelines for the
      Human Verified Badge
    </p>

    <div>
      Open in Figma

      <svg>
        <path />
      </svg>
    </div>
  </div>
</a>

***

## Badge design

* Symbol: World icon
* Label: human in lowercase, optionally styled in pill or badge form

### **Variants:**

* **Icon-only:** For dense UI like leaderboards or tooltips
* **Icon + label:** Preferred for public profiles, social posts, and player cards

### Do:

* Keep badge **small, clear, unobtrusive**
* Always pair with or near a user identity (e.g. username, avatar)
* Use consistent shape and padding

### Don't:

* Overstyle or animate
* Replace or remix copy ("real human", "verified user", etc.)
* Add misleading hierarchy (e.g. badge > blue check)

***

## Placement guidelines

<table>
  <thead>
    <tr>
      <th>Content</th>
      <th>Placement</th>
      <th>Format</th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>Social profiles</td>
      <td>Below or beside username / bio</td>
      <td>Icon + label</td>
    </tr>

    <tr>
      <td>Gaming profiles</td>
      <td>Under character name or stats</td>
      <td>Icon + label</td>
    </tr>

    <tr>
      <td>Leaderboards</td>
      <td>Right of username</td>
      <td>Icon + label</td>
    </tr>

    <tr>
      <td>Messaging/chat</td>
      <td>Right of username</td>
      <td>Icon + label</td>
    </tr>

    <tr>
      <td>Account dashboards</td>

      <td>
        Near user ID, next to login method, etc.
      </td>

      <td>Icon + label</td>
    </tr>
  </tbody>
</table>

## Theming & Branding

**âœ… Partners may:**

* Adapt badge color to suit **light/dark mode**

**âŒ Partners must not:**

* Remove or replace the word human
* Use verification outside of actual World ID-verified users
* Make it look like a World ID badge gives higher permissions than intended
* Change the logo shape

## Rules checklist

### **Layout and Visual**

* Correct badge asset used
* Logo is not distorted, recolored or modified
* Minimum height is respected

### Placement

* Placed directly next to or below user, display name, or avatar
* Badge is not visually grouped with unrelated badges
* Badge does not imply special privileges unless defined


# Getting Started
Source: https://docs.world.org/world-id/id/getting-started

Get started integrating World ID with IDKit: create an app, collect proofs on web/mobile, and verify in Cloud or on-chain.

We created the IDKit libraries, to help you integrate World ID into your app in 3 simple steps:

1. Create an application in our [Developer Portal](http://developer.worldcoin.org/)
2. Retrieve user's verification proof using an IDkit library
3. Verify the proof

# Step 1: Create an application in the Developer Portal

When you create your application you'll choose **External** as the integration type. External apps use IDKit to collect proofs from your end-users and return them to your backend for verification.

### Decide upfront

1. **Environment**\
   â€¢ **Production** â€“ Real Human World IDs.\
   â€¢ **Staging / Development** â€“ internal testing against the test identities.

2. **Verification target**\
   â€¢ **Cloud** â€“ verify proofs via a REST endpoint.\
   â€¢ **On-chain** â€“ verify proofs directly inside a smart contract.

Once you create the application you'll need to create an incognito action.

# Step 2: Retrieve a proof with IDKit

IDKit is available for multiple runtimes so you can collect proofs wherever your users are:

<table>
  <thead>
    <tr>
      <th>Platform</th>
      <th>Docs</th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>Web (React)</td>

      <td>
        <a href="./web-react">Integrate on the web</a>
      </td>
    </tr>

    <tr>
      <td>Web (Vanilla)</td>

      <td>
        <a href="./web-vanilla">Integrate on the web</a>
      </td>
    </tr>

    <tr>
      <td>Mobile (React Native, Swift, Kotlin)</td>

      <td>
        <a href="./mobile">Integrate on mobile</a>
      </td>
    </tr>
  </tbody>
</table>

<Note>Find a full list of supported SDKs [here](./libraries)</Note>

Regardless of the platform the flow is the same:

1. Initiate a verification session with a minimum `verification_level`
2. User will be redirect or prompted to use the World App
3. When the user succeeds you receive a **proof object** containing `merkle_root`, `nullifier_hash`, `proof`, and the user's `verification_level`.

```json title="ISuccessResult" theme={null}
{
  "merkle_root": "0x1f38b57f3bdf96f05ea62fa68814871bf0ca8ce4dbe073d8497d5a6b0a53e5e0",
  "nullifier_hash": "0x0339861e70a9bdb6b01a88c7534a3332db915d3d06511b79a5724221a6958fbe",
  "proof": "0x063942fd7ea1616f17787d2e3374c1826ebcd2d41d2394...",
  "verification_level": "orb"
}
```

<Warning>
  Retrieving the proof is not enough. You must verify the proof in Step 3 to
  prevent replay attacks. Without verification, your application could be
  vulnerable to malicious actors reusing old proofs.
</Warning>

# Step 3: Verify the proof

Choose where you want to verify proofs:

<table>
  <thead>
    <tr>
      <th>Target</th>
      <th>Recommended when</th>
      <th>Docs</th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>Cloud verifier</td>

      <td>
        You already maintain a backend server and prefer a simple REST call
      </td>

      <td>
        <a href="./cloud">Verify via REST</a>
      </td>
    </tr>

    <tr>
      <td>On-chain verifier</td>

      <td>
        You need trust-minimized verification inside a smart contract
      </td>

      <td>
        <a href="./on-chain">Verify on-chain</a>
      </td>
    </tr>
  </tbody>
</table>

<Note>
  Cloud verifications from the Developer portal automatically handle
  sybil-resistance for you, ensuring that a user cannot perform the same action
  more than a set amount. If you want to verify proofs on-chain you need to
  handle this, more details [here](./on-chain)
</Note>


# Libraries
Source: https://docs.world.org/world-id/id/libraries



World ID is available on a variety of platforms. Below is a list of native libraries we currently support.

<table>
  <thead>
    <tr>
      <th>Library</th>
      <th>Description</th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        <a href="https://www.npmjs.com/package/@worldcoin/idkit">React</a>
      </td>

      <td>
        Our most popular library. Integrate easily into any React app
      </td>
    </tr>

    <tr>
      <td>
        <a href="https://www.npmjs.com/package/@worldcoin/idkit-standalone">
          JS
        </a>
      </td>

      <td>
        Standalone version for vanilla javascript.
      </td>
    </tr>

    <tr>
      <td>
        <a href="https://www.npmjs.com/package/@worldcoin/idkit-react-native">
          React Native
        </a>
      </td>

      <td>React Native library.</td>
    </tr>

    <tr>
      <td>
        <a href="https://swiftpackageindex.com/worldcoin/idkit-swift">Swift</a>
      </td>

      <td>Native Swift library for IOS apps.</td>
    </tr>

    <tr>
      <td>
        <a href="https://crates.io/crates/idkit">Rust</a>
      </td>

      <td>
        Rust library. Use this to compile other native binaries, eg. Kotlin.
      </td>
    </tr>

    <tr>
      <td>
        <a href="https://github.com/worldcoin/idkit-kotlin/packages/2232016">
          Kotlin
        </a>
      </td>

      <td>
        Native Kotlin library for Android apps
      </td>
    </tr>
  </tbody>
</table>


# Integrate on mobile
Source: https://docs.world.org/world-id/id/mobile

Add World ID to mobile apps using React Native, Swift, or Kotlin: create sessions, redirect to World App, poll status, and verify proofs.

All of the mobile SDKs follow the same logic:

1. Initiate a session
2. Redirect the user using the session url
3. Poll the session
4. Verify the proof in your Backend

Choose the SDK you want to use:

* [Swift](https://swiftpackageindex.com/worldcoin/idkit-swift)
* [Kotlin](https://github.com/worldcoin/idkit-kotlin/packages/2232016)
* [React Native](https://www.npmjs.com/package/@worldcoin/idkit-react-native)

## Initiating a Session

<CodeGroup>
  ```javascript title="React Native" theme={null}
  const session = await new Session().create('app_id', 'your-action', {
  	bridge_url: undefined, // Optional: URL to a custom bridge
  	verification_level: VerificationLevel.Orb, // Optional: Minimum verification level
  })
  ```

  ```kotlin title="Kotlin" theme={null}
  val session = Session.create(
      appID = AppID("app_id"),
      action = "your-action"
  )
  ```

  ```swift title="Swift" theme={null}
  let session = try await Session(AppID("app_id"), action: "your-action")
  ```
</CodeGroup>

# Redirect user

Use the session url to redirect the user to the World App.

<Note>
  You can add a `return_to` query param to the session url, to redirect the user
  back to your app. Make sure you handle the deeplink correctly when the user
  get's redirect back to the app.
</Note>

<CodeGroup>
  ```javascript title="React Native" theme={null}
  const sessionUrl = session.sessionURI
  ```

  ```kotlin title="Kotlin" theme={null}
  val sessionUrl = session.connectUrl
  ```

  ```swift title="Swift" theme={null}
  let session_url = session.connect_url
  ```
</CodeGroup>

## Poll session status

<CodeGroup>
  ```javascript title="React Native" theme={null}
  const checkStatus = async () => {
  	const status = await session.status()

      if (status.state === VerificationState.Confirmed) {
      	console.log('Verification successful:', status.result)
      } else if (status.state === VerificationState.Failed) {
      	console.log('Verification failed:', status.errorCode)
      }

  }

  // Poll every second
  setTimeout(checkStatus, 1000)

  ```

  ```kotlin title="Kotlin" theme={null}
  session.status().collect { status ->
          when (status) {
              is Status.WaitingForConnection -> {
                  println("Waiting for the user to scan the QR Code")
              }
              is Status.AwaitingConfirmation -> {
                  println("Awaiting user confirmation")
              }
              is Status.Confirmed -> {
                  println("Got proof: ${status.proof}")
              }
              is Status.Failed -> {
                  println("Got error: ${status.error.message}")
              }
          }
      }
  ```

  ```swift title="Swift" theme={null}
  for try await status in session.status() {
  	switch status {
  		case .waitingForConnection:
  			print("Waiting for the user to scan the QR Code")
  		case .awaitingConfirmation:
  			print("Awaiting user confirmation")
  		case let .confirmed(proof):
  			print("Got proof: \(proof)")
  		case let .failed(error):
  			print("Got error: \(error.localizedDescription)")
  	}
  }
  ```
</CodeGroup>

## Verify the proof

If the session was successful, you will get the proof result:

```json title="Result" theme={null}
{
  "merkle_root": "0x1f38b57f3bdf96f05ea62fa68814871bf0ca8ce4dbe073d8497d5a6b0a53e5e0",
  "nullifier_hash": "0x0339861e70a9bdb6b01a88c7534a3332db915d3d06511b79a5724221a6958fbe",
  "proof": "0x063942fd7ea1616f17787d2e3374c1826ebcd2d41d2394...",
  "verification_level": "orb"
}
```

<Warning>
  Retrieving a successful proof doesn't mean the user is verified you need to
  validate this proof in a backend server.
</Warning>

Depending on your needs you can verify the proof:

* In the [cloud](./cloud) using Developer Portal API (Easiest)
* On [chain](./on-chain) using our Solidity SDK


# On-Chain Verification
Source: https://docs.world.org/world-id/id/on-chain

Verify World ID proofs fully on-chain: configure IDKit, use World ID Router, compute hashes, and add sybil resistance.

World ID proofs can be fully verified on-chain. After all, the source of truth for the decentralized protocol is on-chain. To verify a World ID proof, your smart contract will embed a call to the `verifyProof` method of the World ID contract, and then execute the rest of its logic as usual.

The [smart contract starter kit](https://github.com/worldcoin/world-id-onchain-template) and the [frontend & on-chain monorepo template](https://github.com/worldcoin/world-id-onchain-template) are great resources to help you get started with World ID.
Using one of these repositories is strongly recommended to get started with World ID on-chain.

The following examples demonstrate the most common use case: verifying proofs from only Orb-verified users, for a single action, with a user's wallet address as the signal, while also enabling sybil-resistance.

This setup is recommended for most users, as it is the most gas-efficient. For more information on use cases that require more complex setups (such as multiple actions or other types of signals), see the [Advanced On-Chain Verification](/world-id/id/on-chain) page.

<Note>
  At the core of the World ID Protocol is the use of
  [Semaphore](https://docs.semaphore.pse.dev/). Semaphore is a zk-SNARK based
  privacy protocol that allows for the creation of anonymous credential systems
  developed by the Ethereum Foundation. Read more about [The
  Protocol](https://whitepaper.world.org/#world-network-protocol) and
  [Semaphore](https://docs.semaphore.pse.dev/).
</Note>

## IDKit Configuration

When verifying proofs on-chain, there are a few changes you have to make to your IDKit configuration. You must ensure that the app created in the Developer Portal is configured as an on-chain app, and you should only accept Orb credentials in IDKit, as World ID Device is not currently supported on-chain.

```tsx theme={null}
import { IDKitWidget } from '@worldcoin/idkit'

const { address } = useAddress() // get the user's wallet address

<IDKitWidget
    app_id="app_GBkZ1KlVUdFTjeMXKlVUdFT" // must be an app set to on-chain in Developer Portal
    action="claim_nft"
    signal={address} // proof will only verify if the signal is unchanged, this prevents tampering
    onSuccess={onSuccess} // use onSuccess to call your smart contract
    // no use for handleVerify, so it is removed
    // use default verification_level (orb-only), as device credentials are not supported on-chain
>
    {({ open }) => <button onClick={open}>Verify with World ID</button>}
</IDKitWidget>
```

## Contract Addresses

The World ID Router contract is what you should use to verify proofs. It is deployed on multiple chains, and you can find the addresses for each chain in our contracts [Address Book](/world-id/reference/contract-deployments).

## `hashToField` Helper Function

Our contracts use a custom hash function that returns a `uint256` that is guaranteed to be in the field of the elliptic curve we use. This is necessary to ensure that the `uint256` returned by the hash function can be used in our zero-knowledge proofs.

```solidity theme={null}
library ByteHasher {
	/// @dev Creates a keccak256 hash of a bytestring.
	/// @param value The bytestring to hash
	/// @return The hash of the specified value
	/// @dev `>> 8` makes sure that the result is included in our field
	function hashToField(bytes memory value) internal pure returns (uint256) {
		return uint256(keccak256(abi.encodePacked(value))) >> 8;
	}
}
```

To use this function, simply import the `ByteHasher` library and call `hashToField` on your bytestring.

```solidity theme={null}
import { ByteHasher } from './helpers/ByteHasher.sol';

contract HelloWorld {
	using ByteHasher for bytes;
	// {...}
	abi.encodePacked('hello world').hashToField(); // returns the keccak256 hash of 'hello world' as a uint256
	// {...}
```

## Constructor

The `externalNullifier` is the unique identifier of the action performed in Semaphore, and its keccak256 hash (named `externalNullifierHash`) is what is passed to the World ID Router contract. It is a combination of the app ID and the action.
You should typically set it in the constructor to save gas (as is done in this example), as it will not change if all users are performing the same action.

We additionally set the `groupId` to `1`, which limits this example to Orb-verified users only. World ID Device is currently not supported on-chain.

```solidity theme={null}
/// @dev This allows us to use our hashToField function on bytes
using ByteHasher for bytes;

/// @notice Thrown when attempting to reuse a nullifier
error InvalidNullifier();

/// @dev The address of the World ID Router contract that will be used for verifying proofs
IWorldID internal immutable worldId;

/// @dev The keccak256 hash of the externalNullifier (unique identifier of the action performed), combination of appId and action
uint256 internal immutable externalNullifierHash;

/// @dev The World ID group ID (1 for Orb-verified)
uint256 internal immutable groupId = 1;

/// @dev Whether a nullifier hash has been used already. Used to guarantee an action is only performed once by a single person
mapping(uint256 => bool) internal nullifierHashes;

/// @param _worldId The address of the WorldIDRouter that will verify the proofs
/// @param _appId The World ID App ID (from Developer Portal)
/// @param _actionId The World ID Action (from Developer Portal)
constructor(
    IWorldID _worldId,
    string memory _appId,
    string memory _action
) {
    worldId = _worldId;
    externalNullifierHash = abi
        .encodePacked(abi.encodePacked(_appId).hashToField(), _action)
        .hashToField();
}
```

<Note>
  On-chain verification will succeed for **7 days** after a proof is created.
</Note>

## verifyProof

The `verifyProof` method reverts if the proof is invalid, meaning you can just call it as part of your smart contract's logic and execute the rest of your logic after as usual.

<Warning>
  Note that calling the `verifyProof` function by itself does not provide
  sybil-resistance, or prevent proof reuse -- it just verifies that the proof is
  valid. However, this example **does** implement sybil-resistance by checking
  that the `nullifierHash` has not been verified before.
</Warning>

The `verifyProof` method takes the arguments below.

* `root` - The World ID root to verify against. This is obtained from the IDKit widget, and should be passed as-is.
* `groupId` - This must be `1` for Orb-verified users. World ID Device is currently not supported on-chain.
* `signalHash` - The keccak256 hash of the signal to verify.
* `nullifierHash` - Anonymous user ID for this action. This is obtained from the IDKit widget, and should just be passed as-is.
* `externalNullifierHash` - The externalNullifierHash, which identifies which app and action the user is verifying for.
* `proof` - The proof to verify. This is obtained from the IDKit widget.

```solidity theme={null}
/// @param signal An arbitrary input from the user that cannot be tampered with. In this case, it is the user's wallet address.
/// @param root The root (returned by the IDKit widget).
/// @param nullifierHash The nullifier hash for this proof, preventing double signaling (returned by the IDKit widget).
/// @param proof The zero-knowledge proof that demonstrates the claimer is registered with World ID (returned by the IDKit widget).
/// @param externalNullifierHash The externalNullifierHash, which identifies which app and action the user is verifying for.
function verifyAndExecute(
    address signal,
    uint256 root,
    uint256 nullifierHash,
    uint256[8] calldata proof
) public {
    // First, we make sure this person hasn't done this before
    if (nullifierHashes[nullifierHash]) revert InvalidNullifier();

    // We now verify the provided proof is valid and the user is verified by World ID
    worldId.verifyProof(
        root,
        groupId, // set to "1" in the constructor
        abi.encodePacked(signal).hashToField(),
        nullifierHash,
        externalNullifierHash,
        proof
    );

    // We now record the user has done this, so they can't do it again (sybil-resistance)
    nullifierHashes[nullifierHash] = true;

    // Finally, execute your logic here, knowing the user is verified
}
```

<Note>
  All arguments are of type `uint256`, with the exception of `proof`, which is of type `uint256[8]`. Depending on how you're calling your smart contract, you might be required to unpack it into a `uint256[8]` before passing it to the verifyProof method. To unpack it, use the following code:

  <CodeGroup>
    ```ts viem theme={null}
    import { decodeAbiParameters } from 'viem'

    const unpackedProof = decodeAbiParameters([{ type: 'uint256[8]' }], proof)[0]

    ```

    ```ts ethers.js theme={null}
    import { defaultAbiCoder as abi } from '@ethers/utils'

    const unpackedProof = abi.decode(['uint256[8]'], proof)[0]
    ```
  </CodeGroup>
</Note>


# Common Pitfalls
Source: https://docs.world.org/world-id/id/pitfalls



## Not Verifying Proofs

When using Incognito Actions, it's important to **always verify the proof received from IDKit.** This proof is a *claim* that the user has been verified by World ID, and verifying that proof with our API or smart contracts is the only way to ensure that the claim is true.

## Improper Signal (Proof fails verification)

If you specify a signal as an input to IDKit, ensure you include the same signal when verifying the proof with our API or smart contracts. Otherwise, the proof will not verify.

## Compilation/Runtime Errors

IDKit must be run client-side. Ensure that your frontend framework isn't attempting to render IDKit server-side.


# Testing
Source: https://docs.world.org/world-id/id/testing



To test your integration, we provide the [Worldcoin Simulator](https://simulator.worldcoin.org) to simulate a user using World App in a staging environment.

You can use the simulator from another browser tab and copy the QR code from IDKit with a single click:

<div>
  <video>
    <source type="video/mp4" />

    Your browser does not support the video tag.
  </video>
</div>

And then paste the QR code data into the simulator:

<div>
  <video>
    <source type="video/mp4" />

    Your browser does not support the video tag.
  </video>
</div>

You should see a successful outcome in IDKit!

<div>
  <video>
    <source type="video/mp4" />

    Your browser does not support the video tag.
  </video>
</div>

### Verifying the Proof in the Backend

After receiving the proof from IDKit, it's crucial to verify it on your backend to ensure its authenticity. This step is often overlooked but is essential for security. Make sure to implement the verification logic in your server-side code to validate the proof before proceeding with any user actions.


# Integrate on web (React)
Source: https://docs.world.org/world-id/id/web-react

Integrate World ID on React using IDKitWidget and Session API; install, verify proofs, and handle callbacks.

For react integrations, we support 2 paths:

* [**Widget**](#idkitwidget): A plug-and-play widget that handles UI/State management for you. Find an example [here](https://github.com/worldcoin/idkit-js/tree/main/examples/with-next)
* [**Session API**](#session-hook): A react hook that gives you total control of the user journey and UI/State management. Find an example [here](https://github.com/worldcoin/idkit-js/tree/main/examples/with-session).

## Install

<CodeGroup>
  ```bash npm theme={null}
  npm i @worldcoin/idkit
  ```

  ```bash pnpm theme={null}
  pnpm i @worldcoin/idkit
  ```

  ```bash yarn theme={null}
  yarn add @worldcoin/idkit
  ```
</CodeGroup>

## IDKitWidget

First, add the `IDKitWidget` component to your site. The values for the `app_id` and `action` props were obtained from the Developer Portal in [Getting Started](/world-id/id/getting-started). We'll define the `handleVerify` and `onSuccess` callbacks next.

```tsx title="/verify.tsx" theme={null}
"use client"; // for Next.js app router
import {
  IDKitWidget,
  VerificationLevel,
  ISuccessResult,
} from "@worldcoin/idkit";

// ...
<IDKitWidget
  app_id="your app id" // obtained from the Developer Portal
  action="your action id" // obtained from the Developer Portal
  onSuccess={onSuccess} // callback when the modal is closed
  handleVerify={handleVerify} // callback when the proof is received
  verification_level={VerificationLevel.Orb}
>
  {({ open }) => (
    // This is the button that will open the IDKit modal
    <button onClick={open}>Verify with World ID</button>
  )}
</IDKitWidget>;
```

### handleVerify

The `handleVerify` callback is called when the user's proof is received. This will send the proof to your backend for verification:

```tsx title="/verify.tsx" theme={null}
const handleVerify = async (proof: ISuccessResult) => {
  const res = await fetch("/api/verify", {
    // route to your backend will depend on implementation
    method: "POST",
    headers: {
      "Content-Type": "application/json",
    },
    body: JSON.stringify(proof),
  });
  if (!res.ok) {
    throw new Error("Verification failed."); // IDKit will display the error message to the user in the modal
  }
};
```

### Verifying the proof

The `handleVerify` callback sends the proof to your backend for verification. In the backend handler should verify the proof with the Developer Portal API:

<Warning>
  The call to the Developer Portal API must be made server-side to avoid [man in
  the middle attacks](https://en.wikipedia.org/wiki/Man-in-the-middle_attack).
</Warning>

```tsx title="/api/verify.ts" theme={null}
import { type IVerifyResponse, verifyCloudProof } from "@worldcoin/idkit-core";

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  const proof = req.body;
  const app_id = process.env.APP_ID;
  const action = process.env.ACTION_ID;
  const verifyRes = (await verifyCloudProof(
    proof,
    app_id,
    action
  )) as IVerifyResponse;

  if (verifyRes.success) {
    // This is where you should perform backend actions if the verification succeeds
    // Such as, setting a user as "verified" in a database
    res.status(200).send(verifyRes);
  } else {
    // This is where you should handle errors from the World ID /verify endpoint.
    // Usually these errors are due to a user having already verified.
    res.status(400).send(verifyRes);
  }
}
```

<Note>
  If you want to verify the proof onchain read more about it [here](./on-chain).
</Note>

### onSuccess

The `onSuccess` callback is called when the user closes the modal. This is where you can perform any necessary actions, such as redirecting the user to a new page.

```tsx title="/verify.tsx" theme={null}
const onSuccess = () => {
  // This is where you should perform any actions after the modal is closed
  // Such as redirecting the user to a new page
  window.location.href = "/success";
};
```

## Session Hook

First, setup the session hook with your configuration:

```tsx title="/verify.tsx" theme={null}
const { status, sessionURI, result, errorCode } = useSession({
  app_id: "your app id",
  action: "your action id",
});
```

After that you need to handle the following possible statuses:

* **WaitingForConnection**: Display the `sessionURI` to the user eg. with a QR code
* **Confirmed**: Session ended successfully, now you **must** verify the `result` proof in your backend.
* **Failed**: Session failed, check `errorCode`


# Integrate on web (Vanilla)
Source: https://docs.world.org/world-id/id/web-vanilla

Use IDKit Standalone to add World ID verification to vanilla JavaScript apps with Widget or Session API.

For standalone web integrations, we support 2 paths:

* [**Widget**](#idkitwidget): A plug-and-play widget that handles UI/State management for you.
* [**Session API**](#session-api): An API that gives you total control of the user journey and UI/State management.

For full examples check out this [repo](https://github.com/worldcoin/idkit-js/tree/main/examples/with-html).

## Install

<CodeGroup>
  ```bash npm theme={null}
  npm i @worldcoin/idkit-standalone
  ```

  ```bash pnpm theme={null}
  pnpm i @worldcoin/idkit-standalone
  ```

  ```bash yarn theme={null}
  yarn add @worldcoin/idkit-standalone
  ```
</CodeGroup>

## IDKitWidget

A plug-and-play widget that handles UI and state management automatically. Initialize once, then call `open()` to show the verification modal.

```javascript theme={null}
import "@worldcoin/idkit-standalone";

// Initialize the widget
IDKit.init({
  app_id: "app_ce4cb73cb75fc3b73b71ffb4de178410",
  action: "test-action",
  signal: "user_12345",
  action_description: "Verify your World ID",
  verification_level: "orb",
  handleVerify: async (response) => {
    // Verify the proof on your backend
    const verifyRes = await fetch("/api/verify", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(response),
    });
    if (!verifyRes.ok) throw new Error("Verification failed");
  },
  onSuccess: (response) => {
    console.log("Verification successful:", response);
  },
});

// Trigger verification
await IDKit.open();
```

## Session API

For custom UIs and full control over the verification flow. Create a session, display the QR code, and poll for status updates.

```javascript theme={null}
import "@worldcoin/idkit-standalone";

// Create a session
await IDKitSession.create({
  app_id: "app_ce4cb73cb75fc3b73b71ffb4de178410",
  action: "test-action",
  signal: "user_12345",
  action_description: "Verify your World ID",
  verification_level: "orb",
});

// Get QR code URI
const sessionURI = IDKitSession.getURI();
// Display QR code using your preferred method

// Poll for updates
const status = await IDKitSession.pollStatus();
console.log("State:", status.state); // 'awaiting_connection', 'confirmed', 'failed'

if (status.state === "confirmed" && status.result) {
  // Verify the proof on your backend
  const verifyRes = await fetch("/api/verify", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(status.result),
  });

  if (verifyRes.ok) {
    console.log("Verification successful!");
  } else {
    console.error("Verification failed");
  }
}

// Clean up when done
IDKitSession.destroy();
```

## Backend Verification

**Critical:** You must verify all proofs on your backend. Never trust client-side verification alone.

Your `/api/verify` endpoint should validate the World ID proof:

```javascript theme={null}
// Example Node.js/Express endpoint
app.post("/api/verify", async (req, res) => {
  const { proof, merkle_root, nullifier_hash, verification_level } = req.body;

  try {
    const verifyRes = await fetch(
      "https://developer.worldcoin.org/api/v1/verify/app_your_app_id",
      {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          nullifier_hash,
          merkle_root,
          proof,
          verification_level,
          action: "your-action",
          signal: "your-signal", // Optional: must match frontend
        }),
      }
    );

    if (verifyRes.ok) {
      const { verified } = await verifyRes.json();
      if (verified) {
        // Store nullifier_hash to prevent reuse
        // Grant access to user
        res.json({ success: true });
      } else {
        res.status(400).json({ error: "Invalid proof" });
      }
    } else {
      res.status(400).json({ error: "Verification failed" });
    }
  } catch (error) {
    res.status(500).json({ error: "Verification error" });
  }
});
```

### **Important considerations:**

* Store `nullifier_hash` to prevent proof reuse
* Match `action` and `signal` values between frontend and backend


# API Reference
Source: https://docs.world.org/world-id/reference/api

Developer Portal API for World ID: verify proofs, precheck action metadata, GraphQL, JWKs, and authenticated endpoints.

The Worldcoin Developer Portal offers an API to enable easy verification of World IDs and relevant credentials.

### Base URL

```
https://developer.worldcoin.org
```

<Note>
  All requests to the Developer Portal API must include a `Content-Type:
      application/json` header, a `User-Agent` header, and a valid JSON body.
</Note>

## Verify Proof

<ParamField type="POST">
  [https://developer.worldcoin.org/api/v2/verify/\{app\_id}](https://developer.worldcoin.org/api/v2/verify/\{app_id})
</ParamField>

Enables you to verify a World ID proof for a **Cloud action.** To ensure sybil-resistance, by default, a single person can only verify once for every action. The number of allowed verifications for a single user can be configured in the Developer Portal.

<Note>
  This endpoint is now on **version 2**. The previous version at
  `/api/v1/verify/{app_id}` will be unavailable after June 30, 2024.
</Note>

### Request Body

<ParamField type="string">
  The unique user identifier (called the nullifier hash in the ZKP), as provided
  by IDKit. See [IDKit response](/world-id/reference/idkit#types) for details.
</ParamField>

<ParamField type="string">
  The zero-knowledge proof, as provided by IDKit. See [IDKit
  response](/world-id/reference/idkit#types) for details.
</ParamField>

<ParamField type="string">
  Part of the ZKP, the hash of the Merkle root that proves membership to the set
  of credentials. As provided by IDKit. See [IDKit
  response](/world-id/reference/idkit#types) for details.
</ParamField>

<ParamField type="string">
  The verification level, as provided by IDKit. See [IDKit
  response](/world-id/reference/idkit#types) for details.
</ParamField>

<ParamField type="string">
  Same action identifier as passed to IDKit.
</ParamField>

<ParamField type="string">
  The hash of the signal that was used to generate the proof. Defaults to the
  hash of an empty string.
</ParamField>

<ParamField type="number">
  The maximum age of the root in seconds. This parameter controls how old the
  Merkle root used in the proof can be. Minimum value is 3600 (1 hour) and
  maximum value is 604800 (7 days). Defaults to 7200 (2 hours).
</ParamField>

<CodeGroup title="Request">
  ```bash cURL theme={null}
  curl -X POST "https://developer.worldcoin.org/api/v2/verify/{app_id}" \
      -H "Content-Type: application/json" \
      -d '{
          "nullifier_hash": "0x2bf8406809dcefb1486dadc96c0a897db9bab002053054cf64272db512c6fbd8",
          "merkle_root": "0x2264a66d162d7893e12ea8e3c072c51e785bc085ad655f64c10c1a61e00f0bc2",
          "proof": "0x1aa8b8f3b2d2de5ff452c0e1a83e29d6bf46fb83ef35dc5957121ff3d3698a1119090fb...",
          "verification_level": "orb",
          "action": "my_action",
          "signal_hash": "0x00c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a4"
      }'
  ```

  ```javascript theme={null}
  fetch("https://developer.worldcoin.org/api/v2/verify/{app_id}", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
    },
    body: JSON.stringify({
      nullifier_hash:
        "0x2bf8406809dcefb1486dadc96c0a897db9bab002053054cf64272db512c6fbd8",
      merkle_root:
        "0x2264a66d162d7893e12ea8e3c072c51e785bc085ad655f64c10c1a61e00f0bc2",
      proof:
        "0x1aa8b8f3b2d2de5ff452c0e1a83e29d6bf46fb83ef35dc5957121ff3d3698a1119090fb...",
      verification_level: "orb",
      action: "my_action",
      signal_hash:
        "0x00c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a4",
    }),
  });
  ```
</CodeGroup>

### Possible Responses

* `200 OK` - The proof was successfully verified.
* `400 Bad Request` - The proof was invalid or the user has already verified for this action.

### Response Examples

<Tabs>
  <Tab title="200 OK">
    ```json theme={null}
    {
      "success": true,
      "action": "my_action",
      "nullifier_hash": "0x2bf8406809dcefb1486dadc96c0a897db9bab002053054cf64272db512c6fbd8",
      "created_at": "2023-02-18T11:20:39.530041+00:00"
    }
    ```
  </Tab>

  <Tab title="400 Invalid Proof">
    ```json theme={null}
    {
      "code": "invalid_proof",
      "detail": "The provided proof is invalid and it cannot be verified. Please check all inputs and try again.",
      "attribute": null
    }
    ```
  </Tab>

  <Tab title="400 Invalid Merkle Root">
    ```json theme={null}
    {
      "code": "invalid_merkle_root",
      "detail": "The provided Merkle root is invalid. User appears to be unverified.",
      "attribute": null
    }
    ```
  </Tab>

  <Tab title="400 Invalid Credential Type">
    ```json theme={null}
    {
      "code": "invalid",
      "detail": "Invalid credential type.",
      "attribute": "credential_type"
    }
    ```
  </Tab>

  <Tab title="400 User Exceeded Maximum Verifications">
    ```json theme={null}
    {
      "code": "exceeded_max_verifications",
      "detail": "This user has exceeded the maximum number of verifications allowed for this proof.",
      "attribute": null
    }
    ```
  </Tab>

  <Tab title="400 User Already Verified">
    ```json theme={null}
    {
      "code": "already_verified",
      "detail": "This person has already verified for this action.",
      "attribute": null
    }
    ```
  </Tab>
</Tabs>

## Get Action Metadata

<ParamField type="GET">
  [https://developer.worldcoin.org/api/v1/precheck/\{app\_id}](https://developer.worldcoin.org/api/v1/precheck/\{app_id})
</ParamField>

Enables fetching information about a particular app to determine eligibility for verification. This endpoint is also used by the World ID Kiosk, Sign in with World ID, and World App to show metadata about the action being verified. This endpoint will only return information for active actions.

<Note>Primarily intended for internal use.</Note>

### Request Body

<ParamField type="string">
  The action to check. This is the same action that was passed to IDKit.
  Defaults to an empty string for Sign in with World ID.
</ParamField>

<ParamField type="string">
  The ZKP's nullifier hash, as provided by IDKit. See [IDKit
  response](/world-id/reference/api#response) for details. Defaults to an empty
  string.
</ParamField>

<ParamField type="string">
  **Deprecated.** The ZKP's external nullifier. This parameter is deprecated and
  will be removed in a future release, and should no longer be used. Instead,
  pass the `action` parameter.
</ParamField>

<CodeGroup>
  ```bash title="cURL" theme={null}
  curl -X POST "/api/v1/precheck/{app_id}" \
       -H "Content-Type: application/json" \
       -d '{
               "action": "my_custom_action",
               "nullifier_hash": "0x2bf8406809dcefb1486dadc96c0a897db9bab002053054cf64272db512c6fbd8",
               "external_nullifier": "0x00949dd9a8c5b600304d010ce3a3cf012352070ae4b77504e17af77ee894cda"
           }'
  ```

  ```js title="JavaScript" theme={null}
  fetch(`/api/v1/precheck/${appId}`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
    },
    body: JSON.stringify({
      action: "my_custom_action",
      nullifier_hash:
        "0x2bf8406809dcefb1486dadc96c0a897db9bab002053054cf64272db512c6fbd8",
      external_nullifier:
        "0x00949dd9a8c5b600304d010ce3a3cf012352070ae4b77504e17af77ee894cda",
    }),
  });
  ```
</CodeGroup>

### Response

<ParamField type="string">
  Always returns `app`.
</ParamField>

<ParamField type="string">
  The `app_id` from the Developer Portal.
</ParamField>

<ParamField type="'cloud' | 'on-chain'">
  Whether the app is configured for use with **Cloud** or **On-Chain** proof
  verifications.
</ParamField>

<ParamField type="boolean">
  Whether the app is a staging app. If `true`, the [Worldcoin
  Simulator](https://simulator.worldcoin.org) must be used to verify.
</ParamField>

<ParamField type="string">
  Whether the app has been verified by Worldcoin.
</ParamField>

<ParamField type="string">
  The app's name as configured in the Developer Portal.
</ParamField>

<ParamField type="string">
  The URL of the app's logo. Only returned if the app has been verified,
  otherwise returns an empty string.
</ParamField>

<ParamField type="boolean">
  Whether the action request is for Sign in with World ID.
</ParamField>

<ParamField type="'yes' | 'no' | 'on-chain' | 'undetermined'">
  If the user is eligible to verify for this action.

  <ul>
    <li>
      <code>"yes"</code>: The user has not reached the maximum number of
      verifications for this action based on the <code>nullifier\_hash</code>
      provided. Always returned when <code>is\_sign\_in</code> is
      <code>true</code>.
    </li>

    <li>
      <code>"no"</code>: The user has reached the maximum number of verifications
      for this action based on the <code>nullifier\_hash</code> provided.
    </li>

    <li>
      <code>"undetermined"</code>: A <code>nullifier\_hash</code> was not
      provided, so the user's eligibility cannot be determined.
    </li>

    <li>
      <code>"on-chain"</code>: The app is configured for <strong>On-Chain</strong>
      verifications, so the user's eligibility cannot be determined. Verification
      eligibility is determined solely by the application's smart contract.
    </li>
  </ul>
</ParamField>

<ParamField type="object">
  Information about the action being verified.

  <ul>
    <li>
      <code>name</code>: The action's human-readable name as configured in the
      Developer Portal.
    </li>

    <li>
      <code>action</code>: The action identifier as configured in the Developer
      Portal. Typically a slugified version of the action's name.
    </li>

    <li>
      <code>description</code>: The action's description as configured in the
      Developer Portal.
    </li>

    <li>
      <code>max\_verifications</code>: The maximum number of verifications
      allowed for this action. Will be <code>0</code> if the action is
      configured for unlimited verifications.
    </li>

    <li>
      <code>max\_accounts\_per\_user</code>: The maximum number of accounts allowed
      per user for Sign in with World ID. Will always be <code>1</code>.
    </li>

    <li>
      <code>external\_nullifier</code>: The action's external nullifier.
      <strong>Intended for internal use only.</strong>
    </li>

    <li>
      <code>status</code>: Will return <code>active</code> if the action is
      active, otherwise will return <code>inactive</code>.
    </li>

    <li>
      <code>\_\_typename</code>: Always returns <code>action</code>.
    </li>
  </ul>
</ParamField>

### Response Examples

<Tabs>
  <Tab title="200 OK">
    ```json theme={null}
    {
      "id": "app_staging_4cfd049031b0da1e8b62084b09a9f430",
      "is_staging": true,
      "is_verified": false,
      "name": "Default App",
      "verified_app_logo": "",
      "engine": "cloud",
      "__typename": "app",
      "sign_in_with_world_id": true,
      "can_user_verify": "yes",
      "action": {
        "external_nullifier": "0x00949dd9a8c5b600304d010ce3a3cf012352070ae4b77504e17af77ee894cda",
        "name": "My action",
        "action": "my_custom_action",
        "description": "My action",
        "max_verifications": 0,
        "max_accounts_per_user": 1,
        "__typename": "action"
      }
    }
    ```
  </Tab>

  <Tab title="400 Required">
    ```json theme={null}
    {
      "code": "required",
      "detail": "This attribute is required.",
      "attribute": "action"
    }
    ```
  </Tab>

  <Tab title="400 Action Inactive">
    ```json theme={null}
    {
      "code": "action_inactive",
      "detail": "This action is inactive.",
      "attribute": "status"
    }
    ```
  </Tab>

  <Tab title="404 Not Found">
    ```json theme={null}
    {
      "code": "not_found",
      "detail": "We couldn't find an app with this ID.",
      "attribute": null
    }
    ```
  </Tab>

  <Tab title="405 Method Not Allowed">
    ```json theme={null}
    {
      "code": "method_not_allowed",
      "detail": "HTTP method POST is not allowed for this endpoint.",
      "attribute": null
    }
    ```
  </Tab>
</Tabs>

## Get JWK Keys

<ParamField type="GET">
  [https://developer.worldcoin.org/api/v1/jwks](https://developer.worldcoin.org/api/v1/jwks)
</ParamField>

This endpoint lets you retrieve the JWKs (public keys) used to verify the signature on JSON web tokens that authenticate a verification request from the Developer Portal. This verification method is only used if you are using the **Hosted page user interface.**

<CodeGroup>
  ```bash title="cURL" theme={null}
  curl /api/v1/jwks
  ```

  ```js title="JavaScript" theme={null}
  fetch("/api/v1/jwks");
  ```
</CodeGroup>

### Response

```json theme={null}
{
  "keys": [
    {
      "e": "AQAB",
      "n": "09ETz2k4_9IbDBYK_Tcr6DzbDdJPeqIgvoeUvXNVjNU8mYzFbhdqh8jRH80FwtuoFqyw5oyuG9ILHxfGaG_SeutPWSxBsqulXhxTnTAx2i8HtF0i2toMuvsEtiAjQ3hD4_w2xInBVOO98WAGcNA_UgWAG2DlWpe2km_V5bv3iKteCsSTZtzT3RjEO6FeOlVr8rmx9EGwWITdPIvrEXm_3REFqvDOnQvLu2-Au8m1V3U_6404m4RV_wlWGPnhHfG57VTkkqjgrnFKGUDniG-VMJs-WFX4VIQRvy2z1A5nQsmYpobK_clGyV0D0i5P1A_lmWGDEXBLSjEW9zH_o0d2DQ",
      "kty": "RSA",
      "kid": "jwk_8934bcc47ec5b86dd490cc2a46f18a5e"
    }
  ]
}
```

## Authenticated Endpoints

<Note>
  You can generate API Keys on the **My Team** page of the Developer Portal.
</Note>

* API keys are intended for use by third-party applications and for server-to-server communication. They are long-lived and can be revoked at any time.
* API keys are scoped to a team and have full permissions for any actions as any user of the Developer Portal.
* Once you have an API key, use it as the value of the `Authorization` header in your requests. For example:

```
Authorization: Bearer $API_KEY
```

### GraphQL

<ParamField type="POST">
  [https://developer.worldcoin.org/api/v1/graphql](https://developer.worldcoin.org/api/v1/graphql)
</ParamField>

Interaction with the Developer Portal API is mostly done through a GraphQL endpoint, which enables retrieving information and interacting with any of the API objects. You can read more about [queries](https://hasura.io/docs/latest/graphql/core/api-reference/graphql-api/query/) and [mutations](https://hasura.io/docs/latest/graphql/core/api-reference/graphql-api/mutation/) for GraphQL to help you construct your query.

<CodeGroup>
  ```bash title="cURL" theme={null}
  curl -X POST "/v1/graphql" \
       -H "Content-Type: application/json" \
       -H "Authorization: Bearer $WORLD_ID_TOKEN" \
       -d '{
             "query": "YOUR_GRAPHQL_QUERY_HERE"
           }'
  ```

  ```js title="JavaScript" theme={null}
  fetch("/v1/graphql", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer ${WORLD_ID_TOKEN}`,
    },
    body: JSON.stringify({
      query: "YOUR_GRAPHQL_QUERY_HERE",
    }),
  });
  ```
</CodeGroup>

#### Example Queries

<Tabs>
  <Tab title="Listing Apps">
    ```graphql theme={null}
    query MyApps {
      app {
        id
        name
      }
    }
    ```
  </Tab>

  <Tab title="Listing nullifiers for action">
    ```graphql theme={null}
    query ActionNullifiers($action_id: String) {
      action(where: { id: { _eq: $action_id }, status: { _eq: "active" } }) {
        id
        status
        max_accounts_per_user
        max_verifications
        nullifiers {
          nullifier_hash
        }
      }
    }
    ```
  </Tab>
</Tabs>


# Contract Deployments
Source: https://docs.world.org/world-id/reference/contract-deployments

Addresses for World ID Router and related contracts across Ethereum, World Chain, Optimism, Polygon, and Base.

Here you can find the address and associated ENS name (if available) for all of the World ID contracts. For verifying proofs, the only contract you need to interact with is the `WorldIdRouter` contract, which will properly route the call to the correct contract based on the `groupId` argument.

<Note>
  Only the Orb verification level is supported on-chain, so your `groupId`
  should always be `1`.
</Note>

## Ethereum

<table>
  <thead>
    <tr>
      <th>Contract</th>
      <th>Ethereum Mainnet</th>
      <th>Ethereum Sepolia Testnet</th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>World ID Router</td>

      <td>
        <a href="https://etherscan.io/address/0x163b09b4fe21177c455d850bd815b6d583732432#code">
          id.worldcoin.eth
        </a>
      </td>

      <td>
        <a href="https://sepolia.etherscan.io/address/0x469449f251692e0779667583026b5a1e99512157#code">
          0x469449f2â€¦2157
        </a>
      </td>
    </tr>

    <tr>
      <td>Identity Manager</td>

      <td>
        <a href="https://etherscan.io/address/0xf7134CE138832c1456F2a91D64621eE90c2bddEa#code">
          0xf7134CE1â€¦ddEa
        </a>
      </td>

      <td>
        <a href="https://sepolia.etherscan.io/address/0xb2ead588f14e69266d1b87936b75325181377076#code">
          0xb2ead588â€¦7076
        </a>
      </td>
    </tr>
  </tbody>
</table>

## World Chain

<table>
  <thead>
    <tr>
      <th>Contract</th>
      <th>World Chain</th>

      <th>
        World Chain Sepolia Testnet
      </th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>World ID Router</td>

      <td>
        <a href="https://worldscan.org/address/0x17B354dD2595411ff79041f930e491A4Df39A278">
          0x17B354dDâ€¦A278
        </a>
      </td>

      <td>
        <a href="https://sepolia.worldscan.org/address/0x57f928158C3EE7CDad1e4D8642503c4D0201f611">
          0x57f92815â€¦f611
        </a>
      </td>
    </tr>

    <tr>
      <td>Bridged World ID</td>

      <td>
        <a href="https://worldscan.org/address/0xdFCa0A882eF7793485B3d052142B60647E82009E#code">
          0xdFCa0A88â€¦09E
        </a>
      </td>

      <td>
        <a href="https://sepolia.worldscan.org/address/0xE177F37AF0A862A02edFEa4F59C02668E9d0aAA4">
          0xE177F37Aâ€¦0AA4
        </a>
      </td>
    </tr>
  </tbody>
</table>

## Optimism

<table>
  <thead>
    <tr>
      <th>Contract</th>
      <th>Optimism Mainnet</th>
      <th>Optimism Sepolia Testnet</th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>World ID Router</td>

      <td>
        <a href="https://optimistic.etherscan.io/address/0x57f928158C3EE7CDad1e4D8642503c4D0201f611#code">
          optimism.id.worldcoin.eth
        </a>
      </td>

      <td>
        <a href="https://sepolia-optimism.etherscan.io/address/0x11cA3127182f7583EfC416a8771BD4d11Fae4334#code">
          0x11cA3127â€¦4334
        </a>
      </td>
    </tr>

    <tr>
      <td>Bridged World ID</td>

      <td>
        <a href="https://optimistic.etherscan.io/address/0xB3E7771a6e2d7DD8C0666042B7a07C39b938eb7d#code">
          0xB3E7771aâ€¦eb7d
        </a>
      </td>

      <td>
        <a href="https://sepolia-optimism.etherscan.io/address/0xf07d3efadD82A1F0b4C5Cc3476806d9a170147Ba#code">
          0xf07d3efaâ€¦47Ba
        </a>
      </td>
    </tr>
  </tbody>
</table>

## Polygon

<Warning>
  World ID is currently unavailable on Polygon testnets. Support for [Polygon
  Amoy](https://polygon.technology/blog/introducing-the-amoy-testnet-for-polygon-pos)
  is coming soon.
</Warning>

<table>
  <thead>
    <tr>
      <th>Contract</th>
      <th>Polygon Mainnet</th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>World ID Router</td>

      <td>
        <a href="https://polygonscan.com/address/0x515f06B36E6D3b707eAecBdeD18d8B384944c87f#code">
          polygon.id.worldcoin.eth
        </a>
      </td>
    </tr>

    <tr>
      <td>Bridged World ID</td>

      <td>
        <a href="https://polygonscan.com/address/0xa6d85F3b3bE6Ff6DC52C3aaBe9A35d0ce252b79F#code">
          0xa6d85F3bâ€¦b79F
        </a>
      </td>
    </tr>
  </tbody>
</table>

## Base (Sepolia)

<table>
  <thead>
    <tr>
      <th>Contract</th>
      <th>Base Sepolia Testnet</th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>World ID Router</td>

      <td>
        <a href="https://sepolia.basescan.org/address/0x42FF98C4E85212a5D31358ACbFe76a621b50fC02#code">
          0x42FF98C4â€¦C02
        </a>
      </td>
    </tr>

    <tr>
      <td>Bridged World ID</td>

      <td>
        <a href="https://sepolia.basescan.org/address/0x163b09b4fE21177c455D850BD815B6D583732432#code">
          0x163b09b4â€¦2432
        </a>
      </td>
    </tr>
  </tbody>
</table>


# Smart Contracts
Source: https://docs.world.org/world-id/reference/contracts

World ID smart contracts overview: supported chains, architecture, World ID Router verifyProof, and sybil resistance.

All of our smart contracts are available on GitHub:

* [World ID Smart Contracts](https://github.com/worldcoin/world-id-contracts)
* [State Bridge Smart Contracts](https://github.com/worldcoin/world-id-state-bridge)

<Note>
  If you're interested in using World ID and verifying proofs on-chain, see our
  [On-Chain Verification guide](/world-id/id/on-chain).
</Note>

## Supported Chains

<table>
  <thead>
    <tr>
      <th>Chain</th>
      <th>Testnet</th>
      <th>Role</th>
      <th>Identity Availability</th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        <img alt="World Chain" />

        <strong>World Chain</strong>
      </td>

      <td>World Chain</td>
      <td>Bridged</td>
      <td>\~5 Minutes after Ethereum</td>
    </tr>

    <tr>
      <td>
        <img alt="Ethereum" />

        <strong>Ethereum</strong>
      </td>

      <td>Sepolia</td>
      <td>Canonical</td>
      <td>\~60 minutes after verification</td>
    </tr>

    <tr>
      <td>
        <img alt="Optimism" />

        <strong>Optimism</strong>
      </td>

      <td>Optimism Sepolia</td>
      <td>Bridged</td>
      <td>\~5 Minutes after Ethereum</td>
    </tr>

    <tr>
      <td>
        <img alt="Polygon" />

        <strong>Polygon</strong>
      </td>

      <td>Polygon</td>
      <td>Bridged</td>
      <td>\~40 Minutes after Ethereum</td>
    </tr>

    <tr>
      <td>
        <img alt="Base" />

        <strong>Base (Testnet Only)</strong>
      </td>

      <td>Base Sepolia</td>
      <td>Bridged</td>
      <td>\~5 Minutes after Ethereum Sepolia</td>
    </tr>
  </tbody>
</table>

<Note>
  Find our smart contract [address book
  here](/world-id/reference/contract-deployments).
</Note>

## Architecture

This section offers a high-level overview of the various smart contracts that make up World ID. This structure (including state bridging) is replicated on testnets -- currently Sepolia, Optimism Sepolia, and Base Sepolia.

### Identity Managers: `WorldIdIdentityManager`

Identity Managers are only deployed on Ethereum. The Identity Manager contracts are responsible for managing the Semaphore instance. Worldcoin's signup sequencers call the Identity Manager contracts to add or remove identities from the merkle tree.

### State Bridges: `OpStateBridge`/`PolygonStateBridge`

One State Bridge contract is deployed on Ethereum for each bridged chain. It publishes the root of the merkle tree to its configured chain's World ID contract, allowing proofs to be verified on that chain.

### Bridged World ID: `OpWorldId`/`PolygonWorldId`

One World ID contract is deployed on each bridged chain, with an associated State Bridge contract on Ethereum. It is responsible for receiving merkle roots from its State Bridge contract, and verifying World ID proofs against those roots.

<Note>
  You can deploy your own State Bridge contract on Ethereum and Bridged World ID
  contract to any chain to bridge World ID to that chain permissionlessly.
</Note>

### World ID Router: `WorldIdRouter`

**This is the contract you should interact with.**

The World ID Router will route your call to the correct Identity Manager contract (Ethereum) or World ID contract (L2 Chains) based on the `groupId` argument. This contract is proxied, so you will not need to update your code if the underlying contracts are upgraded.

<Note>
  Only Orb credentials are supported on-chain, so the `groupId` must be `1`.
</Note>

## Usage

The `verifyProof` method of the **World ID Router** is used to verify proofs on-chain.

### Arguments

<table>
  <thead>
    <tr>
      <th>Parameter</th>
      <th>Type</th>
      <th>Required</th>
      <th>Description</th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        <code>root</code>
      </td>

      <td>
        <code>uint256</code>
      </td>

      <td>
        <strong>Yes</strong>
      </td>

      <td>The World ID root to verify against.</td>
    </tr>

    <tr>
      <td>
        <code>groupId</code>
      </td>

      <td>
        <code>uint256</code>
      </td>

      <td>
        <strong>Yes</strong>
      </td>

      <td>
        Determines which Credential Type to verify against. As only Orb
        credentials are supported on-chain, this must be <code>1</code>.
      </td>
    </tr>

    <tr>
      <td>
        <code>signalHash</code>
      </td>

      <td>
        <code>uint256</code>
      </td>

      <td>
        <strong>Yes</strong>
      </td>

      <td>
        The <code>keccak256</code> hash of the signal to verify.
      </td>
    </tr>

    <tr>
      <td>
        <code>nullifierHash</code>
      </td>

      <td>
        <code>uint256</code>
      </td>

      <td>
        <strong>Yes</strong>
      </td>

      <td>
        The root of the merkle tree to verify against. This is obtained from the
        IDKit widget as a hex string <code>nullifier\_hash</code>, and must be
        converted to a <code>uint256</code> before passing it to the
        <code>verifyProof</code> method.
      </td>
    </tr>

    <tr>
      <td>
        <code>externalNullifierHash</code>
      </td>

      <td>
        <code>uint256</code>
      </td>

      <td>
        <strong>Yes</strong>
      </td>

      <td>
        The <code>keccak256</code> hash of the <code>externalNullifier</code> to
        verify. The <code>externalNullifier</code> is computed from the
        <code>app\_id</code> and <code>action</code>.
      </td>
    </tr>

    <tr>
      <td>
        <code>proof</code>
      </td>

      <td>
        <code>uint256\[8]</code>
      </td>

      <td>
        <strong>Yes</strong>
      </td>

      <td>
        The zero-knowledge proof to verify. This is obtained from the IDKit
        widget as a hex string <code>proof</code>, and must be converted to a
        <code>uint256\[8]</code> before passing it to the
        <code>verifyProof</code> method.
      </td>
    </tr>
  </tbody>
</table>

#### Example: groupId

```solidity title="Orb-Only groupId" theme={null}
uint256 internal immutable groupId = 1;
```

#### Example: signalHash

```solidity title="signalHash" theme={null}
abi.encodePacked(signal).hashToField();
```

#### Example: externalNullifierHash

```solidity title="externalNullifierHash" theme={null}
externalNullifier = abi.encodePacked(abi.encodePacked(appId).hashToField(), action)
externalNullifierHash = externalNullifier.hashToField();
```

<Note>Read more about the External Nullifier in Protocol Internals.</Note>

#### Example: Unpacking Proof

<CodeGroup>
  ```ts title="viem" theme={null}
  import { decodeAbiParameters } from 'viem'

  const unpackedProof = decodeAbiParameters([{ type: 'uint256[8]' }], proof)[0]

  ```

  ```ts title="ethers.js" theme={null}
  import { defaultAbiCoder as abi } from '@ethers/utils'

  const unpackedProof = abi.decode(['uint256[8]'], proof)[0]
  ```
</CodeGroup>

### Sybil resistance

While the World ID protocol makes it very easy to make your contracts sybil resistant, this takes a little more than just calling the `verifyProof` function. To make your contract sybil-resistant, you'll need to do the following:

* Store the `nullifierHash` of each user that has successfully verified a proof.
* When a user attempts to verify a proof, check that the `nullifierHash` is not already in the list of used `nullifierHash`es.

Here's an example function doing the above. You can also use the [World ID starter kits](/world-id/id/on-chain) to get started with sybil resistance.

```solidity theme={null}
/// @param root The root (returned by the IDKit widget).
/// @param groupId The group ID
/// @param signal An arbitrary input from the user, usually the user's wallet address
/// @param nullifierHash The nullifier hash for this proof, preventing double signaling (returned by the IDKit widget).
/// @param proof The zero-knowledge proof that demonstrates the claimer is registered with World ID (returned by the IDKit widget).
function verifyAndExecute(
    address signal,
    uint256 root,
    uint256 nullifierHash,
    uint256[8] calldata proof
) public {
    // First make sure this person hasn't done this before
    if (nullifierHashes[nullifierHash]) revert InvalidNullifier();

    // Verify the provided proof is valid and the user is verified by World ID
    worldId.verifyProof(
        root,
        groupId,
        abi.encodePacked(signal).hashToField(),
        nullifierHash,
        externalNullifierHash,
        proof
    );

    // Record the user has done this, so they can't do it again (sybil-resistance)
    nullifierHashes[nullifierHash] = true;

    // Finally, execute your logic here, for example issue a token, NFT, etc...
}
```


# Errors
Source: https://docs.world.org/world-id/reference/errors



This page acts as a reference for the error codes returned by IDKit, the Developer Portal API, and the Wallet Bridge.

## IDKit

These error codes are returned in the `onError` callback. The source described if the error originates from within IDKit or the Wallet Bridge response.

<table>
  <thead>
    <tr>
      <th>Code</th>
      <th>Source</th>
      <th>Description</th>
      <th>How to fix?</th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        <code>failed\_by\_host\_app</code>
      </td>

      <td>IDKit</td>

      <td>
        An error was thrown in the <code>handleVerify</code> callback.
      </td>

      <td>
        Assess the error thrown in your <code>handleVerify</code> callback and
        resolve the issue.
      </td>
    </tr>

    <tr>
      <td>
        <code>connection\_failed</code>
      </td>

      <td>IDKit</td>

      <td>
        Could not establish a connection to World App.
      </td>

      <td>
        Ask the user to check their internet connection on both devices running
        your application and World App. Additionally, make sure the user has the
        latest version of World App.
      </td>
    </tr>

    <tr>
      <td>
        <code>verification\_rejected</code>
      </td>

      <td>Wallet Bridge</td>

      <td>
        User rejected the World ID request in World App.
      </td>

      <td>
        If this was a mistake, ask the user to go through the flow again.
      </td>
    </tr>

    <tr>
      <td>
        <code>max\_verifications\_reached</code>
      </td>

      <td>Wallet Bridge</td>

      <td>
        This person has already verified for this particular action the maximum
        number of times allowed.
      </td>

      <td>
        Nothing to do. User cannot verify for this action again.
      </td>
    </tr>

    <tr>
      <td>
        <code>credential\_unavailable</code>
      </td>

      <td>Wallet Bridge</td>

      <td>
        This user does not have the requested credential.
      </td>

      <td>
        The user must verify at the Orb or verify their unique device in World
        App to receive the credential required.
      </td>
    </tr>

    <tr>
      <td>
        <code>malformed\_request</code>
      </td>

      <td>Wallet Bridge</td>

      <td>
        The request payload couldn't be decrypted or did not conform to the
        standard.
      </td>

      <td>
        Ensure IDKit is configured properly and all parameters are valid. See
        above for configuration details.
      </td>
    </tr>

    <tr>
      <td>
        <code>invalid\_network</code>
      </td>

      <td>Wallet Bridge</td>

      <td>
        The application is configured for a different environment than the
        verifying user's client.
      </td>

      <td>
        Ensure you use the Worldcoin Simulator for Staging applications and
        World App for Production applications.
      </td>
    </tr>

    <tr>
      <td>
        <code>inclusion\_proof\_failed</code>
      </td>

      <td>Wallet Bridge</td>

      <td>
        The sequencer returned an unexpected error when retrieving the inclusion
        proof.
      </td>

      <td>
        Ask the user to try again. This may be due to a temporary network issue,
        or a bug with World App or the Signup Sequencer.
      </td>
    </tr>

    <tr>
      <td>
        <code>inclusion\_proof\_pending</code>
      </td>

      <td>Wallet Bridge</td>

      <td>
        The user might have the requested credential, but it is not available
        on-chain yet. It might be available for API verification.
      </td>

      <td>
        Ask the user to verify again in approximately one hour.
      </td>
    </tr>

    <tr>
      <td>
        <code>metadata\_failed</code>
      </td>

      <td>Wallet Bridge</td>

      <td>
        Unable to load metadata for the app from the Developer Portal.
      </td>

      <td>
        Ensure your <code>app\_id</code> is configured correctly in IDKit and
        exactly matches the <code>app\_id</code> from the Developer Portal.
      </td>
    </tr>

    <tr>
      <td>
        <code>unexpected\_response</code>
      </td>

      <td>IDKit</td>

      <td>
        There was a problem with the response obtained from the WLD app.
      </td>

      <td>
        Check the JS console for further details, though in most cases these
        will require contacting us to report the bug.
      </td>
    </tr>

    <tr>
      <td>
        <code>generic\_error</code>
      </td>

      <td>Wallet Bridge or IDKit</td>
      <td>An unhandled exception occurred.</td>

      <td>
        Check the JS console for further details, though in most cases these
        will require contacting us to report the bug.
      </td>
    </tr>
  </tbody>
</table>

## Developer Portal API

These error codes are returned in the `error` property of the response body.

<table>
  <thead>
    <tr>
      <th>Code</th>
      <th>Description</th>
      <th>How to fix?</th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        <code>required</code>
      </td>

      <td>
        The attribute named in the <code>attribute</code> property is required,
        but was not included in the request.
      </td>

      <td>
        Provide the required attribute in your API request.
      </td>
    </tr>

    <tr>
      <td>
        <code>invalid\_format</code>
      </td>

      <td>
        The attribute named in the <code>attribute</code> property was provided,
        but was in an unexpected format.
      </td>

      <td>
        See the error message for the proper format.
      </td>
    </tr>

    <tr>
      <td>
        <code>unauthenticated</code>
      </td>

      <td>
        The credentials (if provided) were invalid.
      </td>

      <td>
        Provide the required credentials in your API request and ensure they are
        correct.
      </td>
    </tr>

    <tr>
      <td>
        <code>permission\_denied</code>
      </td>

      <td>
        The credentials provided were valid, but you do not have the required
        permissions.
      </td>

      <td>
        Contact your Developer Portal team's owner to be granted permissions, or
        the Worldcoin team if you are unable to resolve the issue.
      </td>
    </tr>

    <tr>
      <td>
        <code>max\_verifications\_reached</code>
      </td>

      <td>
        This person has already verified for this particular action the maximum
        number of times allowed.
      </td>

      <td>
        Nothing to do. User cannot verify for this action again.
      </td>
    </tr>

    <tr>
      <td>
        <code>invalid\_proof</code>
      </td>

      <td>
        The provided proof is invalid and it cannot be verified.
      </td>

      <td>
        Ensure your <code>app\_id</code>, <code>action</code>,
        <code>signal</code>, and <code>verification\_level</code> are unchanged
        between the proof request and proof verification.
      </td>
    </tr>

    <tr>
      <td>
        <code>invalid\_merkle\_root</code>
      </td>

      <td>
        The merkle root provided is not recognized.
      </td>

      <td>
        Ask the user to generate a new proof, the existing proof may be stale.
      </td>
    </tr>

    <tr>
      <td>
        <code>invalid\_network</code>
      </td>

      <td>
        The application is configured for a different environment than the
        verifying user's client.
      </td>

      <td>
        Ensure you use the Worldcoin Simulator for Staging applications and
        World App for Production applications.
      </td>
    </tr>

    <tr>
      <td>
        <code>invalid\_engine</code>
      </td>

      <td>
        The application is configured for on-chain verification and cannot be
        verified via API.
      </td>

      <td>
        Either verify the proof on-chain or create a new application configured
        for Cloud verifications.
      </td>
    </tr>

    <tr>
      <td>
        <code>metadata\_failed</code>
      </td>

      <td>
        Unable to load metadata for the app from the Developer Portal.
      </td>

      <td>
        Ensure your <code>app\_id</code> is configured correctly in IDKit and
        exactly matches the <code>app\_id</code> from the Developer Portal.
      </td>
    </tr>

    <tr>
      <td>
        <code>action\_inactive</code>
      </td>

      <td>
        The requested action is disabled in the Developer Portal.
      </td>

      <td>
        Enable the action or create a new action.
      </td>
    </tr>

    <tr>
      <td>
        <code>verification\_error</code>
      </td>

      <td>
        The Developer Portal faced an internal error verifying the proof.
      </td>

      <td>Contact the Worldcoin team.</td>
    </tr>

    <tr>
      <td>
        <code>internal\_error</code>
      </td>

      <td>
        The Developer Portal faced an internal error verifying the proof.
      </td>

      <td>Contact the Worldcoin team.</td>
    </tr>

    <tr>
      <td>
        <code>unexpected\_response</code>
      </td>

      <td>
        There was a problem with the response obtained from the WLD app.
      </td>

      <td>
        Check the JS console for further details, though in most cases these
        will require contacting us to report the bug.
      </td>
    </tr>

    <tr>
      <td>
        <code>generic\_error</code>
      </td>

      <td>An unhandled exception occurred.</td>

      <td>
        Check the JS console for further details, though in most cases these
        will require contacting us to report the bug.
      </td>
    </tr>
  </tbody>
</table>


# IDKit Reference
Source: https://docs.world.org/world-id/reference/idkit

Reference for IDKit React and Standalone: components, hooks, Session API, verifyCloudProof, types, and advanced config.

<Note>
  IDKit is open source and accepts contributions! Head over to
  [GitHub](https://github.com/worldcoin/idkit-js) and submit a pull request.
</Note>

There are three packages available in the IDKit Monorepo: `@worldcoin/idkit`, `@worldcoin/idkit-standalone`, and `@worldcoin/idkit-core`. The `@worldcoin/idkit` package is the main package that should be used with the React JS framework. The `@worldcoin/idkit-standalone` package is a standalone package that can be used in vanilla JavaScript applications. The `@worldcoin/idkit-core` package is a core functionality package that is used by the other two packages, and should be used only when creating a new IDKit package.

## IDKit (React)

The `@worldcoin/idkit` package is the main package that should be used with the [React framework](https://react.dev/) or any other framework that supports React components, such as [Next.JS](https://nextjs.org/).

### Components

#### `IDKitWidget`

The `IDKitWidget` component is the main component that renders the World ID widget. It should be mounted in your React app and passed the relevant parameters. Accepts a function as a child that receives an `open` function to open the widget.

```jsx theme={null}
import { IDKitWidget } from "@worldcoin/idkit";

<IDKitWidget
  app_id="app_GBkZ1KlVUdFTjeMXKlVUdFT" // obtained from the Developer Portal
  action="vote_1" // this is your action name from the Developer Portal
  signal="user_value" // any arbitrary value the user is committing to, e.g. a vote
  onSuccess={onSuccess}
  verification_level="device" // minimum verification level accepted, defaults to "orb"
>
  {({ open }) => <button onClick={open}>Verify with World ID</button>}
</IDKitWidget>;
```

### Parameters

The following parameters can be passed as props to the `IDKitWidget` component:

<Properties>
  <Property name="app_id" type="string">
    Unique identifier for the app verifying the action. This should be the App
    ID obtained from the [Developer Portal](https://developer.worldcoin.org).
  </Property>

  <Property name="action" type="string">
    Identifier for the action the user is performing. This should be the action
    name set in the Developer Portal.
  </Property>

  <Property name="onSuccess" type="function(ISuccessResult)">
    Function to trigger when verification is successful and the modal is closed.
    Should receive a single parameter of type `ISuccessResult` which contains
    [the proof details.](#response)
  </Property>

  <Property name="handleVerify" type="function(ISuccessResult)">
    Called after the proof is returned from the user's identity wallet (e.g.
    World App), but before showing the success screen. Should receive a single
    parameter of type `ISuccessResult` which contains [the proof
    details.](#response) Throwing an error in this screen will show the user a
    custom error.

    <Note>
      `handleVerify` should be used for API proof verifications to create the
      best user experience. This will show a pending state while the proof is
      verified and present any errors thrown in a user-readable fashion.
    </Note>
  </Property>

  <Property name="onError" type="function(IErrorState)">
    Called when IDKit is closed after an error. Should receive a single
    parameter of type `IErrorState` which contains [the error
    details.](#error-handling)
  </Property>

  <Property name="verification_level" type="string">
    The minimum verification level accepted. Can be `orb` or `device`. Defaults
    to `orb`. **TypeScript apps can use the `VerificationLevel` enum.**
  </Property>

  <Property name="signal" type="string">
    The signal to be included in the zero-knowledge proof. Typically used for
    on-chain actions, read more in [the On-chain
    section](/world-id/id/on-chain).
  </Property>

  <Property name="bridge_url" type="string">
    The URL of the [Wallet Bridge](https://github.com/worldcoin/wallet-bridge)
    to use for establishing a connection between IDKit and the user's World ID
    Wallet. Defaults to the bridge service hosted by Worldcoin. **Only change
    this if you are running your own bridge service.** Read more in Protocol
    Internals.

    <Note type="warning">
      World App will temporarily prevent users from connecting to a Wallet
      Bridge that is not hosted by Worldcoin or Tools for Humanity while
      security reviews are ongoing, so we **recommend using the default value**
      by leaving the `bridge_url` parameter undefined.
    </Note>
  </Property>

  <Property name="autoClose" type="boolean">
    Whether to automatically close the widget after completion. Defaults to
    `true`.
  </Property>

  <Property name="advanced" type="JSON">
    A JSON object containing advanced configuration options that may be unstable
    or subject to change. See [Advanced Configuration](#advanced-configuration)
    for more details.
  </Property>
</Properties>

### Hooks

#### `useIDKit`

The `useIDKit` hook allows you to programmatically open the IDKit widget without mounting any buttons on screen. Note that you still need to mount the component for this to work.

```jsx focus=1,3,6,11 theme={null}
import { IDKitWidget, useIDKit } from "@worldcoin/idkit";

const { open, setOpen } = useIDKit();

useEffect(() => {
  setOpen(true);
}, []);

return (
  <div>
    <IDKitWidget app_id="..." action="..." />
  </div>
);
```

#### `useSession`

The `useSession` hook provides a React-friendly way to handle World ID verification sessions with full control over the UI. It automatically manages session creation and polling for verification updates.

```jsx theme={null}
import { useSession, VerificationState } from "@worldcoin/idkit";

const { status, sessionURI, result, errorCode, reset } = useSession({
  app_id: "app_staging_12345",
  action: "login",
  signal: "user_123",
});

if (status === VerificationState.WaitingForConnection && sessionURI) {
  return <QRCodeSVG value={sessionURI} />;
}

if (status === VerificationState.Confirmed && result) {
  return <div>Verification successful!</div>;
}
```

**Parameters:**

<Properties>
  <Property name="config" type="UseSessionConfig">
    Same configuration options as IDKitWidget
  </Property>
</Properties>

**Returns (UseSessionResult):**

<Properties>
  <Property name="status" type="VerificationState">
    Current verification state
  </Property>

  <Property name="sessionURI" type="string | null">
    QR code URI for users to scan
  </Property>

  <Property name="result" type="ISuccessResult | null">
    Verification result if successful
  </Property>

  <Property name="errorCode" type="AppErrorCodes | null">
    Error code if verification failed
  </Property>

  <Property name="reset" type="() => void">
    Function to reset the session and start over
  </Property>
</Properties>

**Verification States:**

<Properties>
  <Property name="PreparingClient" type="VerificationState">
    Initializing session
  </Property>

  <Property name="WaitingForConnection" type="VerificationState">
    Ready for QR code scan
  </Property>

  <Property name="WaitingForApp" type="VerificationState">
    Waiting for user to verify
  </Property>

  <Property name="Confirmed" type="VerificationState">
    Verification completed successfully
  </Property>

  <Property name="Failed" type="VerificationState">
    Verification failed
  </Property>
</Properties>

### Functions

#### `verifyCloudProof`

The `verifyCloudProof` function is used to verify a proof returned from the user's identity wallet (e.g. World App) against the Developer Portal API. This function is useful for verifying proofs on the server side.

<Properties>
  <Property name="proof" type="ISuccessResult">
    The proof object returned from IDKit.
  </Property>

  <Property name="app_id" type="app_${string}">
    The app\_id obtained from the Developer Portal.
  </Property>

  <Property name="action" type="string">
    The action id from the Developer Portal.
  </Property>

  <Property name="signal" type="string">
    The signal as input to IDKit.
  </Property>

  <Property name="endpoint" type="URL | string">
    The endpoint to send the proof to for verification. Defaults to the
    Worldcoin Developer Portal.
  </Property>
</Properties>

```ts {{ title: 'verifyCloudProof' }} theme={null}
export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  const { proof, action, signal } = req.body;
  const app_id = process.env.APP_ID;
  const response = (await verifyCloudProof(
    proof,
    app_id,
    action,
    signal
  )) as IVerifyResponse;
  res.status(response.success ? 200 : 400).json(response);
}
```

### Types

#### `ISuccessResult`

<Properties>
  <Property name="merkle_root" type="string">
    This is the hash pointer to the root of the Merkle tree that proves membership of the user's identity in the
    list of identities verified by the Orb. ABI encoded.
  </Property>

  <Property name="nullifier_hash" type="string">
    Essentially the user's unique identifier for your app (and specific action if using Incognito Actions). ABI
    encoded.
  </Property>

  <Property name="proof" type="string">
    The Zero-knowledge proof of the verification. ABI encoded.
  </Property>

  <Property name="verification_level" type="&#x22;orb&#x22; | &#x22;device&#x22;">
    Either `orb` or `device`. Returns the verification level used to generate the proof.
  </Property>

  <Property name="credential_type" type="&#x22;orb&#x22; | &#x22;device&#x22;">
    Either `orb` or `device`. Will always return the strongest credential with which a user has been verified.

    <Note type="warning">This property is deprecated and will be removed in a future release. Use `verification_level` instead.</Note>
  </Property>
</Properties>

```json {{ title: 'ISuccessResult' }} theme={null}
{
  "merkle_root": "0x1f38b57f3bdf96f05ea62fa68814871bf0ca8ce4dbe073d8497d5a6b0a53e5e0",
  "nullifier_hash": "0x0339861e70a9bdb6b01a88c7534a3332db915d3d06511b79a5724221a6958fbe",
  "proof": "0x063942fd7ea1616f17787d2e3374c1826ebcd2d41d2394...",
  "verification_level": "orb"
}
```

#### `IErrorState`

<Properties>
  <Property name="code" type="string">
    The error code.
  </Property>

  <Property name="detail" type="string">
    A human-readable description of the error.
  </Property>
</Properties>

```json {{ title: 'IErrorState' }} theme={null}
{
  "code": "already_signed",
  "detail": "User has previously signed and submitted proof for this action."
}
```

#### `IVerifyResult`

<Properties>
  <Property name="success" type="boolean">
    If the proof verification succeeded.
  </Property>

  <Property name="code" type="string | undefined">
    The error code.
  </Property>

  <Property name="detail" type="string | undefined">
    A human-readable description of the error.
  </Property>

  <Property name="attribute" type="string | null | undefined">
    The attribute causing the error.
  </Property>
</Properties>

```json {{ title: 'IVerifyResult' }} theme={null}
{
  "success": false,
  "code": "invalid_proof",
  "detail": "The provided proof is invalid and it cannot be verified. Please check all inputs and try again.",
  "attribute": null
}
```

### Error Handling

An error in IDKit will generally be returned as the input to the `onError` callback. IDKit will display an error to the user and call the `onError` callback with an `IErrorState` object when the modal is closed.

<Note>
  View the [Errors Reference](/world-id/reference/errors) for assistance when
  troubleshooting.
</Note>

## IDKit Standalone

The `@worldcoin/idkit-standalone` package is intended for vanilla JS applications. It is a standalone package that acts as a wrapper around the `@worldcoin/idkit` package.

### Methods

<Note>
  The `.init()` and `.update()` methods take the same parameters as the React
  package's IDKitWidget component. See [above](#parameters) for more details.
</Note>

#### .init()

The `.init()` method is the main initialization method used for vanilla JS apps. It should be called to start up IDKit and configure the widget.

```js theme={null}
import { IDKit } from "@worldcoin/idkit-standalone";

const onSuccess = (result) => {
  // handle success
};

IDKit.init({
  app_id: "app_lshSNnaJfdt6Sohu6YAA",
  action: "my_action",
  onSuccess: onSuccess,
});
```

#### .update()

The `.update()` method reinitializes the widget with new parameters. It can only be called after the `.init()` method.

```js theme={null}
IDKit.update({
  app_id: "app_lshSNnaJfdt6Sohu6YAA",
  action: "my_new_action",
  onSuccess: onSuccess,
});
```

#### .open()

The `.open()` method is used to open the widget. It can only be called after the `.init()` method, typically in response to a button click.

This method returns a Promise object that will resolve when the `onSuccess` callback is called, or reject when the `onError` callback is called.

```js theme={null}
IDKit.open();
```

### Session API

#### `IDKitSession`

The `IDKitSession` object provides a session-based approach to World ID verification with full control over the verification flow. Unlike the widget approach, this gives you complete control over UI and state management.

```jsx theme={null}
import { IDKitSession, VerificationState } from "@worldcoin/idkit";

// Create a session
await IDKitSession.create({
  app_id: "app_staging_12345",
  action: "login",
  signal: "user_123",
});

// Get QR code URI
const sessionURI = IDKitSession.getURI();

// Poll for updates
const status = await IDKitSession.pollStatus();
if (status.state === VerificationState.Confirmed) {
  console.log("Verification successful!", status.result); // Verify the proof in your backend
}

// Clean up
IDKitSession.destroy();
```

#### `IDKitSession.create(config)`

Creates a new World ID verification session. If a session already exists, it will be destroyed and replaced.

<Properties>
  <Property name="config" type="IDKitConfig">
    Same configuration options as IDKitWidget
  </Property>
</Properties>

**Returns:** Promise that resolves when session is created

#### `IDKitSession.getURI()`

Gets the current session URI for QR code generation.

**Returns:** `string | null` - The session URI or null if no active session

#### `IDKitSession.pollStatus()`

Polls for verification updates and returns current session status.

**Returns:** Promise with `SessionStatus` object

<Properties>
  <Property name="state" type="VerificationState">
    Current verification state
  </Property>

  <Property name="result" type="ISuccessResult | null">
    Verification result if successful
  </Property>

  <Property name="errorCode" type="AppErrorCodes | null">
    Error code if verification failed
  </Property>

  <Property name="sessionURI" type="string | null">
    Session URI for QR code generation
  </Property>
</Properties>

#### `IDKitSession.destroy()`

Destroys the current session and cleans up resources.

**Returns:** `void`

#### `IDKitSession.isActive`

Property that returns whether there's an active session.

**Returns:** `boolean`

```jsx theme={null}
if (IDKitSession.isActive) {
  const status = await IDKitSession.pollStatus();
}
```

## Advanced configuration

This section outlines advanced configuration options that may be unstable or subject to change. These options are passed as a JSON object to the `advanced` prop of the `IDKitWidget` component.

### Self-Hosted Applications

Self-hosted applications bypass the Worldcoin Developer Portal entirely. The proof returned **can not be verified by the Developer Portal API.** Instead, you must verify the proof on-chain or with a custom prover service.

When using self-hosted mode, no `app_id` is required, and any value passed to IDKit will be ignored. The `action` you set must have sufficient uniqueness to avoid collisions with other applications. We recommend using a prefix that includes your application name, e.g. `your_app_name_vote_1`.

```jsx theme={null}
import { IDKitWidget } from "@worldcoin/idkit";

<IDKitWidget
  // no app_id is set for self-hosted applications
  action="your_app_name_vote_1" // this is your action, set to whatever you'd like
  signal="user_value"
  onSuccess={onSuccess}
  verification_level="orb" // only orb verifications are supported for self-hosted applications
  advanced={{
    self_hosted: true, // enable the self-hosted mode
  }}
>
  {({ open }) => <button onClick={open}>Verify with World ID</button>}
</IDKitWidget>;
```


# Sign In Reference
Source: https://docs.world.org/world-id/reference/sign-in

OIDC-based Sign in with World ID: discovery, authorize, token exchange, OAuth2 endpoints, introspect, and userinfo.

<Warning>
  **Deprecation Notice**: Sign in with World ID v1 has been deprecated and will
  be shut down on **January 31, 2026**. Read more in the
  [announcement](/world-id/sign-in/deprecation).
</Warning>

<Note>
  Sign in with World ID uses a different base API endpoint than the Developer
  Portal.
</Note>

**Base domain**

```
https://id.worldcoin.org
```

<Note>
  This page primarily describes options that are OIDC-compliant. We additionally
  support using access tokens as described in the OAuth2 standards. No actions
  can be taken on behalf of a user with OAuth2 access tokens, but you may
  retrieve the same information about a user as would be contained in an
  `id_token`. [See below for details.](#oauth2)
</Note>

## OpenID Connect discovery

**GET** `/.well-known/openid-configuration`

Fetches the OpenID Connect discovery document.

### Common Errors

* `method_not_allowed`: HTTP method is not allowed. Only GET and OPTIONS may be used

```bash title="cURL" theme={null}
curl https://id.worldcoin.org/.well-known/openid-configuration
```

```json title="Response" theme={null}
{
  "issuer": "https://id.worldcoin.org",
  "authorization_endpoint": "https://id.worldcoin.org/authorize",
  "token_endpoint": "https://id.worldcoin.org/token",
  "userinfo_endpoint": "https://id.worldcoin.org/userinfo",
  "jwks_uri": "https://id.worldcoin.org/jwks",
  "scopes_supported": ["openid", "email", "profile"],
  "response_types_supported": [
    "code",
    "id_token",
    "id_token token",
    "code id_token"
  ],
  "grant_types_supported": ["authorization_code", "implicit"],
  "subject_types_supported": ["pairwise"],
  "id_token_signing_alg_values_supported": ["RSA"]
}
```

## Authorize

**GET** `/authorize`

Redirect your users to this page to begin the sign-in flow.

### Required attributes

All attributes are formatted as URL query parameters.

| Parameter       | Type     | Description                                                                                                                                                                                                                           |
| --------------- | -------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `response_type` | `string` | Must be `code` for authorization code flow, `id_token` for implicit flow, or a space-separated combination of `code`, `id_token`, and `token` for hybrid flow. We generally recommend using the authorization code or implicit flows. |
| `scope`         | `string` | Space-separated list of the requested OIDC scopes. Must include `openid`, and may optionally include `email` and `profile`.                                                                                                           |
| `client_id`     | `string` | The Client ID of your app. Get this from the Developer Portal.                                                                                                                                                                        |
| `redirect_uri`  | `string` | URL the user will be redirected to after authentication. Must match one of your app's configured `redirect_uris`.                                                                                                                     |

### Optional attributes

| Parameter       | Type     | Description                                                                                                                                                                                                                                                                       |
| --------------- | -------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `state`         | `string` | An opaque value used to maintain state between the request and the callback.                                                                                                                                                                                                      |
| `nonce`         | `string` | **Required when using the implicit flow.** Used to prevent replay attacks. Should be randomly generated for each sign-in, and checked to ensure it's unchanged after the callback.                                                                                                |
| `response_mode` | `string` | Determines how the authorization code, ID token, and/or access token are returned. Must be one of `query`, `fragment`, or `form_post`. `query` is only supported for the authorization code flow. Defaults to `query` for authorization code flow, and `fragment` for all others. |

### Common Errors

* `required`: A necessary attribute was not set. Required attributes are: `response_type scope client_id redirect_uri`
* `invalid_redirect_uri`: The provided redirect URI is invalid. Ensure you've set the correct `redirect_uri` in the Developer Portal.

```http title="Request" theme={null}
https://id.worldcoin.org/authorize?redirect_uri=https%3A%2F%2Fdocs.worldcoin.org%2Fworld-id%2Ftry-callback&response_type=code&scope=openid+profile+email&client_id=app_ce4cb73cb75fc3b73b71ffb4de178410
```

```http title="Response - Authorization Code" theme={null}
https://example.app/api/auth/callback/worldcoin?code=e777d780f437330bbd79535b
```

```http title="Response - ID Token" theme={null}
https://example.app/api/auth/callback/worldcoin#id_token=eyJhbGciOiJSUzI1NiIsInR5cCI6I...
```

## Exchange Code

**POST** `/token`

Exchanges an authorization code for an `id_token` for the given user.

### Required attributes

| Parameter      | Type     | Description                                                  |
| -------------- | -------- | ------------------------------------------------------------ |
| `code`         | `string` | The authorization code to exchange.                          |
| `grant_type`   | `string` | The type of grant to exchange. Must be `authorization_code`. |
| `redirect_uri` | `string` | The same redirect URI used in the `/authorize` request.      |

### Common Errors

* `method_not_allowed`: HTTP method is not allowed. Only POST and OPTIONS may be used
* `invalid_content_type`: The provided content type is invalid, only `application/x-www-form-urlencoded` is supported
* `unauthenticated`: The provided authorization token is invalid, try checking your credentials
* `invalid_grant_type`: The provided grant type is invalid, only `authorization_code` is supported
* `required`: A necessary attribute was not set. Required attributes are: `code`
* `invalid_grant`: The authorization code was invalid, and may be expired. Try generating a new code via `/authorize`

```shell title="cURL" theme={null}
curl -X POST https://id.worldcoin.org/token \
     -H "Authorization: Basic YXBwXzU1MGU4MjkwODJmYzU1OGUxMTJlMDYyMGMxYzdhNT..." \
     -H "Content-Type: application/x-www-form-urlencoded" \
     -d "code=23e5edda0f731dfdddace390&grant_type=authorization_code&redirect_uri=https%3A%2F%2Fdocs.worldcoin.org%2Fapi%2Fauth"
```

```js theme={null}
const data = new URLSearchParams();
data.append("code", "23e5edda0f731dfdddace390");
data.append("grant_type", "authorization_code");
data.append("redirect_uri", "https://docs.worldcoin.org/api/auth");

fetch("https://id.worldcoin.org/token", {
  method: "POST",
  headers: {
    Authorization: `Basic ${btoa(`${client_id}:${client_secret}`)}`,
    "Content-Type": "application/x-www-form-urlencoded",
  },
  body: data,
});
```

```json title="Response" theme={null}
{
  "access_token": "eyJhbGciOiJSUzI1NiIsImtpZCI6Imp3a1.ey8yZmVi.ZjY3MDc3N2UyY2NlNzY5YzUxOG...",
  "token_type": "Bearer",
  "expires_in": 3600,
  "scope": "openid",
  "id_token": "eyJhbGciOiJSUzI1NiIsImtpZCI6Imp3a1.ey8yZmVi.ZjY3MDc3N2UyY2NlNzY5YzUxOG..."
}
```

## OAuth2

If you selected `token` as one of your `response_types` for the `/authorize` endpoint, you'll receive an OAuth2 access token. Typically an access token would allow you to perform certain actions on a user's behalf, but there are no actions to perform for a user in this case.
You can retrieve the same information about a user with an access token as you'd receive in an ID token. While we support this functionality for broader compatibility, we generally recommend using the authorization code or implicit flows, rather than the hybrid flow.

The endpoints below are only used with an OAuth2 access token.

## Introspect

**POST** `/introspect`

Validates the given access token is active for the user.

<Note>
  For introspect, [Basic
  Authentication](https://developer.mozilla.org/en-US/docs/Web/HTTP/Authentication#basic_authentication_scheme)
  is used. The `Authorization` header contains the word "Basic ", followed by a
  base64 encoding of the "client\_id:client\_secret" values. You obtain your
  client\_id (also called app\_id) and client\_secret from the Developer Portal.
</Note>

### Required attributes

| Parameter | Type     | Description                   |
| --------- | -------- | ----------------------------- |
| `token`   | `string` | The access token to validate. |

### Common Errors

* `method_not_allowed`: HTTP method is not allowed. Only POST may be used
* `invalid_content_type`: The provided content type is invalid, only `application/x-www-form-urlencoded` is supported
* `required`: A necessary attribute was not set. Required attributes are: `token`
* `unauthenticated`: The authorization header is missing, please pass the Bearer authorization token
* `invalid_token`: The authorization token was invalid, and may be expired. Try generating a new token via `/token`

```shell title="cURL" theme={null}
curl -X POST https://id.worldcoin.org/introspect \
  -H "Authorization: Basic YXBwXzU1MGU4MjkwODJmYzU1OGUxMTJlMDYyMGMxYzdhNT..." \
  -H "Content-Type: application/x-www-form-urlencoded" \
  --data-urlencode "token=eyJhbGciOiJSUzI1NiIsImtpZCI6Imp3a18yZmViZjY3MDc3N2UyY2NlNzY5YzUxOGM3MDNkNTNjMStN..."
```

```js theme={null}
fetch("https://id.worldcoin.org/introspect", {
  method: "POST",
  headers: {
    Authorization: `Basic ${btoa(`${client_id}:${client_secret}`)}`,
    "Content-Type": "application/x-www-form-urlencoded",
  },
  body: new URLSearchParams({ token }),
});
```

```json title="Response" theme={null}
{
  "active": true,
  "client_id": "app_staging_7550e829082fc558e112e0620c1c7a59",
  "exp": 1678330528,
  "sub": "0x2ae86d6d747702b3b2c81811cd2b39875e8fa6b780ee4a207bdc203a7860b535"
}
```

## Get User Info

**POST** `/userinfo`

Retrieves all user information, based on the approved scopes, with the given access token.

<Note>
  For userinfo, [Bearer
  Authentication](https://developer.mozilla.org/en-US/docs/Web/HTTP/Authentication#bearer_authentication_scheme)
  is used. The `Authorization` header contains the word "Bearer ", followed by
  the access token returned from the `/token` endpoint.
</Note>

### Common Errors

* `method_not_allowed`: HTTP method is not allowed. Only GET, POST, and OPTIONS may be used
* `unauthenticated`: The authorization header is missing, please pass the Bearer authorization token
* `invalid_token`: The authorization token was invalid, and may be expired. Try generating a new token via `/token`

```shell title="cURL" theme={null}
curl -X POST https://id.worldcoin.org/userinfo \
-H "Authorization: Bearer eyJhbGciOiJSUzI1NiIsImtpZ.eyCI6I.mp3a18yZmViZjY3MDc3N2UyY2NlN..."
```

```js theme={null}
fetch("https://id.worldcoin.org/userinfo", {
  method: "POST",
  headers: {
    Authorization: `Bearer ${access_token}`,
  },
});
```

```json title="Response" theme={null}
{
  "sub": "0x2ae86d6d747702b3b2c81811cd2b39875e8fa6b780ee4a207bdc203a7860b535",
  "https://id.worldcoin.org/beta": {
    // deprecated, will be removed in the future
    "likely_human": "strong",
    "credential_type": "orb"
  },
  "https://id.worldcoin.org/v1": {
    "verification_level": "orb" // "orb" or "device"
  },
  // if `email` scope is included:
  "email": "0x2ae86d6d747702b3b2c81811cd2b39875e8fa6b780ee4a207bdc203a7860b535@id.worldcoin.org",
  // if `profile` scope is included:
  "name": "World ID User",
  "given_name": "World ID",
  "family_name": "User"
}
```


# Sunsetting Sign in with World ID
Source: https://docs.world.org/world-id/sign-in/deprecation



<Warning>**Deprecation Notice**: Sign in with World ID v1 has been deprecated and will be shut down on **January 31, 2026**.</Warning>

<Note>The shut down date has been extended from December 12, 2025 to **January 31, 2026** to allow developers and users to finalize their migration.</Note>

As the World ID Protocol evolves, and with the introduction of World ID v25 in 2025, the existing version of Sign in with World ID will no longer be supported. The updated Protocol will provide new functionality and improved privacy guarantees which are no longer compatible with the existing version of Sign in with World ID. The current usage of this feature was taken into consideration.

A new version of Sign in with World ID is planned in the future with enhanced functionality and compatibility with existing standards.

## What are the changes?

* Starting September 29, 2025, no new apps will be able to enable Sign in with World ID.
* The Sign in with World ID API will be shut down (`id.worldcoin.org`) on January 31, 2026.
* The Sign in with World ID functionality in the Developer Portal will be removed.

## What should I do?

* If you are using Sign in with World ID, you should migrate to [IDKit](/world-id/reference/idkit).
* If you are solely using Sign in with World ID for authentication, we recommend migrating your users to different authentication providers. For example, if you are a Mini App, you can migrate to [Wallet Authentication](/mini-apps/commands/wallet-auth). Your users will be able to log in until **January 31, 2026** to add different authentication providers.
* Naturally if you have any questions, please reach out on [Telegram](https://t.me/worlddevelopersupport).

Stay tuned for more updates on the World ID v25 Protocol release.


# OIDC Explainer
Source: https://docs.world.org/world-id/sign-in/oidc



<Warning>**Deprecation Notice**: Sign in with World ID v1 has been deprecated and will be shut down on **January 31, 2026**. Read more in the [announcement](/world-id/sign-in/deprecation).</Warning>

The following diagram outlines the general authentication flow for an integrating app:

<img alt="A diagram showcasing the main authentication flow" />

## Registration

Before OIDC authentication can take place, developers must register their applications with Worldcoin. This is a one-time action. You can create a new application on the [Developer Portal](https://developer.worldcoin.org).

During registration, you will need to provide the following values:

* Redirect URIs: **Required**, list of approved websites the user can be redirected to after successful authentication.
* App name (also called client name): **Optional**, the name of the application that's displayed to users

<Note>
  All redirect URIs must be over HTTPS, and contain no port numbers or URL fragments. For example, `https://app.example.com/login` is valid, but `https://app.example.com:3000/login` is not. Similarly, `https://app.example.com/login#foo` is not valid, but `https://app.example.com/login?foo=bar` is.
</Note>

After registration is complete, you will have a valid `app_id` that will be needed for every other step in the authentication process. This value is equivalent to `client_id` from the [OIDC specification](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest)

## Flows

World ID supports the [authorization code](https://openid.net/specs/openid-connect-core-1_0.html#CodeFlowAuth), [implicit](https://openid.net/specs/openid-connect-core-1_0.html#ImplicitFlowAuth), and [hybrid](https://openid.net/specs/openid-connect-core-1_0.html#HybridFlowAuth) flows from the OIDC spec. Applications can use any one of these flows to authenticate users.

*Generally*, applications should implement the authorization code flow, as it is more secure than the implicit flow. Applications without backend servers (that may be running purely client-side) are more suited to implicit authentication.

## Authentication

Authentication begins with a request to the `/authorize` endpoint.

When using the native Sign in with World ID page, most of the OIDC process is handled for you. You can begin the authentication cycle by redirecting your users to:

```
https://id.worldcoin.org/authorize?client_id={app_id}&response_type={code|token|id_token}&redirect_uri={encoded_redirect_url}&scope={scope}&state={state_value}&nonce={nonce_value}
```

Example values could be:

* `client_id`: obtained from the Developer Portal (example: `app_lshSNnaJfdt6Sohu6YAA`).
* `response_type`: response type as specified in OIDC spec, remember to URL encode (example: `code%20id_token`).
* `redirect_uri`: where the user is redirected upon successful authentication. Must be on the approved redirect URI list which can always be updated in the Developer Portal (example: `https%3A%2F%2Fapp.example.com%2Flogin`).
* `scope`: space-separated list of scopes to request. Defaults to `openid` if not provided. (example: `openid%20profile%20email`).
* `state`: unique value used to track a user's session (example: `session_102030405060708090`).
* `nonce`: random value to prevent replay attacks (example: `z-dkEmoy_ujfk7B8uTiQpp`). Required when using the `id_token` response type.

The user will then authenticate with their World ID via the World app. Once successfully authorized, the user is redirected back to your application. The redirect URL will contain a number of values, depending on the flow you are using.

### Redirect Responses

If using the default authorization code flow, the redirect URL will contain the following params:

* `code`: An authorization code that can be exchanged for an ID token
* `state`: The optional state value passed to the `/authorize` endpoint

If you received a response containing an *authorization code*, you must exchange it for an ID token on the `/token` endpoint. Request details can be [seen here](/world-id/reference/sign-in#exchange-code).

If using implicit flow, the redirect URL will contain the following params:

* `id_token`: A signed JWT identifying the user, and any requested scope information

<Warning>ID tokens must always be verified, and should not be blindly accepted! Additionally, you must validate that the `nonce` within the ID token matches the nonce you provided.</Warning>

To verify an ID token, fetch the public key from the `/jwks` endpoint. You can read more about this process at the [Auth0 blog](https://auth0.com/blog/navigating-rs256-and-jwks/) or [JWT.io](https://jwt.io/), but one example method could be:

```ts theme={null}
import * as jose from 'jose'

const verifyJwt = (token: string) => {
	const JWKS = jose.createRemoteJWKSet(new URL('https://id.worldcoin.org/jwks.json'))

	const { payload, header } = await jose.jwtVerify(token, JWKS, {
		issuer: 'https://id.worldcoin.org',
		aud: 'app_lshSNnaJfdt6Sohu6YAA',
	})

	return payload
}

verifyJwt('eyJhbGciOiJSUzI1NiIsInR5cCI6Ikp.eyAs.XVCJ9...')
```


